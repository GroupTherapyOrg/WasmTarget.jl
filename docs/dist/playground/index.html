<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground - WasmTarget.jl</title>
    <base href="/WasmTarget.jl/">
    <link rel="stylesheet" href="/WasmTarget.jl/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Source+Sans+3:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        html { scroll-behavior: smooth; }
        pre code { font-family: 'Fira Code', 'Monaco', 'Consolas', monospace; }
    </style>
    <script>
        (function() {
            try {
                const saved = localStorage.getItem('therapy-theme');
                if (saved === 'dark' || (!saved && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                }
            } catch (e) {}
        })();
    </script>
</head>
<body class="antialiased">
<div id="therapy-content">
<div data-hk="1" class="min-h-screen bg-stone-50 dark:bg-stone-900 transition-colors duration-200"><nav data-hk="2" class="bg-white dark:bg-stone-800 border-b border-stone-200 dark:border-stone-700 transition-colors duration-200"><div data-hk="3" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div data-hk="4" class="flex justify-between h-16"><div data-hk="5" class="flex items-center"><a data-hk="6" class="flex items-center" href="./"><span data-hk="7" class="text-2xl font-bold text-cyan-500 dark:text-cyan-400">WasmTarget</span><span data-hk="8" class="text-2xl font-light text-stone-400 dark:text-stone-500">.jl</span></a></div><div data-hk="9" class="hidden sm:flex sm:items-center sm:space-x-6"><a data-hk="10" data-active-class="text-cyan-600 dark:text-cyan-400 font-semibold" class="text-stone-600 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white px-3 py-2 text-sm font-medium transition-colors" href="./" data-navlink="true" data-exact="true">Home</a><a data-hk="11" data-active-class="text-cyan-600 dark:text-cyan-400 font-semibold" class="text-stone-600 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white px-3 py-2 text-sm font-medium transition-colors" href="./playground/" data-navlink="true">Playground</a><a data-hk="12" data-active-class="text-cyan-600 dark:text-cyan-400 font-semibold" class="text-stone-600 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white px-3 py-2 text-sm font-medium transition-colors" href="./manual/" data-navlink="true">Manual</a><a data-hk="13" data-active-class="text-cyan-600 dark:text-cyan-400 font-semibold" class="text-stone-600 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white px-3 py-2 text-sm font-medium transition-colors" href="./features/" data-navlink="true" data-exact="true">Features</a><a data-hk="14" data-active-class="text-cyan-600 dark:text-cyan-400 font-semibold" class="text-stone-600 dark:text-stone-300 hover:text-stone-900 dark:hover:text-white px-3 py-2 text-sm font-medium transition-colors" href="./api/" data-navlink="true" data-exact="true">API</a><a data-hk="15" class="text-stone-500 hover:text-stone-700 dark:text-stone-400 dark:hover:text-stone-200 transition-colors" href="https://github.com/GroupTherapyOrg/WasmTarget.jl" title="View on GitHub" target="_blank"><svg data-hk="16" viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor"><path data-hk="17" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a><div data-hk="18" class="ml-2"><therapy-island data-component="themetoggle"><div data-hk="1" dark-mode="Therapy.SignalGetter{Int32}(Therapy.Signal{Int32}(0x000000000000009d, 0, Set{Any}()))"><button data-hk="2" class="p-2 rounded-lg hover:bg-stone-100 dark:hover:bg-stone-700 transition-colors" title="Toggle dark mode"><svg data-hk="3" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-stone-600 dark:text-stone-300" fill="none"><path data-hk="4" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></therapy-island></div></div></div></div></nav><main data-hk="19" id="page-content" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div data-hk="1" class="w-full -mx-4 sm:-mx-6 lg:-mx-8 px-4 sm:px-6 lg:px-8"><div data-hk="2" class="text-center mb-6"><h1 data-hk="3" class="text-3xl font-bold text-stone-800 dark:text-stone-100">Julia Playground</h1><p data-hk="4" class="text-stone-500 dark:text-stone-400 mt-2 max-w-2xl mx-auto">Write and run Julia code directly in your browser. Powered by a Julia interpreter compiled to WebAssembly by WasmTarget.jl.</p></div><div data-hk="5" class="border border-stone-700 rounded-xl overflow-hidden shadow-lg"><div data-hk="6" class="flex flex-col h-full min-h-[600px]"><div data-hk="7" class="flex items-center justify-between px-4 py-3 bg-stone-800 dark:bg-stone-900 border-b border-stone-700"><div data-hk="8" class="flex items-center gap-3"><span data-hk="9" class="text-stone-200 font-semibold">Julia Playground</span><span data-hk="10" class="text-stone-500 text-sm">Powered by WasmTarget.jl</span></div><div data-hk="11" class="flex items-center gap-3"><div data-hk="12" id="interpreter-status" class="flex items-center gap-2"><span data-hk="13" id="status-dot" class="w-2 h-2 rounded-full bg-yellow-500"></span><span data-hk="14" id="status-text" class="text-stone-400 text-xs">Loading...</span></div><button data-hk="15" id="run-button" class="px-4 py-2 bg-cyan-500 hover:bg-cyan-600 disabled:bg-stone-600 disabled:cursor-not-allowed text-white rounded-lg font-medium flex items-center gap-2 transition-colors"><svg data-hk="16" viewBox="0 0 24 24" class="w-4 h-4" fill="currentColor"><path data-hk="17" d="M8 5v14l11-7z"></path></svg><span data-hk="18">Run</span></button></div></div><div data-hk="19" class="flex-1 grid lg:grid-cols-2 gap-0 min-h-0"><div data-hk="20" class="flex flex-col min-h-0 border-r border-stone-700"><div data-hk="21" class="flex items-center justify-between px-4 py-2 bg-stone-700 dark:bg-stone-800"><span data-hk="22" class="text-stone-300 text-sm font-medium">Code</span><div data-hk="23" class="flex items-center gap-2"><button data-hk="24" id="clear-button" class="text-stone-400 hover:text-white text-xs transition-colors">Clear</button><select data-hk="25" id="example-selector" class="bg-stone-600 text-stone-200 text-xs rounded px-2 py-1"><option data-hk="26" value="">Examples...</option><option data-hk="27" value="hello">Hello World</option><option data-hk="28" value="arithmetic">Arithmetic</option><option data-hk="29" value="functions">Functions</option><option data-hk="30" value="loops">Loops</option><option data-hk="31" value="factorial">Factorial</option><option data-hk="32" value="fibonacci">Fibonacci</option></select></div></div><div data-hk="33" id="editor-container" class="flex-1 overflow-hidden bg-stone-900"></div></div><div data-hk="34" class="flex flex-col min-h-0"><div data-hk="35" class="flex items-center justify-between px-4 py-2 bg-stone-700 dark:bg-stone-800"><span data-hk="36" class="text-stone-300 text-sm font-medium">Output</span><button data-hk="37" id="clear-output-button" class="text-stone-400 hover:text-white text-xs transition-colors">Clear</button></div><div data-hk="38" id="output-container" class="flex-1 overflow-auto bg-stone-900 p-4 font-mono text-sm"><div data-hk="39" id="output-content" class="text-stone-400">Click &quot;Run&quot; to execute your code...</div></div></div></div><link data-hk="40" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css" rel="stylesheet" /><script>    (function() {
        // Configuration
        const INITIAL_CODE = `# Welcome to the Julia Playground!
# This code runs entirely in your browser via WasmGC.

# Try some basic arithmetic
x = 5
y = 3
println(x + y)

# Define a function
function greet(name)
    println("Hello, " * name * "!")
end

greet("World")
`;

        // State
        let editor = null;
        let interpreterModule = null;
        let interpreterReady = false;

        // DOM elements
        const editorContainer = document.getElementById('editor-container');
        const outputContent = document.getElementById('output-content');
        const runButton = document.getElementById('run-button');
        const clearButton = document.getElementById('clear-button');
        const clearOutputButton = document.getElementById('clear-output-button');
        const exampleSelector = document.getElementById('example-selector');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        // Example code snippets
        const examples = {
            hello: `# Hello World
println("Hello, World!")
`,
            arithmetic: `# Basic Arithmetic
a = 10
b = 3

println("a + b = ", a + b)
println("a - b = ", a - b)
println("a * b = ", a * b)
println("a / b = ", a / b)
println("a % b = ", a % b)
`,
            functions: `# Functions
function greet(name)
    println("Hello, " * name * "!")
end

function add(a, b)
    return a + b
end

greet("Julia")
println("2 + 3 = ", add(2, 3))
`,
            loops: `# Loops
println("While loop:")
i = 1
while i <= 5
    println(i)
    i = i + 1
end

println("For loop:")
for j in 5
    println(j)
end
`,
            factorial: `# Factorial (Recursive)
function factorial(n)
    if n <= 1
        return 1
    end
    return n * factorial(n - 1)
end

println("factorial(5) = ", factorial(5))
println("factorial(10) = ", factorial(10))
`,
            fibonacci: `# Fibonacci (Recursive)
function fib(n)
    if n <= 1
        return n
    end
    return fib(n - 1) + fib(n - 2)
end

println("Fibonacci sequence:")
for i in 10
    println("fib(", i, ") = ", fib(i))
end
`
        };

        // Update status indicator
        function updateStatus(state, text) {
            if (statusDot && statusText) {
                statusText.textContent = text;
                statusDot.className = 'w-2 h-2 rounded-full ';
                switch(state) {
                    case 'ready':
                        statusDot.className += 'bg-green-500';
                        break;
                    case 'loading':
                        statusDot.className += 'bg-yellow-500 animate-pulse';
                        break;
                    case 'running':
                        statusDot.className += 'bg-cyan-500 animate-pulse';
                        break;
                    case 'error':
                        statusDot.className += 'bg-red-500';
                        break;
                    default:
                        statusDot.className += 'bg-stone-500';
                }
            }
        }

        // Append output
        function appendOutput(text, isError = false) {
            if (outputContent) {
                const line = document.createElement('div');
                line.className = isError ? 'text-red-400' : 'text-green-400';
                line.textContent = text;
                outputContent.appendChild(line);
                outputContent.scrollTop = outputContent.scrollHeight;
            }
        }

        // Clear output
        function clearOutput() {
            if (outputContent) {
                outputContent.innerHTML = '';
            }
        }

        // Initialize CodeMirror 6
        async function initEditor() {
            updateStatus('loading', 'Loading editor...');

            // Load CodeMirror 6 modules from esm.sh
            try {
                const [{EditorState}, {EditorView, keymap, lineNumbers, highlightActiveLineGutter, highlightSpecialChars, drawSelection, dropCursor, rectangularSelection, crosshairCursor}, {defaultHighlightStyle, syntaxHighlighting, indentOnInput, bracketMatching, foldGutter, foldKeymap}, {defaultKeymap, history, historyKeymap}, {closeBrackets, closeBracketsKeymap, autocompletion, completionKeymap}, {highlightSelectionMatches, searchKeymap}] = await Promise.all([
                    import('https://esm.sh/@codemirror/state@6'),
                    import('https://esm.sh/@codemirror/view@6'),
                    import('https://esm.sh/@codemirror/language@6'),
                    import('https://esm.sh/@codemirror/commands@6'),
                    import('https://esm.sh/@codemirror/autocomplete@6'),
                    import('https://esm.sh/@codemirror/search@6')
                ]);

                // Create a simple Julia-like syntax (basic tokenizer)
                const juliaTheme = EditorView.theme({
                    '&': {
                        backgroundColor: '#1c1917',
                        color: '#e7e5e4',
                        height: '100%'
                    },
                    '.cm-content': {
                        fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
                        padding: '16px'
                    },
                    '.cm-gutters': {
                        backgroundColor: '#292524',
                        color: '#78716c',
                        border: 'none'
                    },
                    '.cm-activeLineGutter': {
                        backgroundColor: '#44403c'
                    },
                    '.cm-activeLine': {
                        backgroundColor: 'rgba(68, 64, 60, 0.4)'
                    },
                    '.cm-cursor': {
                        borderLeftColor: '#22d3ee'
                    },
                    '.cm-selectionBackground': {
                        backgroundColor: '#0e7490 !important'
                    },
                    '&.cm-focused .cm-selectionBackground': {
                        backgroundColor: '#0e7490 !important'
                    }
                });

                // Create editor
                const startState = EditorState.create({
                    doc: INITIAL_CODE,
                    extensions: [
                        lineNumbers(),
                        highlightActiveLineGutter(),
                        highlightSpecialChars(),
                        history(),
                        foldGutter(),
                        drawSelection(),
                        dropCursor(),
                        EditorState.allowMultipleSelections.of(true),
                        indentOnInput(),
                        syntaxHighlighting(defaultHighlightStyle, {fallback: true}),
                        bracketMatching(),
                        closeBrackets(),
                        autocompletion(),
                        rectangularSelection(),
                        crosshairCursor(),
                        highlightSelectionMatches(),
                        keymap.of([
                            ...closeBracketsKeymap,
                            ...defaultKeymap,
                            ...searchKeymap,
                            ...historyKeymap,
                            ...foldKeymap,
                            ...completionKeymap,
                            // Ctrl/Cmd+Enter to run
                            {
                                key: 'Mod-Enter',
                                run: () => { runCode(); return true; }
                            }
                        ]),
                        juliaTheme
                    ]
                });

                editor = new EditorView({
                    state: startState,
                    parent: editorContainer
                });

                console.log('CodeMirror initialized');
            } catch (err) {
                console.error('Failed to load CodeMirror:', err);
                // Fallback to textarea
                editorContainer.innerHTML = '<textarea id="fallback-editor" class="w-full h-full bg-stone-900 text-stone-100 p-4 font-mono text-sm resize-none focus:outline-none" spellcheck="false">' + INITIAL_CODE + '</textarea>';
            }
        }

        // Initialize WasmGC interpreter
        async function initInterpreter() {
            updateStatus('loading', 'Loading WasmGC interpreter...');

            try {
                // Load the real WasmGC interpreter compiled by WasmTarget.jl
                // Try multiple paths for different deployment scenarios
                const wasmPaths = [
                    '/WasmTarget.jl/wasm/interpreter.wasm',  // GitHub Pages with base_path
                    '/wasm/interpreter.wasm',                 // Local dev without base_path
                    './wasm/interpreter.wasm',                // Relative from current page
                    '/dist/wasm/interpreter.wasm',            // Alternative path
                ];

                // Math.pow import required by the interpreter
                const importObject = {
                    Math: {
                        pow: Math.pow
                    }
                };

                let instance = null;
                let loadedPath = null;

                for (const wasmPath of wasmPaths) {
                    try {
                        const response = await fetch(wasmPath);
                        if (response.ok) {
                            const result = await WebAssembly.instantiateStreaming(response, importObject);
                            instance = result.instance;
                            loadedPath = wasmPath;
                            break;
                        }
                    } catch (e) {
                        console.log('Failed to load from ' + wasmPath + ':', e.message);
                    }
                }

                if (!instance) {
                    throw new Error('Could not load interpreter.wasm from any path');
                }

                interpreterModule = instance;
                interpreterReady = true;

                updateStatus('ready', 'WasmGC Ready');

                if (runButton) {
                    runButton.disabled = false;
                }

                console.log('WasmGC interpreter loaded from:', loadedPath);
                console.log('Available exports:', Object.keys(instance.exports));
            } catch (err) {
                console.error('Failed to load WasmGC interpreter:', err);
                console.log('Falling back to JavaScript interpreter...');

                // Fallback to JS interpreter if WASM fails
                interpreterReady = true;
                updateStatus('ready', 'Ready (JS fallback)');

                if (runButton) {
                    runButton.disabled = false;
                }
            }
        }

        // String marshaling helpers for WasmGC
        // WasmGC strings are i32 arrays, JS strings are UTF-16
        function jsToWasmString(jsStr, exports) {
            // Create a WASM string using str_new and str_setchar!
            const len = jsStr.length;
            const wasmStr = exports.str_new(len);
            for (let i = 0; i < len; i++) {
                exports['str_setchar!'](wasmStr, i + 1, jsStr.charCodeAt(i));
            }
            return wasmStr;
        }

        function wasmToJsString(wasmStr, exports) {
            // Read a WASM string using str_len and str_char
            if (!wasmStr) return '';
            const len = exports.str_len(wasmStr);
            let result = '';
            for (let i = 0; i < len; i++) {
                result += String.fromCharCode(exports.str_char(wasmStr, i + 1));
            }
            return result;
        }

        // Simple JavaScript interpreter for basic Julia syntax
        // This is a placeholder until the WasmGC interpreter is ready
        function interpretJS(code) {
            const output = [];
            const env = {};

            // Split into statements
            const lines = code.split(/[;\n]+/).filter(l => l.trim() && !l.trim().startsWith('#'));

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                // Handle println
                const printMatch = trimmed.match(/^println\((.*)\)$/);
                if (printMatch) {
                    try {
                        const args = printMatch[1];
                        // Simple evaluation
                        const result = evalExpr(args, env);
                        output.push(String(result));
                    } catch (e) {
                        output.push('Error: ' + e.message);
                    }
                    continue;
                }

                // Handle assignment
                const assignMatch = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
                if (assignMatch) {
                    const [, name, expr] = assignMatch;
                    try {
                        env[name] = evalExpr(expr, env);
                    } catch (e) {
                        output.push('Error in assignment: ' + e.message);
                    }
                    continue;
                }
            }

            return output.join('\n');
        }

        // Simple expression evaluator
        function evalExpr(expr, env) {
            expr = expr.trim();

            // String literal
            if (expr.startsWith('"') && expr.endsWith('"')) {
                return expr.slice(1, -1);
            }

            // Number literal
            if (/^-?\d+(\.\d+)?$/.test(expr)) {
                return parseFloat(expr);
            }

            // Variable lookup
            if (/^\w+$/.test(expr) && expr in env) {
                return env[expr];
            }

            // String concatenation with *
            if (expr.includes(' * ')) {
                const parts = expr.split(' * ').map(p => evalExpr(p.trim(), env));
                return parts.join('');
            }

            // Addition
            if (expr.includes(' + ')) {
                const parts = expr.split(' + ').map(p => evalExpr(p.trim(), env));
                if (typeof parts[0] === 'string') {
                    return parts.join('');
                }
                return parts.reduce((a, b) => a + b, 0);
            }

            // Subtraction
            if (expr.includes(' - ')) {
                const parts = expr.split(' - ').map(p => evalExpr(p.trim(), env));
                return parts.reduce((a, b) => a - b);
            }

            // Multiplication
            if (expr.includes(' * ') && !expr.includes('"')) {
                const parts = expr.split(' * ').map(p => evalExpr(p.trim(), env));
                return parts.reduce((a, b) => a * b, 1);
            }

            // Division
            if (expr.includes(' / ')) {
                const parts = expr.split(' / ').map(p => evalExpr(p.trim(), env));
                return parts.reduce((a, b) => a / b);
            }

            return expr;
        }

        // Run code using WasmGC interpreter
        function runCode() {
            if (!interpreterReady) return;

            const code = getEditorContent();
            if (!code.trim()) {
                clearOutput();
                appendOutput('No code to run', true);
                return;
            }

            updateStatus('running', 'Running...');
            clearOutput();

            try {
                let result;

                if (interpreterModule && interpreterModule.exports.interpret) {
                    // Use real WasmGC interpreter
                    const exports = interpreterModule.exports;

                    try {
                        // Convert JS string to WASM string
                        const wasmCode = jsToWasmString(code, exports);

                        // Clear output buffer before running
                        if (exports.clear_output) {
                            exports.clear_output();
                        }

                        // Call the interpreter
                        exports.interpret(wasmCode);

                        // Get output from the interpreter's output buffer
                        if (exports.get_output) {
                            const wasmOutput = exports.get_output();
                            result = wasmToJsString(wasmOutput, exports);
                        }
                    } catch (wasmErr) {
                        console.error('WASM execution error:', wasmErr);
                        // Fall back to JS interpreter
                        result = interpretJS(code);
                    }
                } else {
                    // Use JS interpreter as fallback
                    result = interpretJS(code);
                }

                if (result) {
                    String(result).split('\n').forEach(line => {
                        if (line.trim()) appendOutput(line);
                    });
                }
                appendOutput('\n--- Execution complete ---', false);
                updateStatus('ready', interpreterModule ? 'WasmGC Ready' : 'Ready');
            } catch (err) {
                appendOutput('Error: ' + err.message, true);
                updateStatus('error', 'Error');
            }
        }

        // Get editor content
        function getEditorContent() {
            if (editor) {
                return editor.state.doc.toString();
            }
            const fallback = document.getElementById('fallback-editor');
            if (fallback) {
                return fallback.value;
            }
            return '';
        }

        // Set editor content
        function setEditorContent(code) {
            if (editor) {
                editor.dispatch({
                    changes: { from: 0, to: editor.state.doc.length, insert: code }
                });
            } else {
                const fallback = document.getElementById('fallback-editor');
                if (fallback) {
                    fallback.value = code;
                }
            }
        }

        // Event listeners
        if (runButton) {
            runButton.addEventListener('click', runCode);
        }

        if (clearButton) {
            clearButton.addEventListener('click', () => {
                setEditorContent('');
            });
        }

        if (clearOutputButton) {
            clearOutputButton.addEventListener('click', clearOutput);
        }

        if (exampleSelector) {
            exampleSelector.addEventListener('change', (e) => {
                const exampleId = e.target.value;
                if (exampleId && examples[exampleId]) {
                    setEditorContent(examples[exampleId]);
                }
                e.target.value = '';
            });
        }

        // Initialize
        (async function() {
            await initEditor();
            await initInterpreter();
        })();
    })();
    </script></div></div><div data-hk="41" class="mt-8 grid md:grid-cols-3 gap-6"><div data-hk="42" class="p-6 bg-stone-100 dark:bg-stone-800 rounded-xl"><h3 data-hk="43" class="text-lg font-semibold text-stone-800 dark:text-stone-100 mb-3">How It Works</h3><p data-hk="44" class="text-stone-600 dark:text-stone-400 text-sm">This playground runs a Julia interpreter that was written in Julia and compiled to WebAssembly (WasmGC) using WasmTarget.jl. Your code is parsed and executed entirely in your browser - no server required.</p></div><div data-hk="45" class="p-6 bg-stone-100 dark:bg-stone-800 rounded-xl"><h3 data-hk="46" class="text-lg font-semibold text-stone-800 dark:text-stone-100 mb-3">Supported Features</h3><ul data-hk="47" class="text-stone-600 dark:text-stone-400 text-sm space-y-1"><li data-hk="48">Variables and assignment</li><li data-hk="49">Arithmetic operations</li><li data-hk="50">Function definitions</li><li data-hk="51">If/else conditionals</li><li data-hk="52">While and for loops</li><li data-hk="53">Recursion</li><li data-hk="54">String operations</li><li data-hk="55">println() output</li></ul></div><div data-hk="56" class="p-6 bg-stone-100 dark:bg-stone-800 rounded-xl"><h3 data-hk="57" class="text-lg font-semibold text-stone-800 dark:text-stone-100 mb-3">Keyboard Shortcuts</h3><ul data-hk="58" class="text-stone-600 dark:text-stone-400 text-sm space-y-1"><li data-hk="59"><code data-hk="60" class="bg-stone-200 dark:bg-stone-700 px-1 rounded">Ctrl</code> + <code data-hk="61" class="bg-stone-200 dark:bg-stone-700 px-1 rounded">Enter</code> - Run code</li><li data-hk="62"><code data-hk="63" class="bg-stone-200 dark:bg-stone-700 px-1 rounded">Tab</code> - Indent</li><li data-hk="64"><code data-hk="65" class="bg-stone-200 dark:bg-stone-700 px-1 rounded">Ctrl</code> + <code data-hk="66" class="bg-stone-200 dark:bg-stone-700 px-1 rounded">Z</code> - Undo</li></ul></div></div><div data-hk="67" class="mt-6 p-4 bg-cyan-50 dark:bg-cyan-900/20 border border-cyan-200 dark:border-cyan-800 rounded-xl"><div data-hk="68" class="flex items-start gap-3"><div data-hk="69" class="flex-shrink-0 w-8 h-8 bg-cyan-500 rounded-full flex items-center justify-center"><svg data-hk="70" viewBox="0 0 24 24" stroke="currentColor" class="w-4 h-4 text-white" fill="none"><path data-hk="71" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><div data-hk="72" class="flex-1"><p data-hk="73" class="text-stone-700 dark:text-stone-200 font-medium text-sm">100% Browser-Based</p><p data-hk="74" class="text-stone-500 dark:text-stone-400 text-xs mt-1">This playground runs entirely in your browser using WebAssembly. No code is sent to any server. The interpreter is built using WasmTarget.jl&#39;s WasmGC compilation, demonstrating that Julia can run in the browser without a traditional server backend.</p></div></div></div></div></main><footer data-hk="20" class="bg-white dark:bg-stone-800 border-t border-stone-200 dark:border-stone-700 mt-auto transition-colors duration-200"><div data-hk="21" class="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8"><div data-hk="22" class="flex justify-between items-center"><p data-hk="23" class="text-stone-500 dark:text-stone-400 text-sm">Built with <a data-hk="24" class="text-cyan-500 dark:text-cyan-400 hover:text-cyan-600 dark:hover:text-cyan-300" href="https://github.com/GroupTherapyOrg/Therapy.jl" target="_blank">Therapy.jl</a> - Powered by <a data-hk="25" class="text-cyan-500 dark:text-cyan-400 hover:text-cyan-600 dark:hover:text-cyan-300" href="./">WasmTarget.jl</a></p><p data-hk="26" class="text-stone-400 dark:text-stone-500 text-sm">MIT License</p></div></div></footer></div>
</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-julia.min.js"></script>
    <script>
// Therapy.jl Hydration - ThemeToggle
// Registered globally for re-hydration after client-side navigation
(function() {
    'use strict';

    // Initialize global hydration registry
    window.TherapyHydrate = window.TherapyHydrate || {};

    // Global tracking of in-flight hydrations (prevents duplicate WASM fetches under rapid clicks)
    // This is CRITICAL because content swaps remove DOM elements, invalidating data-hydrating attrs
    window._therapyHydrating = window._therapyHydrating || {};
    if (window._therapyHydrating['themetoggle']) {
        console.log('%c[Hydration] ThemeToggle - hydration already in progress (global guard)', 'color: #ffa500');
        return;
    }

    // Hydration function for this component
    async function hydrate_themetoggle() {
        // CRITICAL: Global guard against duplicate hydration during rapid clicks
        // This must be checked BEFORE any async operations (fetch, etc.)
        // The IIFE-level guard only works for the first script load; this handles re-execution
        if (window._therapyHydrating['themetoggle']) {
            console.log('%c[Hydration] ThemeToggle - hydration already in progress (function guard)', 'color: #ffa500');
            return;
        }
        // Mark as hydrating IMMEDIATELY before any async operations
        window._therapyHydrating['themetoggle'] = true;

        console.log('%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'color: #e94560');
        console.log('%c  Therapy.jl - Hydrating ThemeToggle', 'color: #e94560; font-weight: bold');
        console.log('%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'color: #e94560');

        try {
        // Signals discovered:
        // signal_142: 0 (Int32)

        const container = document.querySelector('therapy-island[data-component="themetoggle"]');
        if (!container) {
            console.error('[Hydration] Container not found: therapy-island[data-component="themetoggle"]');
            console.error('[Hydration] Available therapy-islands:', document.querySelectorAll('therapy-island').length);
            document.querySelectorAll('therapy-island').forEach(el => console.log('  Found island:', el.dataset.component));
            return;
        }

        // CRITICAL: Guard against duplicate hydration (fixes rapid-click WASM fetch bug)
        // Check BEFORE the async fetch starts, not after it completes
        if (container.dataset.hydrated === 'true' || container.dataset.hydrating === 'true') {
            console.log('%c[Hydration] Skipping therapy-island[data-component="themetoggle"] - already hydrated/hydrating', 'color: #ffa500');
            return;
        }
        // Mark as hydrating IMMEDIATELY to prevent concurrent calls
        container.dataset.hydrating = 'true';

        console.log('%c[Hydration] Scoped to container: therapy-island[data-component="themetoggle"]', 'color: #748ffc');

        // Load WebAssembly module
        console.log('%c[Hydration] Loading Wasm module from: /WasmTarget.jl/themetoggle.wasm', 'color: #748ffc');
        const response = await fetch('/WasmTarget.jl/themetoggle.wasm');
        if (!response.ok) {
            console.error('[Hydration] Failed to fetch Wasm:', response.status, response.statusText);
            return;
        }
        const bytes = await response.arrayBuffer();
        console.log('%c[Hydration] Module size: ' + bytes.byteLength + ' bytes', 'color: #748ffc');

        // Query helper for scoped DOM access
        const queryEl = (hk) => container.querySelector('[data-hk="' + hk + '"]');

        // DOM imports for Wasm
        // All numeric values are passed as f64 (JavaScript numbers)
        const imports = {
            dom: {
                update_text: (hk, value) => {
                    const el = queryEl(hk);
                    if (el) {
                        let displayValue;
                        const format = el.dataset.format;

                        // Check for special format attributes
                        if (format === 'xo') {
                            // Square format: 0‚Üí"", 1‚Üí"X", 2‚Üí"O"
                            displayValue = value === 0 ? '' : (value === 1 ? 'X' : 'O');
                        } else if (format === 'turn') {
                            // Turn format: 0‚Üí"X", 1‚Üí"O"
                            displayValue = value === 0 ? 'X' : 'O';
                        } else if (format === 'winner') {
                            // Winner format: 0‚Üí"", 1‚Üí"X wins!", 2‚Üí"O wins!"
                            displayValue = value === 0 ? '' : (value === 1 ? 'X wins! üéâ' : 'O wins! üéâ');
                            // Also update parent badge styling
                            const badge = el.parentElement;
                            if (badge && badge.dataset.format === 'winner-badge') {
                                if (value === 0) {
                                    badge.className = 'hidden mb-4 px-6 py-3 rounded-lg text-lg font-bold text-center';
                                } else {
                                    const colors = value === 1
                                        ? 'bg-blue-100 dark:bg-blue-900/50 text-blue-700 dark:text-blue-300'
                                        : 'bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-300';
                                    badge.className = 'mb-4 px-6 py-3 rounded-lg text-lg font-bold text-center animate-bounce ' + colors;
                                }
                                // Also toggle turn display visibility
                                const turnDisplay = container.querySelector('[data-format="turn-display"]');
                                if (turnDisplay) turnDisplay.style.display = value === 0 ? '' : 'none';
                            }
                        } else {
                            // Default: show as integer if whole number
                            displayValue = Number.isInteger(value) ? Math.trunc(value) : value;
                        }

                        el.textContent = displayValue;
                        console.log('%c[Wasm‚ÜíDOM] update_text(hk=' + hk + ', value=' + displayValue + ')', 'color: #51cf66');
                    }
                },
                set_visible: (hk, visible) => {
                    const el = queryEl(hk);
                    if (el) {
                        el.style.display = visible ? '' : 'none';
                        console.log('%c[Wasm‚ÜíDOM] set_visible(hk=' + hk + ', visible=' + !!visible + ')', 'color: #be4bdb');
                    }
                },
                set_dark_mode: (enabled) => {
                    const isDark = !!enabled;
                    document.documentElement.classList.toggle('dark', isDark);
                    try {
                        localStorage.setItem('therapy-theme', isDark ? 'dark' : 'light');
                    } catch (e) {}
                    console.log('%c[Wasm‚ÜíDOM] set_dark_mode(enabled=' + isDark + ')', 'color: #9775fa');
                },
                get_editor_code: (cell_hk) => {
                    // Get code from CodeMirror editor
                    // Returns 0 as placeholder - proper string handling requires externref
                    const cell = queryEl(cell_hk) || document.querySelector('[data-cell-id]');
                    if (cell) {
                        const container = cell.querySelector('[data-codemirror]');
                        if (container && container._cmView) {
                            // Code available via container._cmView.state.doc.toString()
                            // but returning as f64 doesn't work for strings
                            console.log('%c[Wasm‚ÜíDOM] get_editor_code(hk=' + cell_hk + ') - string handling not yet supported', 'color: #ff6b6b');
                        }
                    }
                    return 0;  // Placeholder - needs externref for strings
                }
            },
            channel: {
                send: (channel_id, cell_id) => {
                    // Channel IDs: 0=execute, 1=delete_cell, 2=add_cell
                    // This allows islands to send messages to Therapy.jl channels
                    const channels = ['execute', 'delete_cell', 'add_cell'];
                    const channelName = channels[channel_id] || 'unknown';

                    // Find the cell by hydration key or data-cell-id
                    const cell = queryEl(cell_id) || document.querySelector('[data-cell-id]');
                    const cellIdStr = cell ? cell.dataset.cellId : String(cell_id);
                    const notebookId = window.notebookId || '';

                    if (typeof TherapyWS !== 'undefined' && TherapyWS.isConnected()) {
                        // Build payload based on channel
                        let payload = { notebook_id: notebookId, cell_id: cellIdStr };

                        if (channel_id === 0) {  // execute
                            // Get code from CodeMirror
                            const container = cell ? cell.querySelector('[data-codemirror]') : null;
                            const code = container && container._cmView ?
                                container._cmView.state.doc.toString() : '';
                            payload.code = code;
                        }

                        TherapyWS.sendMessage(channelName, payload);
                        console.log('%c[Wasm‚ÜíChannel] send(' + channelName + ', cell=' + cellIdStr + ')', 'color: #22b8cf');
                    } else {
                        console.warn('%c[Wasm‚ÜíChannel] WebSocket not connected', 'color: #ff6b6b');
                    }
                }
            }
        };

        const { instance } = await WebAssembly.instantiate(bytes, imports);
        const wasm = instance.exports;

        console.log('%c[Hydration] ‚úì Wasm loaded!', 'color: #51cf66; font-weight: bold');
        console.log('%c[Hydration] Exports:', 'color: #ffd43b', Object.keys(wasm));

        // Connect event handlers
            container.querySelector('[data-hk="2"]')?.addEventListener('click', () => {
    console.log('%c[Event] click ‚Üí handler_1()', 'color: #e94560');
    wasm.handler_1();
});

        // Connect input bindings
        

        // Initialize (sync DOM with Wasm state)
        if (wasm.init) {
            wasm.init();
            console.log('%c[Hydration] ‚úì Initialized', 'color: #51cf66');
        }

        // Initialize theme signals from current DOM state
        // MUST run AFTER wasm.init() to override default signal values (0=light)
        // with the actual saved/system preference
        // Sync theme signal with saved preference or current DOM state
// Check localStorage first (where we save it), then fall back to DOM class
const savedTheme = (() => {
    try { return localStorage.getItem('therapy-theme'); } catch (e) { return null; }
})();
const shouldBeDark = savedTheme === 'dark' ||
    (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches);

// Apply theme to DOM first (in case localStorage was set but class not yet applied)
document.documentElement.classList.toggle('dark', shouldBeDark);

// Then sync the Wasm signal (use regular number for Int32)
if (wasm.set_signal_142) {
    wasm.set_signal_142(shouldBeDark ? 1 : 0);
    console.log('%c[Hydration] Theme signal synced: ' + (shouldBeDark ? 'dark' : 'light') + ' mode', 'color: #9775fa');
}

        console.log('%c[Hydration] üöÄ ThemeToggle hydrated!', 'color: #51cf66; font-weight: bold');
        console.log('%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'color: #e94560');

        // Mark the island as hydrated to prevent re-hydration on SPA navigation
        // This is especially important for Layout islands like ThemeToggle
        if (container) {
            container.dataset.hydrated = 'true';
            delete container.dataset.hydrating;  // Clear the in-progress flag
        }

        // Clear the global hydrating flag now that we're done
        delete window._therapyHydrating['themetoggle'];

        // Expose for debugging
        window.TherapyWasm = window.TherapyWasm || {};
        window.TherapyWasm['themetoggle'] = wasm;

        return wasm;
        } catch (error) {
            console.error('[Hydration] Error hydrating ThemeToggle:', error);
            // Clear hydrating flags on error so retry is possible
            if (typeof container !== 'undefined' && container) {
                delete container.dataset.hydrating;
            }
            delete window._therapyHydrating['themetoggle'];
            throw error;
        }
    }

    // Register hydration function globally for re-hydration after navigation
    window.TherapyHydrate['themetoggle'] = hydrate_themetoggle;

    // Auto-hydrate on initial page load (skip if router will handle it)
    // The router sets this flag before executing extracted scripts
    if (!window._therapyRouterHydrating) {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', hydrate_themetoggle);
        } else {
            hydrate_themetoggle();
        }
    }
})();

    </script>
<script>
// Therapy.jl Client-Side Router
(function() {
    'use strict';

    // CRITICAL: Prevent re-execution during SPA navigation.
    // On static sites, loadPage() extracts inline scripts from the fetched full HTML page.
    // This router script contains 'TherapyWS' references, so it matches the extraction filter
    // and gets re-executed on every navigation. Without this guard, each execution adds another
    // click listener, causing exponential request duplication (1‚Üí2‚Üí4‚Üí8 navigations per click).
    if (window.TherapyRouter) {
        return;
    }

    const CONFIG = {
        contentSelector: '#page-content',
        basePath: '/WasmTarget.jl',
        partialHeader: 'X-Therapy-Partial',
        // Debug logging - toggle via TherapyRouter.setDebug(true/false)
        debug: false
    };

    // Track current navigation to cancel on rapid clicks
    let currentNavigation = null;

    function log(...args) {
        if (CONFIG.debug) console.log('%c[Router]', 'color: #748ffc', ...args);
    }

    /**
     * Normalize a path by removing trailing slashes and adding leading slash
     */
    function normalizePath(path) {
        if (!path) return '/';
        path = path.replace(/\/+$/g, '') || '/';
        if (!path.startsWith('/')) path = '/' + path;
        return path;
    }

    /**
     * Check if a URL is internal (same origin, not a hash link, etc.)
     */
    function isInternalLink(href, link) {
        if (!href) return false;

        // Skip hash-only links
        if (href.startsWith('#')) return false;

        // Skip javascript: links
        if (href.startsWith('javascript:')) return false;

        // Skip links with download attribute
        if (link.hasAttribute('download')) return false;

        // Skip links targeting new window
        if (link.target === '_blank') return false;

        // Skip links with data-no-router
        if (link.hasAttribute('data-no-router')) return false;

        // External links (different origin)
        if (href.startsWith('http://') || href.startsWith('https://')) {
            try {
                const url = new URL(href);
                if (url.origin !== window.location.origin) return false;
            } catch (e) {
                return false;
            }
        }

        return true;
    }

    /**
     * Resolve a relative URL to absolute path
     *
     * Path resolution rules:
     * - Absolute paths (/foo) -> returned as-is
     * - Full URLs (http://...) -> extract pathname
     * - ./ paths -> resolve against CONFIG.basePath (app root)
     * - Bare paths (foo/) -> resolve against CONFIG.basePath (app root)
     * - ../ paths -> resolve against current URL (for going up directories)
     */
    function resolveUrl(href) {
        log('resolveUrl input:', href);

        // Absolute paths - return as-is
        if (href.startsWith('/')) {
            log('resolveUrl: absolute path, returning as-is:', href);
            return href;
        }

        // Full URLs - extract pathname
        if (href.startsWith('http://') || href.startsWith('https://')) {
            const pathname = new URL(href).pathname;
            log('resolveUrl: full URL, extracted pathname:', pathname);
            return pathname;
        }

        // Parent-relative paths (../) - resolve against current URL
        // This is intentional for going UP from nested routes
        // Example: on /Therapy.jl/book/reactivity/, "../" -> /Therapy.jl/book/
        if (href.startsWith('../')) {
            const resolved = new URL(href, window.location.href).pathname;
            log('resolveUrl: parent-relative resolved:', href, '->', resolved);
            return resolved;
        }

        // Current-directory relative (./) or bare paths - resolve against BASE PATH
        // This fixes the path stacking bug where ./foo on /Therapy.jl/learn/
        // would incorrectly become /Therapy.jl/learn/foo instead of /Therapy.jl/foo
        const base = CONFIG.basePath || '';
        let path = href;

        // Remove leading ./ if present
        if (path.startsWith('./')) {
            path = path.slice(2);
        }

        // Build the final path: basePath + "/" + path
        // Handle edge cases for trailing/leading slashes
        let result;
        if (!path) {
            // ./ alone means "home" (the base path with trailing slash)
            result = base ? base + '/' : '/';
        } else if (base.endsWith('/')) {
            result = base + path;
        } else {
            result = base + '/' + path;
        }

        log('resolveUrl: base-relative resolved:', href, '->', result);
        return result;
    }

    /**
     * Navigate to a new URL using client-side routing
     */
    async function navigate(href, options = {}) {
        const { replace = false, scroll = true } = options;

        const path = resolveUrl(href);
        log('Navigating to:', path);

        // Update browser history
        if (replace) {
            history.replaceState({ path }, '', path);
        } else {
            history.pushState({ path }, '', path);
        }

        // Load the page content
        await loadPage(path);

        // Scroll to top unless disabled
        if (scroll) {
            window.scrollTo({ top: 0, behavior: 'instant' });
        }

        // Update active link states
        updateActiveLinks();
    }

    /**
     * Fetch page content and swap it into the content container
     */
    async function loadPage(path) {
        const container = document.querySelector(CONFIG.contentSelector);
        if (!container) {
            console.error('[Router] Content container not found:', CONFIG.contentSelector);
            window.location.href = path;
            return;
        }

        // Cancel any in-flight navigation (handles rapid clicking)
        if (currentNavigation) {
            currentNavigation.abort();
            log('Cancelled previous navigation');
        }

        // Create new abort controller for this navigation
        const abortController = new AbortController();
        currentNavigation = abortController;

        // Show loading state (optional)
        container.style.opacity = '0.7';
        container.style.transition = 'opacity 0.1s';

        try {
            const response = await fetch(path, {
                headers: {
                    [CONFIG.partialHeader]: '1',
                    'Accept': 'text/html'
                },
                credentials: 'same-origin',
                signal: abortController.signal
            });

            if (!response.ok) {
                throw new Error('HTTP ' + response.status);
            }

            let html = await response.text();

            // Check if this navigation was cancelled while waiting for response
            if (abortController.signal.aborted) {
                return;
            }

            // Check if we got a full HTML document (static site) or partial content (dev server)
            // Full documents start with <!DOCTYPE or <html
            let scriptsToExecute = [];
            if (html.trim().toLowerCase().startsWith('<!doctype') || html.trim().toLowerCase().startsWith('<html')) {
                log('Got full page, extracting content...');
                // Parse the full document and extract just the content area
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const newContent = doc.querySelector(CONFIG.contentSelector);
                if (newContent) {
                    html = newContent.innerHTML;
                } else {
                    // Fallback: try to get body content
                    log('Content selector not found in response, using body');
                    html = doc.body ? doc.body.innerHTML : html;
                }

                // Extract hydration scripts from the body (they're outside #therapy-content)
                // These contain TherapyHydrate registration functions for islands
                const scripts = doc.querySelectorAll('body script:not([src])');
                log('Found', scripts.length, 'inline scripts in body');
                scripts.forEach((script, idx) => {
                    const content = script.textContent;
                    // Only collect Therapy-related scripts (safety check)
                    if (content && (content.includes('TherapyHydrate') || content.includes('TherapyWS'))) {
                        scriptsToExecute.push(content);
                        log('Script', idx, 'contains Therapy code, length:', content.length);
                    } else {
                        log('Script', idx, 'skipped, length:', content ? content.length : 0);
                    }
                });
                if (scriptsToExecute.length > 0) {
                    log('Collected', scriptsToExecute.length, 'hydration scripts to execute');
                } else {
                    log('WARNING: No hydration scripts found!');
                }
            }

            // Swap content
            container.innerHTML = html;
            container.style.opacity = '1';

            // Clear current navigation tracker
            if (currentNavigation === abortController) {
                currentNavigation = null;
            }

            // Execute any hydration scripts extracted from the full page
            // This registers TherapyHydrate functions before we try to call them
            // Set flag to prevent auto-hydration (router will call hydrateIslands)
            window._therapyRouterHydrating = true;
            for (const scriptContent of scriptsToExecute) {
                try {
                    const script = document.createElement('script');
                    script.textContent = scriptContent;
                    document.head.appendChild(script);
                    document.head.removeChild(script);
                    log('Executed hydration script');
                } catch (e) {
                    console.error('[Router] Failed to execute hydration script:', e);
                }
            }
            window._therapyRouterHydrating = false;

            // Re-hydrate all islands in the new content
            await hydrateIslands();

            // Re-run syntax highlighting for code blocks (Prism.js)
            if (typeof Prism !== 'undefined' && Prism.highlightAll) {
                Prism.highlightAll();
            }

            // Re-discover and subscribe to any new server signals in the content
            if (typeof TherapyWS !== 'undefined' && TherapyWS.discoverAndSubscribe) {
                TherapyWS.discoverAndSubscribe();
            }

            // Show static mode warnings on any new ws-example elements
            if (typeof TherapyWS !== 'undefined' && TherapyWS.showStaticModeWarningOnNewElements) {
                TherapyWS.showStaticModeWarningOnNewElements();
            }

            // Dispatch event for any listeners (e.g., Sessions.jl CodeMirror reinit)
            window.dispatchEvent(new CustomEvent('therapy:router:loaded', {
                detail: { path: path }
            }));

            // Call any registered post-navigation callbacks
            if (Array.isArray(window._therapyRouterCallbacks)) {
                for (const callback of window._therapyRouterCallbacks) {
                    try {
                        callback(path);
                    } catch (e) {
                        console.error('[Router] Post-navigation callback error:', e);
                    }
                }
            }

            log('Page loaded successfully');

        } catch (error) {
            // Ignore abort errors (expected when clicking fast)
            if (error.name === 'AbortError') {
                log('Navigation cancelled');
                return;
            }

            console.error('[Router] Failed to load page:', error);
            container.style.opacity = '1';

            // Clear current navigation tracker
            if (currentNavigation === abortController) {
                currentNavigation = null;
            }

            // Fallback to full page navigation
            window.location.href = path;
        }
    }

    /**
     * Re-hydrate therapy-island components that haven't been hydrated yet.
     * Islands in the Layout (like ThemeToggle) persist across SPA navigation,
     * so we skip them to avoid re-fetching WASM and re-initializing state.
     */
    async function hydrateIslands() {
        // Only hydrate islands that haven't been hydrated yet
        // This prevents duplicate WASM fetches for Layout islands like ThemeToggle
        const islands = document.querySelectorAll('therapy-island:not([data-hydrated])');
        const totalIslands = document.querySelectorAll('therapy-island').length;
        log('Hydrating', islands.length, 'new islands (', totalIslands, 'total on page)');

        for (const island of islands) {
            const componentName = island.dataset.component;
            if (!componentName) {
                console.warn('[Router] Found therapy-island without data-component attribute');
                continue;
            }

            // Registry uses lowercase keys (see Hydration.jl)
            const registryKey = componentName.toLowerCase();
            log('Looking for hydration function:', componentName, '-> registry key:', registryKey);
            log('TherapyHydrate registry:', window.TherapyHydrate ? Object.keys(window.TherapyHydrate) : 'undefined');

            // Look for registered hydration function (using lowercase key)
            if (window.TherapyHydrate && typeof window.TherapyHydrate[registryKey] === 'function') {
                try {
                    log('Calling hydration function for:', registryKey);
                    await window.TherapyHydrate[registryKey]();
                    // Mark as hydrated to prevent re-hydration on future navigation
                    island.dataset.hydrated = 'true';
                    log('Hydrated island:', componentName);
                } catch (error) {
                    console.error('[Router] Failed to hydrate island:', componentName, error);
                }
            } else {
                console.warn('[Router] No hydration function found for:', registryKey);
                console.warn('[Router] Available functions:', window.TherapyHydrate ? Object.keys(window.TherapyHydrate) : 'none');
            }
        }
    }

    /**
     * Update active class on navigation links
     */
    function updateActiveLinks() {
        const currentPath = normalizePath(window.location.pathname);

        document.querySelectorAll('[data-navlink]').forEach(link => {
            const href = link.getAttribute('href');
            if (!href) return;

            const linkPath = normalizePath(resolveUrl(href));
            const activeClassAttr = link.dataset.activeClass || 'active';
            // Split by spaces to handle multiple classes like "text-emerald-700 dark:text-emerald-400"
            const activeClasses = activeClassAttr.split(/\s+/).filter(c => c.length > 0);
            const exact = link.hasAttribute('data-exact');

            let isActive;
            const basePath = normalizePath(CONFIG.basePath || '/');
            if (exact) {
                isActive = linkPath === currentPath;
            } else {
                // Prefix match for nested routes
                // But exclude base path itself (e.g., /Therapy.jl) from prefix matching
                // to avoid Home link being active on all pages
                isActive = currentPath === linkPath ||
                          (linkPath !== '/' && linkPath !== basePath && currentPath.startsWith(linkPath + '/'));
            }

            if (isActive) {
                link.classList.add(...activeClasses);
            } else {
                link.classList.remove(...activeClasses);
            }
        });
    }

    /**
     * Handle click events on links
     */
    function handleLinkClick(event) {
        // Find the closest anchor tag
        const link = event.target.closest('a[href]');
        if (!link) return;

        const href = link.getAttribute('href');
        log('handleLinkClick: intercepted href=', href, 'from element:', link.tagName);

        // Check if we should handle this link
        if (!isInternalLink(href, link)) {
            log('handleLinkClick: not internal, skipping');
            return;
        }

        log('handleLinkClick: internal link, routing via SPA');

        // Prevent default navigation
        event.preventDefault();

        // Navigate using the router
        navigate(href);
    }

    /**
     * Handle browser back/forward buttons
     */
    function handlePopState(event) {
        const path = window.location.pathname;
        log('Popstate:', path);
        loadPage(path);
    }

    /**
     * Initialize the router
     */
    function init() {
        log('Initializing client-side router');

        // Bind link click handler (delegation on document, capture phase)
        document.addEventListener('click', handleLinkClick, true);

        // Bind popstate for back/forward
        window.addEventListener('popstate', handlePopState);

        // Update active links on initial load
        updateActiveLinks();

        log('Router initialized');
    }

    // Expose API for programmatic navigation
    window.TherapyRouter = {
        navigate,
        loadPage,
        hydrateIslands,
        updateActiveLinks,
        setDebug: (enabled) => { CONFIG.debug = enabled; },
        // Register a callback to run after each navigation
        onNavigate: (callback) => {
            if (!Array.isArray(window._therapyRouterCallbacks)) {
                window._therapyRouterCallbacks = [];
            }
            window._therapyRouterCallbacks.push(callback);
        }
    };

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
</script>
<script>
// Therapy.jl WebSocket Client
(function() {
    'use strict';

    // CRITICAL: Prevent re-execution during SPA navigation
    // ClientRouter extracts and re-executes scripts containing 'TherapyWS' after each navigation.
    // Without this guard, each navigation creates a NEW scope with its own `let ws = null`,
    // causing the duplicate connection check (ws.readyState) to fail and create new connections.
    // This single check fixes the WebSocket connection leak issue.
    if (window.TherapyWS) {
        console.log('[WS] Script already executed, skipping re-initialization');
        return;
    }

    const CONFIG = {
        reconnectDelay: 1000,
        maxReconnectDelay: 30000,
        signals: []
    };

    let ws = null;
    let reconnectAttempts = 0;
    let connectionId = null;
    let isStaticMode = false;

    // Dev mode: localhost/127.0.0.1 gets exponential backoff reconnection.
    // Production: non-localhost gets fast static mode detection (1 retry).
    const isDevMode = (window.location.hostname === 'localhost' ||
                       window.location.hostname === '127.0.0.1');

    // Track signal values for patch application
    let signalValues = {};

    /**
     * Get WebSocket URL based on current page protocol
     */
    function getWsUrl() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        return protocol + '//' + window.location.host + '/ws';
    }

    /**
     * Connect to WebSocket server
     */
    function connect() {
        if (isStaticMode) return;

        // Prevent duplicate connections - check if already connected or connecting
        // This fixes connection leaks during SPA navigation
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
            return;
        }

        try {
            ws = new WebSocket(getWsUrl());

            ws.onopen = function() {
                console.log('[WS] Connected to server');
                reconnectAttempts = 0;

                // Subscribe to configured signals
                CONFIG.signals.forEach(function(sig) {
                    subscribe(sig);
                });

                // Auto-discover and subscribe to signals from data-server-signal attributes
                discoverAndSubscribe();

                // Dispatch connected event
                window.dispatchEvent(new CustomEvent('therapy:ws:connected'));
            };

            ws.onmessage = function(e) {
                try {
                    const msg = JSON.parse(e.data);
                    handleMessage(msg);
                } catch (err) {
                    console.warn('[WS] Failed to parse message:', e.data);
                }
            };

            ws.onclose = function(e) {
                connectionId = null;

                // Dispatch disconnected event
                window.dispatchEvent(new CustomEvent('therapy:ws:disconnected'));

                // Attempt reconnect unless it was a clean close
                if (e.code !== 1000) {
                    if (isDevMode) {
                        // Dev server: exponential backoff reconnection
                        // Handles server restarts, code changes, crashes
                        scheduleReconnect();
                    } else if (reconnectAttempts >= 1) {
                        // Production: two failures ‚Üí static hosting, stop trying
                        showStaticModeWarning();
                    } else {
                        // Production: first failure ‚Üí retry once quickly
                        reconnectAttempts++;
                        setTimeout(connect, 500);
                    }
                }
            };

            ws.onerror = function(err) {
                // Dev mode: log connection errors for debugging
                if (isDevMode) {
                    console.warn('[WS] Connection error - server may not be running');
                }
                // Production: suppress verbose logs during static mode detection
            };

        } catch (e) {
            showStaticModeWarning();
        }
    }

    /**
     * Schedule a reconnection attempt with exponential backoff (dev mode only)
     */
    function scheduleReconnect() {
        if (isStaticMode) return;

        const delay = Math.min(
            CONFIG.reconnectDelay * Math.pow(2, reconnectAttempts),
            CONFIG.maxReconnectDelay
        );
        reconnectAttempts++;

        console.log('[WS] Reconnecting in', delay, 'ms (attempt', reconnectAttempts + ')');
        setTimeout(connect, delay);
    }

    /**
     * Handle incoming WebSocket message
     */
    function handleMessage(msg) {
        switch (msg.type) {
            case 'connected':
                connectionId = msg.connection_id;
                console.log('[WS] Connection ID:', connectionId);
                break;

            case 'signal_update':
                handleSignalUpdate(msg.signal, msg.value);
                break;

            case 'signal_patch':
                handleSignalPatch(msg.signal, msg.patch);
                break;

            case 'channel_message':
                handleChannelMessage(msg.channel, msg.data);
                break;

            case 'error':
                console.error('[WS] Server error:', msg.message);
                break;

            case 'pong':
                // Keepalive response, ignore
                break;

            default:
                console.log('[WS] Unknown message type:', msg.type, msg);
        }
    }

    /**
     * Handle a signal update from the server (full value)
     */
    function handleSignalUpdate(signalName, value) {
        console.log('[WS] Signal update:', signalName, '=', value);

        // Store the value for future patch application
        signalValues[signalName] = value;

        // Update via TherapySignals if available (Wasm integration)
        if (window.TherapySignals && window.TherapySignals[signalName]) {
            window.TherapySignals[signalName].set(value);
        }

        // Also update DOM elements with data-server-signal attribute
        updateSignalDOM(signalName, value);

        // Dispatch custom event for custom handlers
        window.dispatchEvent(new CustomEvent('therapy:signal:' + signalName, {
            detail: { value: value }
        }));
    }

    /**
     * Handle a signal patch from the server (RFC 6902 JSON Patch)
     */
    function handleSignalPatch(signalName, patch) {
        console.log('[WS] Signal patch:', signalName, patch);

        // Get current value or initialize
        let value = signalValues[signalName];
        if (value === undefined) {
            value = null;
        }

        // Apply each patch operation
        for (const op of patch) {
            value = applyPatchOp(value, op);
        }

        // Store the new value
        signalValues[signalName] = value;

        // Update via TherapySignals if available (Wasm integration)
        if (window.TherapySignals && window.TherapySignals[signalName]) {
            window.TherapySignals[signalName].set(value);
        }

        // Update DOM elements
        updateSignalDOM(signalName, value);

        // Dispatch custom event
        window.dispatchEvent(new CustomEvent('therapy:signal:' + signalName, {
            detail: { value: value }
        }));
    }

    /**
     * Apply a single JSON patch operation (RFC 6902)
     */
    function applyPatchOp(value, op) {
        const path = op.path;
        const operation = op.op;

        // Root replacement
        if (path === '' || path === '/') {
            if (operation === 'replace' || operation === 'add') {
                return op.value;
            }
            return null;
        }

        // Parse path: "/foo/bar/0" -> ["foo", "bar", "0"]
        const parts = path.split('/').filter(p => p !== '');

        // Handle nested path
        if (operation === 'add' || operation === 'replace') {
            return setAtPath(value, parts, op.value);
        } else if (operation === 'remove') {
            return removeAtPath(value, parts);
        }

        return value;
    }

    /**
     * Set a value at a nested path in an object/array
     */
    function setAtPath(obj, parts, newValue) {
        if (!obj) {
            obj = {};
        }
        if (parts.length === 0) {
            return newValue;
        }

        // Clone to avoid mutation
        obj = JSON.parse(JSON.stringify(obj));

        let current = obj;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (Array.isArray(current)) {
                const idx = parseInt(part, 10);
                if (!current[idx]) {
                    current[idx] = {};
                }
                current = current[idx];
            } else {
                if (!current[part]) {
                    current[part] = {};
                }
                current = current[part];
            }
        }

        const finalPart = parts[parts.length - 1];
        if (Array.isArray(current)) {
            const idx = finalPart === '-' ? current.length : parseInt(finalPart, 10);
            current[idx] = newValue;
        } else {
            current[finalPart] = newValue;
        }

        return obj;
    }

    /**
     * Remove a value at a nested path
     */
    function removeAtPath(obj, parts) {
        if (!obj || parts.length === 0) {
            return obj;
        }

        // Clone to avoid mutation
        obj = JSON.parse(JSON.stringify(obj));

        let current = obj;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (Array.isArray(current)) {
                current = current[parseInt(part, 10)];
            } else {
                current = current[part];
            }
            if (!current) return obj;
        }

        const finalPart = parts[parts.length - 1];
        if (Array.isArray(current)) {
            current.splice(parseInt(finalPart, 10), 1);
        } else {
            delete current[finalPart];
        }

        return obj;
    }

    /**
     * Update DOM elements with data-server-signal or data-bidirectional-signal attribute
     * Leptos-style reactive bindings:
     * - data-server-signal="name" - updates textContent/value
     * - data-signal-html="name" - updates innerHTML (for rich content)
     * - data-signal-class="name:class1,class2" - adds classes when signal is truthy
     * - data-signal-match="name:value:class" - adds class when signal equals value
     */
    function updateSignalDOM(signalName, value) {
        // Update read-only server signal elements (textContent)
        document.querySelectorAll('[data-server-signal="' + signalName + '"]').forEach(function(el) {
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.value = value;
            } else {
                el.textContent = value;
            }
        });

        // Update innerHTML bindings (for rich HTML content like cell output)
        document.querySelectorAll('[data-signal-html="' + signalName + '"]').forEach(function(el) {
            el.innerHTML = value || '';
            // Show/hide based on content
            if (el.hasAttribute('data-signal-hide-empty')) {
                el.classList.toggle('hidden', !value);
            }
        });

        // Update class bindings (add classes when signal is truthy)
        document.querySelectorAll('[data-signal-class^="' + signalName + ':"]').forEach(function(el) {
            const binding = el.getAttribute('data-signal-class');
            const [, classes] = binding.split(':');
            if (classes) {
                const classList = classes.split(',').map(c => c.trim()).filter(c => c);
                if (value) {
                    el.classList.add(...classList);
                } else {
                    el.classList.remove(...classList);
                }
            }
        });

        // Update match bindings (add class when signal equals specific value)
        // Format: data-signal-match="signalName:matchValue:className"
        document.querySelectorAll('[data-signal-match]').forEach(function(el) {
            const bindings = el.getAttribute('data-signal-match').split(';');
            bindings.forEach(function(binding) {
                const parts = binding.trim().split(':');
                if (parts.length >= 3 && parts[0] === signalName) {
                    const matchValue = parts[1];
                    const className = parts[2];
                    if (String(value) === matchValue) {
                        el.classList.add(className);
                    } else {
                        el.classList.remove(className);
                    }
                }
            });
        });

        // Update bidirectional signal elements (only if not focused, to avoid cursor jump)
        document.querySelectorAll('[data-bidirectional-signal="' + signalName + '"]').forEach(function(el) {
            if (document.activeElement === el) {
                // Don't update if user is currently typing in this element
                return;
            }
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.value = value;
            } else {
                el.textContent = value;
            }
        });
    }

    /**
     * Compute a JSON patch between old and new values (client-side)
     * Simplified version - handles basic types
     */
    function computePatch(oldValue, newValue) {
        const patches = [];

        // Handle simple values
        if (typeof oldValue !== 'object' || typeof newValue !== 'object' ||
            oldValue === null || newValue === null ||
            Array.isArray(oldValue) !== Array.isArray(newValue)) {
            if (oldValue !== newValue) {
                patches.push({ op: 'replace', path: '', value: newValue });
            }
            return patches;
        }

        // Handle objects
        if (!Array.isArray(newValue)) {
            // Added or changed keys
            for (const key of Object.keys(newValue)) {
                if (!(key in oldValue)) {
                    patches.push({ op: 'add', path: '/' + key, value: newValue[key] });
                } else if (JSON.stringify(oldValue[key]) !== JSON.stringify(newValue[key])) {
                    patches.push({ op: 'replace', path: '/' + key, value: newValue[key] });
                }
            }
            // Removed keys
            for (const key of Object.keys(oldValue)) {
                if (!(key in newValue)) {
                    patches.push({ op: 'remove', path: '/' + key });
                }
            }
            return patches;
        }

        // For arrays, just replace if different (computing array diff is complex)
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
            patches.push({ op: 'replace', path: '', value: newValue });
        }
        return patches;
    }

    /**
     * Update a bidirectional signal from the client
     * Sends changes to server, which validates and broadcasts to other clients
     */
    function setBidirectional(signalName, newValue) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.warn('[WS] Cannot update signal - not connected');
            return false;
        }

        // Get current value
        const oldValue = signalValues[signalName];

        // Compute patch
        const patch = computePatch(oldValue, newValue);

        if (patch.length === 0) {
            return true; // No change needed
        }

        // Optimistic update - update local state immediately
        signalValues[signalName] = newValue;
        updateSignalDOM(signalName, newValue);

        // Send patch to server
        send({
            type: 'bidirectional_update',
            signal: signalName,
            patch: patch
        });

        console.log('[WS] Bidirectional update:', signalName, patch);
        return true;
    }

    /**
     * Get current value of a signal (for use before setBidirectional)
     */
    function getSignalValue(signalName) {
        return signalValues[signalName];
    }

    /**
     * Handle a channel message from the server
     */
    function handleChannelMessage(channelName, data) {
        console.log('[WS] Channel message:', channelName, data);

        // Dispatch custom event for this channel
        window.dispatchEvent(new CustomEvent('therapy:channel:' + channelName, {
            detail: data
        }));

        // Also dispatch a general channel event
        window.dispatchEvent(new CustomEvent('therapy:channel', {
            detail: { channel: channelName, data: data }
        }));
    }

    /**
     * Send a message on a channel
     */
    function sendMessage(channelName, data) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.warn('[WS] Cannot send message - not connected');
            return false;
        }

        send({
            type: 'channel_message',
            channel: channelName,
            data: data
        });

        console.log('[WS] Sent channel message:', channelName, data);
        return true;
    }

    /**
     * Subscribe to channel messages (convenience for addEventListener)
     */
    function onChannelMessage(channelName, callback) {
        window.addEventListener('therapy:channel:' + channelName, function(e) {
            callback(e.detail);
        });
    }

    /**
     * Add warning banner to a single ws-example element
     */
    function addWarningToElement(el) {
        if (el.querySelector('.ws-warning')) return;

        const warning = document.createElement('div');
        warning.className = 'ws-warning';
        warning.style.cssText = 'background: linear-gradient(135deg, #fef3c7, #fde68a); border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin-bottom: 16px; color: #92400e;';
        warning.innerHTML = '<strong style="display: block; margin-bottom: 4px;">\u26A0\uFE0F Live Demo Unavailable</strong>' +
            '<span style="font-size: 14px;">This example requires a WebSocket server. Run locally with:</span>' +
            '<code style="display: block; margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; font-family: monospace;">julia docs/app.jl dev</code>';
        el.insertBefore(warning, el.firstChild);
    }

    /**
     * Show warning when running in static mode (no WebSocket server)
     */
    function showStaticModeWarning() {
        if (isStaticMode) return;
        isStaticMode = true;

        console.log('[WS] Static mode detected - WebSocket features unavailable');

        // Find all WebSocket example containers and add warning
        document.querySelectorAll('[data-ws-example]').forEach(addWarningToElement);

        // Dispatch static mode event
        window.dispatchEvent(new CustomEvent('therapy:ws:static_mode'));
    }

    /**
     * Add warnings to any new ws-example elements loaded after static mode was detected
     * Called by ClientRouter after SPA navigation
     */
    function showStaticModeWarningOnNewElements() {
        if (!isStaticMode) return;

        // Find any new ws-example elements that don't have warnings yet
        document.querySelectorAll('[data-ws-example]').forEach(addWarningToElement);
    }

    // Track subscribed signals to avoid duplicates
    let subscribedSignals = new Set();

    /**
     * Subscribe to a server signal
     */
    function subscribe(signalName) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            if (!subscribedSignals.has(signalName)) {
                subscribedSignals.add(signalName);
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    signal: signalName
                }));
            }
        }
    }

    /**
     * Discover and subscribe to signals from all reactive data attributes
     * Called on connect and after SPA navigation
     */
    function discoverAndSubscribe() {
        // Subscribe to read-only server signals
        document.querySelectorAll('[data-server-signal]').forEach(function(el) {
            var signalName = el.getAttribute('data-server-signal');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to bidirectional signals (also need to receive updates)
        document.querySelectorAll('[data-bidirectional-signal]').forEach(function(el) {
            var signalName = el.getAttribute('data-bidirectional-signal');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to bidirectional:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to HTML signal bindings (innerHTML updates for rich content)
        document.querySelectorAll('[data-signal-html]').forEach(function(el) {
            var signalName = el.getAttribute('data-signal-html');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to html signal:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to class match bindings (parse signal names from pattern)
        // Format: "signalName:value:class;signalName2:value2:class2"
        document.querySelectorAll('[data-signal-match]').forEach(function(el) {
            var pattern = el.getAttribute('data-signal-match');
            if (pattern) {
                // Extract unique signal names from pattern
                var parts = pattern.split(';');
                parts.forEach(function(part) {
                    var signalName = part.split(':')[0];
                    if (signalName && !subscribedSignals.has(signalName)) {
                        console.log('[WS] Auto-subscribing to match signal:', signalName);
                        subscribe(signalName);
                    }
                });
            }
        });

        // Subscribe to class toggle bindings
        // Format: "signalName:class1,class2"
        document.querySelectorAll('[data-signal-class]').forEach(function(el) {
            var binding = el.getAttribute('data-signal-class');
            if (binding) {
                var signalName = binding.split(':')[0];
                if (signalName && !subscribedSignals.has(signalName)) {
                    console.log('[WS] Auto-subscribing to class signal:', signalName);
                    subscribe(signalName);
                }
            }
        });
    }

    /**
     * Unsubscribe from a server signal
     */
    function unsubscribe(signalName) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'unsubscribe',
                signal: signalName
            }));
        }
    }

    /**
     * Send a custom action to the server
     */
    function sendAction(signalName, action, payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'action',
                signal: signalName,
                action: action,
                payload: payload
            }));
        }
    }

    /**
     * Send raw message to server
     */
    function send(msg) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(msg));
        }
    }

    /**
     * Check if WebSocket is connected
     */
    function isConnected() {
        return ws && ws.readyState === WebSocket.OPEN;
    }

    /**
     * Get current connection ID
     */
    function getConnectionId() {
        return connectionId;
    }

    /**
     * Manually disconnect
     */
    function disconnect() {
        if (ws) {
            ws.close(1000, 'Client disconnect');
            ws = null;
        }
    }

    // Expose API globally
    window.TherapyWS = {
        connect: connect,
        disconnect: disconnect,
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        discoverAndSubscribe: discoverAndSubscribe,
        showStaticModeWarningOnNewElements: showStaticModeWarningOnNewElements,
        sendAction: sendAction,
        send: send,
        isConnected: isConnected,
        getConnectionId: getConnectionId,
        isStaticMode: function() { return isStaticMode; },
        // Bidirectional signals
        setBidirectional: setBidirectional,
        getSignalValue: getSignalValue,
        computePatch: computePatch,
        // Channel messaging
        sendMessage: sendMessage,
        onChannelMessage: onChannelMessage
    };

    /**
     * Handle data-action clicks (Leptos-style server actions)
     * Elements with data-action="channelName" send channel messages on click
     * Additional data-* attributes are included in the message payload
     */
    function setupActionHandlers() {
        document.addEventListener('click', function(e) {
            const el = e.target.closest('[data-action]');
            if (!el) return;

            const action = el.getAttribute('data-action');
            if (!action) return;

            // Collect all data-* attributes as payload
            const payload = {};
            for (const attr of el.attributes) {
                if (attr.name.startsWith('data-') && attr.name !== 'data-action') {
                    // Convert data-cell-id to cell_id
                    const key = attr.name.substring(5).replace(/-/g, '_');
                    payload[key] = attr.value;
                }
            }

            // Check for confirmation
            if (el.hasAttribute('data-confirm')) {
                const msg = el.getAttribute('data-confirm');
                if (!confirm(msg)) return;
            }

            // Send channel message
            sendMessage(action, payload);

            // Prevent default for links/buttons
            e.preventDefault();
        });
    }

    // Auto-connect when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            connect();
            setupActionHandlers();
        });
    } else {
        connect();
        setupActionHandlers();
    }
})();
</script>
</body>
</html>
