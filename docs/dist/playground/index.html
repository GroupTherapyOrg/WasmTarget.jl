<!DOCTYPE html>
<html lang="en" data-base-path="/WasmTarget.jl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground - WasmTarget.jl</title>
    <base href="/WasmTarget.jl/">
    <link rel="stylesheet" href="/WasmTarget.jl/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        html { scroll-behavior: smooth; }
        pre code { font-family: 'JuliaMono', 'Fira Code', 'JetBrains Mono', monospace; }
    </style>
    <script>
        (function() {
            try {
                var bp = document.documentElement.getAttribute('data-base-path') || '';
                var sk = bp ? 'therapy-theme:' + bp : 'therapy-theme';
                var tk = bp ? 'suite-active-theme:' + bp : 'suite-active-theme';
                var s = localStorage.getItem(sk);
                if (s === 'dark' || (!s && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                }
                var t = localStorage.getItem(tk);
                if (t && t !== 'default') {
                    document.documentElement.setAttribute('data-theme', t);
                }
            } catch (e) {}
        })();
    </script>
</head>
<body class="antialiased">
<div id="therapy-content">
<div data-hk="1" class="min-h-screen flex flex-col bg-warm-50 dark:bg-warm-950 transition-colors duration-200"><header data-hk="2" class="bg-warm-100 dark:bg-warm-900 border-b border-warm-200 dark:border-warm-700 transition-colors duration-200"><div data-hk="3" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div data-hk="4" class="flex items-center justify-between h-16"><div data-hk="5" class="flex items-center"><a data-hk="6" class="flex items-center" href="./"><span data-hk="7" class="text-2xl font-bold" style="color: var(--brand-name)">WasmTarget</span><span data-hk="8" class="text-2xl font-light"><span data-hk="9" style="color: var(--jl-dot)">.</span><span data-hk="10" style="color: var(--jl-j)">j</span><span data-hk="11" style="color: var(--jl-l)">l</span></span></a></div><div data-hk="12" class="hidden md:flex md:items-center md:gap-2"><nav data-hk="13" class="flex items-center gap-6"><a data-hk="14" data-active-class="text-accent-700 dark:text-accent-400 font-semibold" class="text-sm font-medium transition-colors text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400" href="./" data-navlink="true" data-exact="true" data-inactive-class="text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400">Home</a><a data-hk="15" data-active-class="text-accent-700 dark:text-accent-400 font-semibold" class="text-sm font-medium transition-colors text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400" href="./playground/" data-navlink="true" data-inactive-class="text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400">Playground</a><a data-hk="16" data-active-class="text-accent-700 dark:text-accent-400 font-semibold" class="text-sm font-medium transition-colors text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400" href="./manual/" data-navlink="true" data-inactive-class="text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400">Manual</a><a data-hk="17" data-active-class="text-accent-700 dark:text-accent-400 font-semibold" class="text-sm font-medium transition-colors text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400" href="./features/" data-navlink="true" data-exact="true" data-inactive-class="text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400">Features</a><a data-hk="18" data-active-class="text-accent-700 dark:text-accent-400 font-semibold" class="text-sm font-medium transition-colors text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400" href="./api/" data-navlink="true" data-exact="true" data-inactive-class="text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400">API</a></nav><div data-hk="19" class="flex items-center gap-2 ml-4"><a data-hk="20" class="text-warm-600 hover:text-warm-800 dark:text-warm-400 dark:hover:text-warm-200 transition-colors" href="https://github.com/GroupTherapyOrg/WasmTarget.jl" target="_blank"><svg data-hk="21" viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor"><path data-hk="22" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a><div data-hk="23" data-suite-theme-switcher="" class="relative"><button data-hk="24" type="button" class="inline-flex items-center justify-center rounded-md p-2 hover:bg-warm-200 dark:hover:bg-warm-800 transition-colors cursor-pointer relative" aria-haspopup="true" title="Switch theme" data-suite-theme-switcher-trigger="" aria-label="Switch theme" aria-expanded="false"><svg data-hk="25" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-warm-600 dark:text-warm-400" fill="none"><path data-hk="26" d="M4.098 19.902a3.75 3.75 0 005.304 0l6.401-6.402M6.75 21A3.75 3.75 0 013 17.25V4.125C3 3.504 3.504 3 4.125 3h5.25c.621 0 1.125.504 1.125 1.125v4.072M6.75 21a3.75 3.75 0 003.75-3.75V8.197M6.75 21h13.125c.621 0 1.125-.504 1.125-1.125v-5.25c0-.621-.504-1.125-1.125-1.125h-4.072M10.5 8.197l2.88-2.88c.438-.439 1.15-.439 1.59 0l3.712 3.713c.44.44.44 1.152 0 1.59l-2.879 2.88M6.75 17.25h.008v.008H6.75v-.008z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><div data-hk="27" class="hidden absolute right-0 top-full mt-2 z-50 w-56 rounded-md border border-warm-200 dark:border-warm-700 bg-warm-50 dark:bg-warm-900 shadow-lg" role="menu" aria-label="Theme options" data-suite-theme-switcher-content=""><div data-hk="28" class="p-1"><button data-hk="29" data-suite-theme-option="default" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="30" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #71717a"></span><span data-hk="31" class="flex flex-col"><span data-hk="32" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Minimal</span><span data-hk="33" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Zinc — sharp and clean</span></span><svg data-hk="34" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="default"><path data-hk="35" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="36" data-suite-theme-option="classic" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="37" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #9558b2"></span><span data-hk="38" class="flex flex-col"><span data-hk="39" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Classic</span><span data-hk="40" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Purple — warm scholarly tones</span></span><svg data-hk="41" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="classic"><path data-hk="42" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="43" data-suite-theme-option="ocean" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="44" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #2563eb"></span><span data-hk="45" class="flex flex-col"><span data-hk="46" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Ocean</span><span data-hk="47" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Blue — professional and confident</span></span><svg data-hk="48" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="ocean"><path data-hk="49" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="50" data-suite-theme-option="nature" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="51" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #059669"></span><span data-hk="52" class="flex flex-col"><span data-hk="53" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Nature</span><span data-hk="54" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Emerald — organic and earthy</span></span><svg data-hk="55" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="nature"><path data-hk="56" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div><button data-hk="57" type="button" class="inline-flex items-center justify-center rounded-md p-2 hover:bg-warm-200 dark:hover:bg-warm-800 transition-colors cursor-pointer" data-suite-theme-toggle="" aria-label="Toggle dark mode" title="Toggle dark mode"><svg data-hk="58" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="hidden dark:block w-5 h-5 text-warm-300" fill="none"><path data-hk="59" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" stroke-linecap="round" stroke-linejoin="round"></path></svg><svg data-hk="60" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="block dark:hidden w-5 h-5 text-warm-600" fill="none"><path data-hk="61" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div><div data-hk="62" class="flex items-center md:hidden"><div data-hk="63" class=""><span data-hk="64" data-suite-sheet-trigger-wrapper="" aria-expanded="false" data-state="closed" data-suite-sheet-trigger="suite-sheet-f74a8f86" class="text-warm-600 dark:text-warm-400 hover:text-warm-800 dark:hover:text-warm-200" aria-label="Open menu" aria-haspopup="dialog" style="display:contents"><svg data-hk="65" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-5 w-5" fill="none"><path data-hk="66" d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round"></path></svg></span><div data-hk="67" data-suite-sheet="suite-sheet-f74a8f86" style="display:none"><div data-hk="68"><div data-hk="69" data-state="closed" class="fixed inset-0 z-50 bg-warm-950/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" data-suite-sheet-overlay="" style="display:none"></div><div data-hk="70" aria-modal="true" data-state="closed" data-suite-sheet-content="" class="glass-panel bg-warm-50 dark:bg-warm-950 text-warm-800 dark:text-warm-300 fixed z-50 gap-4 p-6 shadow-lg outline-none transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out inset-y-0 left-0 h-full w-3/4 border-r border-warm-200 dark:border-warm-700 data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm" role="dialog" tabindex="-1"><div data-hk="71" class="flex flex-col gap-2 text-center sm:text-left"><h2 data-hk="72" class="text-lg leading-none font-semibold text-warm-800 dark:text-warm-300">WasmTarget.jl</h2><p data-hk="73" class="text-warm-600 dark:text-warm-500 text-sm">Navigation</p></div><nav data-hk="74" class="flex flex-col gap-2 mt-4"><a data-hk="75" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./">Home</a><div data-hk="76" class="mt-2"><span data-hk="77" class="text-xs font-semibold text-warm-500 dark:text-warm-500 uppercase tracking-wider">Explore</span></div><a data-hk="78" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./playground/">Playground</a><a data-hk="79" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./features/">Features</a><a data-hk="80" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./api/">API Reference</a><div data-hk="81" class="mt-2"><span data-hk="82" class="text-xs font-semibold text-warm-500 dark:text-warm-500 uppercase tracking-wider">Manual</span></div><a data-hk="83" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/">Overview</a><a data-hk="84" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/variables/">Variables</a><a data-hk="85" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/integers-floats/">Integers &amp; Floats</a><a data-hk="86" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/math-operations/">Math Operations</a><a data-hk="87" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/strings/">Strings</a><a data-hk="88" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/functions/">Functions</a><a data-hk="89" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/control-flow/">Control Flow</a><a data-hk="90" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/types/">Types</a><a data-hk="91" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/methods/">Methods</a><a data-hk="92" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/arrays/">Arrays</a><a data-hk="93" class="text-sm text-warm-700 dark:text-warm-300 hover:text-accent-600 dark:hover:text-accent-400 py-1.5 px-2 rounded-md hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors" href="./manual/tuples/">Tuples</a><div data-hk="94" class="shrink-0 bg-warm-200 dark:bg-warm-700 h-px w-full my-4" role="none"></div><div data-hk="95" class="flex items-center gap-4"><a data-hk="96" class="text-warm-600 hover:text-warm-800 dark:text-warm-400 dark:hover:text-warm-200 transition-colors" href="https://github.com/GroupTherapyOrg/WasmTarget.jl" target="_blank"><svg data-hk="97" viewBox="0 0 24 24" class="h-5 w-5" fill="currentColor"><path data-hk="98" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a><div data-hk="99" data-suite-theme-switcher="" class="relative"><button data-hk="100" type="button" class="inline-flex items-center justify-center rounded-md p-2 hover:bg-warm-200 dark:hover:bg-warm-800 transition-colors cursor-pointer relative" aria-haspopup="true" title="Switch theme" data-suite-theme-switcher-trigger="" aria-label="Switch theme" aria-expanded="false"><svg data-hk="101" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-warm-600 dark:text-warm-400" fill="none"><path data-hk="102" d="M4.098 19.902a3.75 3.75 0 005.304 0l6.401-6.402M6.75 21A3.75 3.75 0 013 17.25V4.125C3 3.504 3.504 3 4.125 3h5.25c.621 0 1.125.504 1.125 1.125v4.072M6.75 21a3.75 3.75 0 003.75-3.75V8.197M6.75 21h13.125c.621 0 1.125-.504 1.125-1.125v-5.25c0-.621-.504-1.125-1.125-1.125h-4.072M10.5 8.197l2.88-2.88c.438-.439 1.15-.439 1.59 0l3.712 3.713c.44.44.44 1.152 0 1.59l-2.879 2.88M6.75 17.25h.008v.008H6.75v-.008z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><div data-hk="103" class="hidden absolute right-0 top-full mt-2 z-50 w-56 rounded-md border border-warm-200 dark:border-warm-700 bg-warm-50 dark:bg-warm-900 shadow-lg" role="menu" aria-label="Theme options" data-suite-theme-switcher-content=""><div data-hk="104" class="p-1"><button data-hk="105" data-suite-theme-option="default" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="106" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #71717a"></span><span data-hk="107" class="flex flex-col"><span data-hk="108" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Minimal</span><span data-hk="109" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Zinc — sharp and clean</span></span><svg data-hk="110" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="default"><path data-hk="111" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="112" data-suite-theme-option="classic" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="113" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #9558b2"></span><span data-hk="114" class="flex flex-col"><span data-hk="115" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Classic</span><span data-hk="116" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Purple — warm scholarly tones</span></span><svg data-hk="117" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="classic"><path data-hk="118" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="119" data-suite-theme-option="ocean" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="120" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #2563eb"></span><span data-hk="121" class="flex flex-col"><span data-hk="122" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Ocean</span><span data-hk="123" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Blue — professional and confident</span></span><svg data-hk="124" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="ocean"><path data-hk="125" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><button data-hk="126" data-suite-theme-option="nature" type="button" class="flex items-center gap-3 w-full rounded-sm px-2 py-2 text-sm cursor-pointer hover:bg-warm-100 dark:hover:bg-warm-800 transition-colors text-left" role="menuitem"><span data-hk="127" class="w-4 h-4 rounded-full shrink-0 border border-warm-200 dark:border-warm-700" style="background-color: #059669"></span><span data-hk="128" class="flex flex-col"><span data-hk="129" class="font-medium text-warm-800 dark:text-warm-300 text-sm leading-none">Nature</span><span data-hk="130" class="text-warm-500 dark:text-warm-500 text-xs mt-0.5">Emerald — organic and earthy</span></span><svg data-hk="131" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 ml-auto text-accent-600 dark:text-accent-400 hidden" fill="none" data-suite-theme-check="nature"><path data-hk="132" d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div><button data-hk="133" type="button" class="inline-flex items-center justify-center rounded-md p-2 hover:bg-warm-200 dark:hover:bg-warm-800 transition-colors cursor-pointer" data-suite-theme-toggle="" aria-label="Toggle dark mode" title="Toggle dark mode"><svg data-hk="134" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="hidden dark:block w-5 h-5 text-warm-300" fill="none"><path data-hk="135" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" stroke-linecap="round" stroke-linejoin="round"></path></svg><svg data-hk="136" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="block dark:hidden w-5 h-5 text-warm-600" fill="none"><path data-hk="137" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></nav><button data-hk="138" data-suite-sheet-close="" type="button" class="absolute right-4 top-4 rounded-sm opacity-70 cursor-pointer ring-offset-warm-50 dark:ring-offset-warm-950 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-accent-600 focus:ring-offset-2 disabled:pointer-events-none" aria-label="Close"><svg data-hk="139" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-4 w-4" fill="none"><path data-hk="140" d="M18 6L6 18M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div></div></div></div></div></header><main data-hk="141" id="page-content" class="flex-1 w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div data-hk="1" class="w-full max-w-4xl mx-auto py-8"><div data-hk="2" class="text-center mb-8"><h1 data-hk="3" class="text-3xl font-serif font-semibold text-warm-800 dark:text-warm-100">Julia Playground</h1><p data-hk="4" class="text-warm-500 dark:text-warm-400 mt-2 max-w-2xl mx-auto">Write Julia expressions and run them as WebAssembly — directly in your browser.</p><div data-hk="5" class="mt-3 flex justify-center gap-2"><span data-hk="6" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 bg-accent-600 text-white hover:bg-accent-700">WebAssembly</span><span data-hk="7" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 bg-warm-100 dark:bg-warm-900 text-warm-800 dark:text-warm-300 hover:bg-warm-200 dark:hover:bg-warm-800">Client-Side</span></div></div><div data-hk="8" class="glass-panel rounded-xl border border-warm-200 dark:border-warm-700 bg-warm-100 dark:bg-warm-900 text-warm-800 dark:text-warm-300 shadow-sm flex flex-col gap-6 py-6 text-sm overflow-hidden mb-8"><div data-hk="9" class="flex flex-col gap-1.5 px-6"><div data-hk="10" class="flex items-center justify-between"><div data-hk="11"><div data-hk="12" class="text-lg font-semibold leading-none tracking-tight">Editor</div><div data-hk="13" class="text-sm text-warm-600 dark:text-warm-500">Type a Julia expression and click Run (or Ctrl+Enter)</div></div><span data-hk="14" id="pg-status" class="text-xs text-warm-400 dark:text-warm-500">Loading WASM...</span></div></div><div data-hk="15" class="px-6"><div data-hk="16" class="mb-4 group relative overflow-hidden rounded-lg border border-warm-200 dark:border-warm-700 bg-warm-950 focus-within:ring-2 focus-within:ring-accent-600/50 focus-within:border-accent-600 transition-colors"><div data-hk="17" class="flex items-center gap-2 border-b border-warm-800 px-4 py-2"><span data-hk="18" class="text-[11px] font-mono uppercase tracking-wider text-warm-400 dark:text-warm-500 select-none">julia</span></div><textarea data-hk="19" rows="5" autocapitalize="off" autocomplete="off" id="pg-editor" spellcheck="false" autocorrect="off" class="w-full bg-transparent border-none outline-none resize-y p-4 font-mono text-sm leading-6 text-warm-200 placeholder:text-warm-600" placeholder="Type Julia code here...">1 + 1</textarea></div><div data-hk="20" class="mb-4 flex items-center gap-3"><button data-hk="21" id="pg-run" class="inline-flex items-center justify-center gap-2 whitespace-nowrap cursor-pointer rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-accent-600 text-white hover:bg-accent-700 h-10 px-4 py-2"><svg data-hk="22" viewBox="0 0 24 24" class="w-4 h-4" fill="currentColor"><polygon data-hk="23" points="5,3 19,12 5,21"></polygon></svg>Run</button><span data-hk="24" class="text-xs text-warm-400 dark:text-warm-500">Ctrl+Enter</span></div><div data-hk="25"><p data-hk="26" class="text-xs font-medium text-warm-500 dark:text-warm-400 mb-2 uppercase tracking-wider">Output</p><div data-hk="27" id="pg-output" class="overflow-hidden rounded-lg border border-warm-200 dark:border-warm-700 bg-warm-950 p-4 font-mono text-sm leading-6 text-warm-200 min-h-[60px] whitespace-pre-wrap"><span data-hk="28" class="text-warm-500 italic">Click Run to evaluate.</span></div></div></div></div><div data-hk="29" class="glass-panel rounded-xl border border-warm-200 dark:border-warm-700 bg-warm-100 dark:bg-warm-900 text-warm-800 dark:text-warm-300 shadow-sm flex flex-col gap-6 py-6 text-sm overflow-hidden mb-8"><div data-hk="30" class="flex flex-col gap-1.5 px-6"><div data-hk="31" class="text-lg font-semibold leading-none tracking-tight">Try These Examples</div><div data-hk="32" class="text-sm text-warm-600 dark:text-warm-500">Click any expression to load it into the editor</div></div><div data-hk="33" class="px-6"><div data-hk="34" class="flex flex-wrap gap-2"><span data-hk="35" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="1 + 1">1 + 1</span><span data-hk="36" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="10 - 3">10 - 3</span><span data-hk="37" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="2 * 3">2 * 3</span><span data-hk="38" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="10 % 3">10 % 3</span><span data-hk="39" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="2.5 + 3.5">2.5 + 3.5</span><span data-hk="40" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="sin(1.0)">sin(1.0)</span><span data-hk="41" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="sqrt(4.0)">sqrt(4.0)</span><span data-hk="42" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="abs(-7)">abs(-7)</span><span data-hk="43" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="max(3, 7)">max(3, 7)</span><span data-hk="44" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="factorial(10)">factorial(10)</span><span data-hk="45" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="fib(20)">fib(20)</span><span data-hk="46" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="gcd(100, 75)">gcd(100, 75)</span><span data-hk="47" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="isprime(97)">isprime(97)</span><span data-hk="48" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="pow(2, 10)">pow(2, 10)</span><span data-hk="49" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="sum_to(100)">sum_to(100)</span><span data-hk="50" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="sign(-5)">sign(-5)</span><span data-hk="51" class="inline-flex items-center justify-center w-fit whitespace-nowrap shrink-0 rounded-xl border border-transparent px-2 py-0.5 text-xs font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 border-warm-200 dark:border-warm-700 text-warm-800 dark:text-warm-300 hover:bg-warm-100 dark:hover:bg-warm-900 pg-example cursor-pointer font-mono hover:border-accent-500 dark:hover:border-accent-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" data-expr="clamp(15, 1, 10)">clamp(15, 1, 10)</span></div></div></div><div data-hk="52" class="relative w-full rounded-lg border px-4 py-3 text-sm grid gap-1 bg-warm-100 dark:bg-warm-900 text-warm-800 dark:text-warm-300 border-warm-200 dark:border-warm-700 mb-8" role="alert"><div data-hk="53" class="font-medium leading-none tracking-tight">How It Works</div><div data-hk="54" class="text-sm text-warm-600 dark:text-warm-500">For simple arithmetic like &#39;1 + 1&#39;, this playground runs the real Julia compiler pipeline entirely in your browser: it parses Julia source code, performs type inference, and generates a fresh WebAssembly module on the fly — no server required. Other expressions use pre-compiled WASM functions as a fallback. More expression types will be compiled live as the compiler expands.</div></div><script>(function() {
  // TherapyHydrate — marker so the SPA router re-executes this script on navigation
  // --- Global WASM cache (persists across SPA navigations) ---
  var pipelinePaths = [
    window.location.pathname.replace(/\/playground\/.*/, '/playground/pipeline-optimized.wasm'),
    './pipeline-optimized.wasm',
    '/WasmTarget.jl/playground/pipeline-optimized.wasm'
  ];
  var evalPaths = [
    window.location.pathname.replace(/\/playground\/.*/, '/playground/eval_julia.wasm'),
    './eval_julia.wasm',
    '/WasmTarget.jl/playground/eval_julia.wasm'
  ];

  // Load pipeline-optimized.wasm (regex fallback)
  async function ensurePipelineWasm() {
    if (window._pgWasm) return window._pgWasm;
    for (var i = 0; i < pipelinePaths.length; i++) {
      try {
        var resp = await fetch(pipelinePaths[i]);
        if (!resp.ok) continue;
        var bytes = await resp.arrayBuffer();
        var result = await WebAssembly.instantiate(bytes, { Math: { pow: Math.pow } });
        window._pgWasm = result.instance;
        window._pgWasmSize = (bytes.byteLength / 1024).toFixed(0);
        return window._pgWasm;
      } catch(e) { /* try next */ }
    }
    return null;
  }

  // Load eval_julia.wasm (real compiler pipeline)
  async function ensureEvalWasm() {
    if (window._pgEvalWasm) return window._pgEvalWasm;
    for (var i = 0; i < evalPaths.length; i++) {
      try {
        var resp = await fetch(evalPaths[i]);
        if (!resp.ok) continue;
        var bytes = await resp.arrayBuffer();
        var result = await WebAssembly.instantiate(bytes, { Math: { pow: Math.pow } });
        window._pgEvalWasm = result.instance;
        window._pgEvalSize = (bytes.byteLength / 1024).toFixed(0);
        return window._pgEvalWasm;
      } catch(e) { /* try next */ }
    }
    return null;
  }

  // --- Bridge helpers (from PURE-7008, browser-compatible) ---

  // Encode JS string → WasmGC byte vector
  function jsToWasmBytes(exports, str) {
    var vec = exports['make_byte_vec'](str.length);
    for (var i = 0; i < str.length; i++) {
      exports['set_byte_vec!'](vec, i + 1, str.charCodeAt(i));
    }
    return vec;
  }

  // Extract WasmGC byte vector → JS Uint8Array
  function extractWasmBytes(exports, wasmVec) {
    var len = exports['eval_julia_result_length'](wasmVec);
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      bytes[i] = exports['eval_julia_result_byte'](wasmVec, i + 1);
    }
    return bytes;
  }

  // Full eval_julia pipeline: string → compile → extract → instantiate → execute
  async function evalJulia(expr) {
    var e = window._pgEvalWasm.exports;
    var t0 = performance.now();

    // Strip whitespace — WASM parser handles "1+1" but not "1 + 1" yet
    var exprClean = expr.replace(/\s+/g, '');

    // Step 1: Encode expression → WasmGC byte vector
    var inputVec = jsToWasmBytes(e, exprClean);

    // Step 2: Compile — eval_julia_to_bytes_vec → inner WASM bytes
    var resultVec = e['eval_julia_to_bytes_vec'](inputVec);
    var innerBytes = extractWasmBytes(e, resultVec);

    // Validate WASM magic
    if (innerBytes.length < 8 || innerBytes[0] !== 0x00 || innerBytes[1] !== 0x61 ||
        innerBytes[2] !== 0x73 || innerBytes[3] !== 0x6d) {
      throw new Error('Compiler produced invalid WASM bytes (' + innerBytes.length + ' bytes)');
    }

    // Step 3: Instantiate inner module
    var inner = await WebAssembly.instantiate(innerBytes, { Math: { pow: Math.pow } });
    var compileMs = (performance.now() - t0).toFixed(1);

    // Step 4: Find and call the operator export
    var opMatch = expr.match(/([+\-*/])/);
    if (!opMatch) throw new Error('No operator found in "' + expr + '"');
    var fn = inner.instance.exports[opMatch[1]];
    if (!fn) throw new Error('No export "' + opMatch[1] + '" in inner module');

    // Parse operands and call
    var parts = expr.split(opMatch[0]);
    var left = BigInt(parseInt(parts[0].trim(), 10));
    var right = BigInt(parseInt(parts[1].trim(), 10));
    var result = fn(left, right);

    return { value: Number(result), innerSize: innerBytes.length, compileMs: compileMs };
  }

  function escapeHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Regex-based evaluate (fallback for pre-compiled pipeline-optimized.wasm)
  function evaluateFallback(code) {
    var e = window._pgWasm.exports;
    var trimmed = code.trim();

    var um = trimmed.match(/^(sin|cos|sqrt|abs|sign|sum_to|factorial|fib|isprime)\((-?\d+(?:\.\d+)?)\)$/);
    if (um) {
      var fn = um[1], x = Number(um[2]), isF = um[2].includes('.');
      if (fn==='sin') return String(e.pipeline_sin(x));
      if (fn==='cos') return String(e.pipeline_cos(x));
      if (fn==='sqrt') return String(e.pipeline_sqrt(x));
      if (fn==='abs' && isF) return String(e.pipeline_abs_f(x));
      if (fn==='abs') return String(e.pipeline_abs_i(BigInt(Math.trunc(x))));
      if (fn==='sign') return String(e.pipeline_sign(BigInt(Math.trunc(x))));
      if (fn==='sum_to') return String(e.pipeline_sum_to(BigInt(Math.trunc(x))));
      if (fn==='factorial') return String(e.pipeline_factorial(BigInt(Math.trunc(x))));
      if (fn==='fib') return String(e.pipeline_fib(BigInt(Math.trunc(x))));
      if (fn==='isprime') return String(e.pipeline_isprime(BigInt(Math.trunc(x))));
    }

    var neg = trimmed.match(/^-(\d+)$/);
    if (neg) return String(e.pipeline_neg(BigInt(neg[1])));

    var bin = trimmed.match(/^(-?\d+(?:\.\d+)?)\s*([+\-*\/%])\s*(-?\d+(?:\.\d+)?)$/);
    if (bin) {
      var a = Number(bin[1]), b = Number(bin[3]), op = bin[2];
      var isFloat = bin[1].includes('.') || bin[3].includes('.');
      if (isFloat) {
        if (op==='+') return String(e.pipeline_fadd(a,b));
        if (op==='-') return String(e.pipeline_fsub(a,b));
        if (op==='*') return String(e.pipeline_fmul(a,b));
        if (op==='/') return String(e.pipeline_fdiv(a,b));
      } else {
        var ai = BigInt(Math.trunc(a)), bi = BigInt(Math.trunc(b));
        if (op==='+') return String(e.pipeline_add(ai,bi));
        if (op==='-') return String(e.pipeline_sub(ai,bi));
        if (op==='*') return String(e.pipeline_mul(ai,bi));
        if (op==='/') return String(e.pipeline_div(ai,bi));
        if (op==='%') return String(e.pipeline_mod(ai,bi));
      }
    }

    var eq = trimmed.match(/^(-?\d+)\s*==\s*(-?\d+)$/);
    if (eq) {
      return String(e.pipeline_eq(BigInt(eq[1]), BigInt(eq[2]))) === '1' ? 'true' : 'false';
    }

    var ta = trimmed.match(/^(max|min|div|mod|gcd|pow)\((-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\)$/);
    if (ta) {
      var fn2 = ta[1], isF2 = ta[2].includes('.') || ta[3].includes('.');
      if (isF2) {
        var fa = Number(ta[2]), fb = Number(ta[3]);
        if (fn2==='max') return String(e.pipeline_fmax(fa,fb));
        if (fn2==='min') return String(e.pipeline_fmin(fa,fb));
      }
      var ai2 = BigInt(ta[2]), bi2 = BigInt(ta[3]);
      if (fn2==='max') return String(e.pipeline_max(ai2,bi2));
      if (fn2==='min') return String(e.pipeline_min(ai2,bi2));
      if (fn2==='div') return String(e.pipeline_div(ai2,bi2));
      if (fn2==='mod') return String(e.pipeline_mod(ai2,bi2));
      if (fn2==='gcd') return String(e.pipeline_gcd(ai2,bi2));
      if (fn2==='pow') return String(e.pipeline_pow(ai2,bi2));
    }

    var cl = trimmed.match(/^clamp\((-?\d+),\s*(-?\d+),\s*(-?\d+)\)$/);
    if (cl) {
      return String(e.pipeline_clamp(BigInt(cl[1]), BigInt(cl[2]), BigInt(cl[3])));
    }

    throw new Error(
      'Expression not yet supported.\n\n' +
      'Supported: arithmetic (1 + 1), math (sin, sqrt, abs), ' +
      'control flow (sign, clamp), loops (factorial, fib, sum_to), ' +
      'algorithms (gcd, isprime, pow).\n\n' +
      'Full Julia compilation coming soon.'
    );
  }

  // Check if expression is simple integer arithmetic that eval_julia supports
  function isEvalJuliaSupported(code) {
    return /^\s*-?\d+\s*[+\-]\s*-?\d+\s*$/.test(code);
  }

  // --- Init: wire up DOM elements and load WASM ---
  async function initPlayground() {
    var editor = document.getElementById('pg-editor');
    var runBtn = document.getElementById('pg-run');
    var output = document.getElementById('pg-output');
    var status = document.getElementById('pg-status');

    if (!editor || !runBtn || !output || !status) return;

    // Load both WASM modules in parallel
    status.textContent = 'Loading WASM modules...';
    var results = await Promise.allSettled([ensurePipelineWasm(), ensureEvalWasm()]);
    var hasPipeline = !!window._pgWasm;
    var hasEval = !!window._pgEvalWasm;

    if (hasEval || hasPipeline) {
      var parts = [];
      if (hasEval) parts.push('compiler ' + (window._pgEvalSize || '?') + ' KB');
      if (hasPipeline) parts.push('pre-compiled ' + (window._pgWasmSize || '?') + ' KB');
      status.textContent = 'Ready (' + parts.join(' + ') + ')';
      status.className = 'text-xs text-accent-600 dark:text-accent-400 font-medium';
      runBtn.disabled = false;
    } else {
      status.textContent = 'Failed to load WASM';
      status.className = 'text-xs text-red-500';
      return;
    }

    async function run() {
      var code = editor.value;
      var trimmed = code.trim();

      // Try real eval_julia pipeline for supported expressions
      if (hasEval && isEvalJuliaSupported(trimmed)) {
        try {
          var r = await evalJulia(trimmed);
          output.innerHTML =
            '<span class="text-green-400">' + escapeHtml(String(r.value)) + '</span>' +
            '<span class="text-warm-500 text-xs ml-3">' +
            'Compiled live via eval_julia (' + r.innerSize + ' byte inner module, ' + r.compileMs + ' ms)' +
            '</span>';
          return;
        } catch(e) {
          // Fall through to regex fallback
          console.warn('eval_julia failed, falling back:', e.message);
        }
      }

      // Fallback to pre-compiled pipeline-optimized.wasm
      if (hasPipeline) {
        try {
          var result = evaluateFallback(code);
          output.innerHTML =
            '<span class="text-green-400">' + escapeHtml(result) + '</span>' +
            '<span class="text-warm-500 text-xs ml-3">Pre-compiled</span>';
        } catch(err) {
          output.innerHTML = '<span class="text-red-400">' + escapeHtml(err.message) + '</span>';
        }
      } else {
        output.innerHTML = '<span class="text-red-400">No WASM module available for this expression.</span>';
      }
    }

    // Wire up Run button (clone+replace to remove old listeners from previous SPA nav)
    var fresh = runBtn.cloneNode(true);
    fresh.disabled = false;
    runBtn.parentNode.replaceChild(fresh, runBtn);
    fresh.addEventListener('click', function() { run(); });

    // Ctrl/Cmd+Enter
    if (window._pgKeyHandler) document.removeEventListener('keydown', window._pgKeyHandler);
    window._pgKeyHandler = function(ev) {
      if ((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter' && document.getElementById('pg-editor')) {
        ev.preventDefault();
        run();
      }
    };
    document.addEventListener('keydown', window._pgKeyHandler);

    // Example chips
    document.querySelectorAll('.pg-example').forEach(function(el) {
      el.addEventListener('click', function() {
        document.getElementById('pg-editor').value = el.textContent.trim();
      });
    });
  }

  // Run now — works on both hard refresh AND SPA navigation because
  // the router re-executes scripts containing 'TherapyHydrate'
  initPlayground();
})();
</script></div></main><div data-hk="142" class="shrink-0 bg-warm-200 dark:bg-warm-700 h-px w-full" role="none"></div><footer data-hk="143" class="bg-warm-100 dark:bg-warm-900 mt-auto transition-colors duration-200"><div data-hk="144" class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8"><div data-hk="145" class="flex flex-col sm:flex-row items-center justify-between gap-4"><div data-hk="146" class="flex items-center gap-4"><span data-hk="147" class="text-sm font-medium text-warm-800 dark:text-warm-300">GroupTherapyOrg</span></div><div data-hk="148" class="flex items-center gap-4"><a data-hk="149" class="text-sm text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" href="https://github.com/GroupTherapyOrg/WasmTarget.jl" target="_blank">WasmTarget.jl</a><span data-hk="150" class="text-warm-300 dark:text-warm-600">/</span><a data-hk="151" class="text-sm text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" href="https://github.com/GroupTherapyOrg/Therapy.jl" target="_blank">Therapy.jl</a><span data-hk="152" class="text-warm-300 dark:text-warm-600">/</span><a data-hk="153" class="text-sm text-warm-600 dark:text-warm-400 hover:text-accent-600 dark:hover:text-accent-400 transition-colors" href="https://github.com/GroupTherapyOrg/Suite.jl" target="_blank">Suite.jl</a></div><p data-hk="154" class="text-warm-500 dark:text-warm-500 text-xs">Built with Therapy.jl — Julia to WebAssembly compiler</p></div></div></footer><section data-hk="155" data-position="bottom-right" data-duration="4000" data-visible-toasts="3" class="" data-suite-toaster="" aria-label="Notifications" tabindex="-1"></section><script>/**
 * Suite.jl Runtime — Behavioral JS for complex UI components
 *
 * This module handles DOM behaviors that cannot be expressed in pure Wasm:
 * - Focus trapping (Dialog, AlertDialog, Sheet)
 * - Dismiss layers (click-outside, Escape key)
 * - Floating positioning (Popover, Tooltip, DropdownMenu, Select)
 * - Roving focus (Menubar, NavigationMenu, RadioGroup)
 * - Presence animations (mount/unmount transitions)
 * - Collection management (ordered item lists)
 *
 * Architecture:
 *   - Auto-discovers components via data-suite-* attributes
 *   - Each behavior is a standalone module (no cross-dependencies)
 *   - Re-scans on SPA navigation (listens for therapy:router:loaded)
 *   - Zero external dependencies (no Floating UI, no Radix)
 *
 * Verified against:
 *   - Radix UI primitives (behavioral parity)
 *   - WAI-ARIA patterns (accessibility compliance)
 *   - Zag.js state machines (logic reference)
 */
;(function() {
    'use strict';

    // Singleton guard — prevent re-execution during SPA navigation
    if (window.Suite) return;

    const Suite = {
        version: '0.1.0',

        // Helper: get namespaced localStorage key based on data-base-path
        _themeKey(name) {
            const bp = document.documentElement.getAttribute('data-base-path') || '';
            return bp ? name + ':' + bp : name;
        },

        // --- Focus Guards ---------------------------------------------------------
        FocusGuards: {
            _count: 0,
            install() {
                if (this._count === 0) {
                    const create = () => {
                        const s = document.createElement('span');
                        s.setAttribute('data-suite-focus-guard', '');
                        s.tabIndex = 0;
                        Object.assign(s.style, { outline: 'none', opacity: '0', position: 'fixed', pointerEvents: 'none' });
                        return s;
                    };
                    document.body.insertAdjacentElement('afterbegin', create());
                    document.body.insertAdjacentElement('beforeend', create());
                }
                this._count++;
            },
            uninstall() {
                this._count--;
                if (this._count === 0) {
                    document.querySelectorAll('[data-suite-focus-guard]').forEach(n => n.remove());
                }
            }
        },

        // --- Scroll Lock ----------------------------------------------------------
        ScrollLock: {
            _saved: null,
            _count: 0,
            lock() {
                if (this._count === 0) {
                    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
                    this._saved = {
                        overflow: document.body.style.overflow,
                        paddingRight: document.body.style.paddingRight,
                    };
                    document.body.style.overflow = 'hidden';
                    if (scrollbarWidth > 0) {
                        document.body.style.paddingRight = scrollbarWidth + 'px';
                    }
                }
                this._count++;
            },
            unlock() {
                this._count--;
                if (this._count === 0 && this._saved) {
                    document.body.style.overflow = this._saved.overflow;
                    document.body.style.paddingRight = this._saved.paddingRight;
                    this._saved = null;
                }
            }
        },

        // --- Focus Trap -----------------------------------------------------------
        FocusTrap: {
            _scopes: [],
            _getTabbable(container) {
                const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
                    acceptNode(node) {
                        if (node.tagName === 'INPUT' && node.type === 'hidden') return NodeFilter.FILTER_SKIP;
                        if (node.disabled || node.hidden) return NodeFilter.FILTER_SKIP;
                        if (node.tabIndex >= 0) return NodeFilter.FILTER_ACCEPT;
                        return NodeFilter.FILTER_SKIP;
                    }
                });
                const result = [];
                while (walker.nextNode()) result.push(walker.currentNode);
                return result;
            },
            _isVisible(el, upTo) {
                if (getComputedStyle(el).visibility === 'hidden') return false;
                let node = el;
                while (node && node !== upTo) {
                    if (getComputedStyle(node).display === 'none') return false;
                    node = node.parentElement;
                }
                return true;
            },
            activate(container, options) {
                options = options || {};
                const previouslyFocused = document.activeElement;
                const scope = { container, paused: false };

                // Pause previous scope
                if (this._scopes.length > 0) this._scopes[this._scopes.length - 1].paused = true;
                this._scopes.push(scope);

                // Auto-focus: first tabbable non-link element, or container
                if (!options.skipAutoFocus) {
                    const tabbable = this._getTabbable(container);
                    const nonLinks = tabbable.filter(el => el.tagName !== 'A' && this._isVisible(el, container));
                    const target = options.initialFocus
                        ? (typeof options.initialFocus === 'function' ? options.initialFocus() : options.initialFocus)
                        : (nonLinks[0] || tabbable[0]);
                    if (target) target.focus({ preventScroll: true });
                    else container.focus({ preventScroll: true });
                }

                // Focusin handler — yank focus back if it escapes
                const onFocusIn = (e) => {
                    if (scope.paused) return;
                    if (container.contains(e.target)) {
                        scope._lastFocused = e.target;
                    } else if (scope._lastFocused) {
                        scope._lastFocused.focus({ preventScroll: true });
                    }
                };

                // Tab key handler — loop focus
                const onKeyDown = (e) => {
                    if (scope.paused) return;
                    if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;
                    const tabbable = this._getTabbable(container).filter(el => this._isVisible(el, container));
                    if (tabbable.length === 0) { e.preventDefault(); return; }
                    const first = tabbable[0];
                    const last = tabbable[tabbable.length - 1];
                    if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus({ preventScroll: true });
                    } else if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus({ preventScroll: true });
                    }
                };

                document.addEventListener('focusin', onFocusIn);
                container.addEventListener('keydown', onKeyDown);

                return () => {
                    document.removeEventListener('focusin', onFocusIn);
                    container.removeEventListener('keydown', onKeyDown);
                    // Remove scope and resume previous
                    this._scopes = this._scopes.filter(s => s !== scope);
                    if (this._scopes.length > 0) this._scopes[this._scopes.length - 1].paused = false;
                    // Return focus
                    setTimeout(() => {
                        if (previouslyFocused && previouslyFocused.focus) {
                            previouslyFocused.focus({ preventScroll: true });
                        }
                    }, 0);
                };
            }
        },

        // --- Dismiss Layer --------------------------------------------------------
        DismissLayer: {
            _layers: [],
            activate(container, options) {
                options = options || {};
                const onDismiss = options.onDismiss || options;
                const isFunc = typeof onDismiss === 'function';

                this._layers.push(container);

                // Body pointer-events management for modal overlays
                let savedPointerEvents;
                if (options.disableOutsidePointerEvents) {
                    savedPointerEvents = document.body.style.pointerEvents;
                    document.body.style.pointerEvents = 'none';
                    container.style.pointerEvents = 'auto';
                }

                // Escape handler — only top layer responds
                const onKeyDown = (e) => {
                    if (e.key !== 'Escape') return;
                    if (this._layers[this._layers.length - 1] !== container) return;
                    if (options.onEscapeKeyDown) {
                        options.onEscapeKeyDown(e);
                        if (e.defaultPrevented) return;
                    }
                    if (isFunc) onDismiss();
                    else if (options.onDismiss) options.onDismiss();
                };

                // Pointer down outside handler
                let isPointerInside = false;
                const onPointerDownCapture = () => { isPointerInside = true; };
                container.addEventListener('pointerdown', onPointerDownCapture, true);

                const onPointerDown = (e) => {
                    if (isPointerInside) { isPointerInside = false; return; }
                    if (container.contains(e.target)) return;
                    // Check excludeElements — e.g., menubar triggers shouldn't dismiss
                    if (options.excludeElements) {
                        const excluded = typeof options.excludeElements === 'function'
                            ? options.excludeElements() : options.excludeElements;
                        if (excluded && excluded.some(el => el && el.contains(e.target))) return;
                    }
                    if (options.onPointerDownOutside) {
                        options.onPointerDownOutside(e);
                        if (e.defaultPrevented) return;
                    }
                    if (isFunc) onDismiss();
                    else if (options.onDismiss) options.onDismiss();
                    isPointerInside = false;
                };

                // Delayed registration to prevent the opening click from dismissing
                const timerId = setTimeout(() => {
                    document.addEventListener('pointerdown', onPointerDown);
                }, 0);

                document.addEventListener('keydown', onKeyDown);

                return () => {
                    clearTimeout(timerId);
                    document.removeEventListener('pointerdown', onPointerDown);
                    document.removeEventListener('keydown', onKeyDown);
                    container.removeEventListener('pointerdown', onPointerDownCapture, true);
                    this._layers = this._layers.filter(l => l !== container);
                    if (options.disableOutsidePointerEvents) {
                        if (this._layers.length === 0) {
                            document.body.style.pointerEvents = savedPointerEvents || '';
                        }
                    }
                };
            }
        },

        // --- Floating Positioning -------------------------------------------------
        Floating: {
            /**
             * Position a floating element relative to a reference element.
             * Supports side/align/sideOffset with flip and shift.
             * Sets data-side and data-align for CSS animation targeting.
             */
            position(reference, floating, options = {}) {
                const side = options.side || 'bottom';
                const align = options.align || 'center';
                const sideOffset = options.sideOffset || 0;
                const alignOffset = options.alignOffset || 0;
                const avoidCollisions = options.avoidCollisions !== false;

                function update() {
                    const ref = reference.getBoundingClientRect();
                    const flt = floating.getBoundingClientRect();
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    const pad = 4;

                    // Calculate align offset based on alignment
                    function alignPos(refStart, refSize, fltSize) {
                        if (align === 'start') return refStart + alignOffset;
                        if (align === 'end') return refStart + refSize - fltSize + alignOffset;
                        return refStart + (refSize - fltSize) / 2 + alignOffset;
                    }

                    let top, left, actualSide = side;

                    // Initial position
                    if (side === 'bottom') {
                        top = ref.bottom + sideOffset;
                        left = alignPos(ref.left, ref.width, flt.width);
                    } else if (side === 'top') {
                        top = ref.top - flt.height - sideOffset;
                        left = alignPos(ref.left, ref.width, flt.width);
                    } else if (side === 'right') {
                        left = ref.right + sideOffset;
                        top = alignPos(ref.top, ref.height, flt.height);
                    } else {
                        left = ref.left - flt.width - sideOffset;
                        top = alignPos(ref.top, ref.height, flt.height);
                    }

                    // Flip if collision
                    if (avoidCollisions) {
                        if (actualSide === 'bottom' && top + flt.height > vh - pad) {
                            const flipped = ref.top - flt.height - sideOffset;
                            if (flipped >= pad) { top = flipped; actualSide = 'top'; }
                        } else if (actualSide === 'top' && top < pad) {
                            const flipped = ref.bottom + sideOffset;
                            if (flipped + flt.height <= vh - pad) { top = flipped; actualSide = 'bottom'; }
                        } else if (actualSide === 'right' && left + flt.width > vw - pad) {
                            const flipped = ref.left - flt.width - sideOffset;
                            if (flipped >= pad) { left = flipped; actualSide = 'left'; }
                        } else if (actualSide === 'left' && left < pad) {
                            const flipped = ref.right + sideOffset;
                            if (flipped + flt.width <= vw - pad) { left = flipped; actualSide = 'right'; }
                        }

                        // Shift to keep within viewport
                        left = Math.max(pad, Math.min(left, vw - flt.width - pad));
                        top = Math.max(pad, Math.min(top, vh - flt.height - pad));
                    }

                    floating.style.position = 'fixed';
                    floating.style.top = top + 'px';
                    floating.style.left = left + 'px';
                    floating.setAttribute('data-side', actualSide);
                    floating.setAttribute('data-align', align);

                    // CSS custom properties
                    floating.style.setProperty('--radix-popper-anchor-width', ref.width + 'px');
                    floating.style.setProperty('--radix-popper-anchor-height', ref.height + 'px');
                    floating.style.setProperty('--radix-popper-available-width', (vw - pad * 2) + 'px');
                    floating.style.setProperty('--radix-popper-available-height', (vh - pad * 2) + 'px');
                }

                // Make visible for measurement, position, then show
                floating.style.visibility = 'hidden';
                floating.style.display = '';
                requestAnimationFrame(() => {
                    update();
                    floating.style.visibility = '';
                });

                window.addEventListener('scroll', update, true);
                window.addEventListener('resize', update);

                return function cleanup() {
                    window.removeEventListener('scroll', update, true);
                    window.removeEventListener('resize', update);
                };
            }
        },

        // --- Roving Focus ---------------------------------------------------------
        RovingFocus: {
            /**
             * Arrow key navigation within a group of focusable items.
             * @param {HTMLElement} container - The group container
             * @param {string} selector - CSS selector for focusable items
             * @param {Object} options - { orientation: 'horizontal' | 'vertical', loop: true }
             * @returns {Function} cleanup
             */
            activate(container, selector, options = {}) {
                const orientation = options.orientation || 'horizontal';
                const loop = options.loop !== false;
                const nextKey = orientation === 'horizontal' ? 'ArrowRight' : 'ArrowDown';
                const prevKey = orientation === 'horizontal' ? 'ArrowLeft' : 'ArrowUp';

                function handleKeyDown(e) {
                    const items = Array.from(container.querySelectorAll(selector));
                    const current = items.indexOf(document.activeElement);
                    if (current === -1) return;

                    let next;
                    if (e.key === nextKey) {
                        next = current + 1;
                        if (next >= items.length) next = loop ? 0 : current;
                    } else if (e.key === prevKey) {
                        next = current - 1;
                        if (next < 0) next = loop ? items.length - 1 : current;
                    } else if (e.key === 'Home') {
                        next = 0;
                    } else if (e.key === 'End') {
                        next = items.length - 1;
                    } else {
                        return;
                    }

                    e.preventDefault();
                    items[next].focus();
                }

                container.addEventListener('keydown', handleKeyDown);
                return function cleanup() {
                    container.removeEventListener('keydown', handleKeyDown);
                };
            }
        },

        // --- Presence Animation ---------------------------------------------------
        Presence: {
            /**
             * Mount/unmount with CSS transitions.
             * @param {HTMLElement} element - Element to animate
             * @param {boolean} present - Whether element should be visible
             * @param {Object} options - { enterClass, exitClass, duration }
             */
            toggle(element, present, options = {}) {
                const enterClass = options.enterClass || 'suite-enter';
                const exitClass = options.exitClass || 'suite-exit';

                if (present) {
                    element.style.display = '';
                    element.classList.remove(exitClass);
                    // Force reflow
                    element.offsetHeight;
                    element.classList.add(enterClass);
                } else {
                    element.classList.remove(enterClass);
                    element.classList.add(exitClass);
                    // Remove after animation
                    element.addEventListener('animationend', function handler() {
                        element.style.display = 'none';
                        element.classList.remove(exitClass);
                        element.removeEventListener('animationend', handler);
                    }, { once: true });
                    // Fallback if no animation defined
                    const duration = options.duration || 200;
                    setTimeout(() => {
                        if (element.classList.contains(exitClass)) {
                            element.style.display = 'none';
                            element.classList.remove(exitClass);
                        }
                    }, duration + 50);
                }
            }
        },

        // --- Collapsible ----------------------------------------------------------
        Collapsible: {
            /**
             * Initialize collapsible components.
             * Discovers [data-suite-collapsible] roots and wires trigger→content toggle.
             */
            init() {
                const roots = document.querySelectorAll('[data-suite-collapsible]');
                roots.forEach(root => {
                    if (root._suiteCollapsible) return;
                    root._suiteCollapsible = true;

                    const trigger = root.querySelector('[data-suite-collapsible-trigger]');
                    const content = root.querySelector('[data-suite-collapsible-content]');
                    if (!trigger || !content) return;

                    // Sync initial state from root
                    const initialState = root.getAttribute('data-state') || 'closed';
                    trigger.setAttribute('data-state', initialState);
                    trigger.setAttribute('aria-expanded', String(initialState === 'open'));
                    content.setAttribute('data-state', initialState);
                    content.hidden = initialState !== 'open';

                    trigger.addEventListener('click', () => {
                        if (root.hasAttribute('data-disabled')) return;
                        const isOpen = root.getAttribute('data-state') === 'open';
                        const newState = isOpen ? 'closed' : 'open';
                        root.setAttribute('data-state', newState);
                        trigger.setAttribute('data-state', newState);
                        trigger.setAttribute('aria-expanded', String(!isOpen));
                        content.setAttribute('data-state', newState);
                        content.hidden = isOpen;
                    });
                });
            }
        },

        // --- Accordion ------------------------------------------------------------
        Accordion: {
            /**
             * Initialize accordion components.
             * Discovers [data-suite-accordion] roots. Handles single/multiple mode,
             * collapsible flag, and keyboard navigation between triggers.
             */
            init() {
                const roots = document.querySelectorAll('[data-suite-accordion]');
                roots.forEach(root => {
                    if (root._suiteAccordion) return;
                    root._suiteAccordion = true;

                    const type = root.getAttribute('data-suite-accordion') || 'single';
                    const collapsible = root.hasAttribute('data-collapsible');
                    const orientation = root.getAttribute('data-orientation') || 'vertical';

                    function getItems() {
                        return Array.from(root.querySelectorAll('[data-suite-accordion-item]'));
                    }

                    function getTriggers() {
                        return Array.from(root.querySelectorAll('[data-suite-accordion-trigger]'))
                            .filter(t => !t.disabled && !t.closest('[data-suite-accordion-item]').hasAttribute('data-disabled'));
                    }

                    function toggleItem(item, open) {
                        const state = open ? 'open' : 'closed';
                        item.setAttribute('data-state', state);
                        const trigger = item.querySelector('[data-suite-accordion-trigger]');
                        const content = item.querySelector('[data-suite-accordion-content]');
                        if (trigger) {
                            trigger.setAttribute('data-state', state);
                            trigger.setAttribute('aria-expanded', String(open));
                            if (type === 'single' && open && !collapsible) {
                                trigger.setAttribute('aria-disabled', 'true');
                            } else {
                                trigger.removeAttribute('aria-disabled');
                            }
                        }
                        if (content) {
                            content.setAttribute('data-state', state);
                            content.hidden = !open;
                        }
                    }

                    // Trigger click handlers
                    root.addEventListener('click', (e) => {
                        const trigger = e.target.closest('[data-suite-accordion-trigger]');
                        if (!trigger || trigger.disabled) return;
                        const item = trigger.closest('[data-suite-accordion-item]');
                        if (!item || item.hasAttribute('data-disabled')) return;

                        const isOpen = item.getAttribute('data-state') === 'open';

                        if (type === 'single') {
                            if (isOpen) {
                                if (collapsible) toggleItem(item, false);
                                // If not collapsible, do nothing (can't close last open)
                            } else {
                                // Close all others, open this one
                                getItems().forEach(i => toggleItem(i, false));
                                toggleItem(item, true);
                            }
                        } else {
                            // Multiple mode — always toggle
                            toggleItem(item, !isOpen);
                        }
                    });

                    // Keyboard navigation between triggers
                    root.addEventListener('keydown', (e) => {
                        const trigger = e.target.closest('[data-suite-accordion-trigger]');
                        if (!trigger) return;

                        const triggers = getTriggers();
                        const idx = triggers.indexOf(trigger);
                        if (idx === -1) return;

                        const isVert = orientation === 'vertical';
                        const nextKey = isVert ? 'ArrowDown' : 'ArrowRight';
                        const prevKey = isVert ? 'ArrowUp' : 'ArrowLeft';
                        let target;

                        if (e.key === nextKey) {
                            target = triggers[(idx + 1) % triggers.length];
                        } else if (e.key === prevKey) {
                            target = triggers[(idx - 1 + triggers.length) % triggers.length];
                        } else if (e.key === 'Home') {
                            target = triggers[0];
                        } else if (e.key === 'End') {
                            target = triggers[triggers.length - 1];
                        }

                        if (target) {
                            e.preventDefault();
                            target.focus();
                        }
                    });
                });
            }
        },

        // --- Tabs -----------------------------------------------------------------
        Tabs: {
            /**
             * Initialize tabs components.
             * Discovers [data-suite-tabs] roots. Handles tab selection,
             * roving tabindex on TabsList, and keyboard navigation.
             */
            init() {
                const roots = document.querySelectorAll('[data-suite-tabs]');
                roots.forEach(root => {
                    if (root._suiteTabs) return;
                    root._suiteTabs = true;

                    const orientation = root.getAttribute('data-orientation') || 'horizontal';
                    const activation = root.getAttribute('data-activation') || 'automatic';
                    const list = root.querySelector('[data-suite-tabslist]');
                    if (!list) return;

                    const loop = !list.hasAttribute('data-no-loop');

                    function getTriggers() {
                        return Array.from(list.querySelectorAll('[data-suite-tabs-trigger]'))
                            .filter(t => !t.disabled && !t.hasAttribute('data-disabled'));
                    }

                    function selectTab(value) {
                        // Update triggers
                        const triggers = Array.from(list.querySelectorAll('[data-suite-tabs-trigger]'));
                        triggers.forEach(t => {
                            const isActive = t.getAttribute('data-suite-tabs-trigger') === value;
                            t.setAttribute('data-state', isActive ? 'active' : 'inactive');
                            t.setAttribute('aria-selected', String(isActive));
                            t.setAttribute('tabindex', isActive ? '0' : '-1');
                        });
                        // Update content panels
                        const panels = Array.from(root.querySelectorAll('[data-suite-tabs-content]'));
                        panels.forEach(p => {
                            const isActive = p.getAttribute('data-suite-tabs-content') === value;
                            p.setAttribute('data-state', isActive ? 'active' : 'inactive');
                            p.hidden = !isActive;
                        });
                    }

                    // Click handler
                    list.addEventListener('click', (e) => {
                        const trigger = e.target.closest('[data-suite-tabs-trigger]');
                        if (!trigger || trigger.disabled || trigger.hasAttribute('data-disabled')) return;
                        selectTab(trigger.getAttribute('data-suite-tabs-trigger'));
                    });

                    // Keyboard handler — roving focus
                    list.addEventListener('keydown', (e) => {
                        // Suppress arrow nav when modifier keys are pressed
                        if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) return;

                        const trigger = e.target.closest('[data-suite-tabs-trigger]');
                        if (!trigger) return;

                        const triggers = getTriggers();
                        const idx = triggers.indexOf(trigger);
                        if (idx === -1) return;

                        const isHoriz = orientation === 'horizontal';
                        const nextKey = isHoriz ? 'ArrowRight' : 'ArrowDown';
                        const prevKey = isHoriz ? 'ArrowLeft' : 'ArrowUp';
                        let target;

                        if (e.key === nextKey) {
                            const next = idx + 1;
                            target = next < triggers.length ? triggers[next] : (loop ? triggers[0] : null);
                        } else if (e.key === prevKey) {
                            const prev = idx - 1;
                            target = prev >= 0 ? triggers[prev] : (loop ? triggers[triggers.length - 1] : null);
                        } else if (e.key === 'Home') {
                            target = triggers[0];
                        } else if (e.key === 'End') {
                            target = triggers[triggers.length - 1];
                        } else if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            selectTab(trigger.getAttribute('data-suite-tabs-trigger'));
                            return;
                        }

                        if (target) {
                            e.preventDefault();
                            target.focus();
                            if (activation === 'automatic') {
                                selectTab(target.getAttribute('data-suite-tabs-trigger'));
                            }
                        }
                    });
                });
            }
        },

        // --- Toggle ---------------------------------------------------------------
        Toggle: {
            /**
             * Initialize standalone toggle buttons.
             * Discovers [data-suite-toggle] elements and wires click→state toggle.
             */
            init() {
                const toggles = document.querySelectorAll('[data-suite-toggle]');
                toggles.forEach(btn => {
                    if (btn._suiteToggle) return;
                    btn._suiteToggle = true;

                    btn.addEventListener('click', () => {
                        if (btn.disabled || btn.hasAttribute('data-disabled')) return;
                        const isOn = btn.getAttribute('data-state') === 'on';
                        const newState = isOn ? 'off' : 'on';
                        btn.setAttribute('data-state', newState);
                        btn.setAttribute('aria-pressed', String(!isOn));
                    });
                });
            }
        },

        // --- Toggle Group ---------------------------------------------------------
        ToggleGroup: {
            /**
             * Initialize toggle groups.
             * Discovers [data-suite-toggle-group] roots. Handles single/multiple selection,
             * ARIA role differences (radio vs pressed), and optional roving focus.
             */
            init() {
                const roots = document.querySelectorAll('[data-suite-toggle-group]');
                roots.forEach(root => {
                    if (root._suiteToggleGroup) return;
                    root._suiteToggleGroup = true;

                    const type = root.getAttribute('data-suite-toggle-group') || 'single';
                    const orientation = root.getAttribute('data-orientation') || 'horizontal';
                    const isDisabled = root.hasAttribute('data-disabled');

                    function getItems() {
                        return Array.from(root.querySelectorAll('[data-suite-toggle-group-item]'))
                            .filter(i => !i.disabled && !i.hasAttribute('data-disabled'));
                    }

                    function updateAria(item, isOn) {
                        item.setAttribute('data-state', isOn ? 'on' : 'off');
                        if (type === 'single') {
                            item.setAttribute('role', 'radio');
                            item.setAttribute('aria-checked', String(isOn));
                            item.removeAttribute('aria-pressed');
                        } else {
                            item.setAttribute('aria-pressed', String(isOn));
                            item.removeAttribute('role');
                            item.removeAttribute('aria-checked');
                        }
                    }

                    // Apply default values
                    const defaultVal = root.getAttribute('data-default-value');
                    if (defaultVal) {
                        const defaults = defaultVal.split(',');
                        root.querySelectorAll('[data-suite-toggle-group-item]').forEach(item => {
                            const val = item.getAttribute('data-suite-toggle-group-item');
                            const isOn = defaults.includes(val);
                            updateAria(item, isOn);
                        });
                    } else {
                        // Initialize ARIA for all items
                        root.querySelectorAll('[data-suite-toggle-group-item]').forEach(item => {
                            updateAria(item, item.getAttribute('data-state') === 'on');
                        });
                    }

                    // Click handler — event delegation
                    root.addEventListener('click', (e) => {
                        if (isDisabled) return;
                        const item = e.target.closest('[data-suite-toggle-group-item]');
                        if (!item || item.disabled || item.hasAttribute('data-disabled')) return;

                        const isOn = item.getAttribute('data-state') === 'on';

                        if (type === 'single') {
                            // Deselect all, select this (or deselect if already on)
                            getItems().forEach(i => updateAria(i, false));
                            if (!isOn) updateAria(item, true);
                        } else {
                            // Multiple — just toggle this item
                            updateAria(item, !isOn);
                        }
                    });

                    // Keyboard — roving focus between items
                    root.addEventListener('keydown', (e) => {
                        if (isDisabled) return;
                        const item = e.target.closest('[data-suite-toggle-group-item]');
                        if (!item) return;

                        const items = getItems();
                        const idx = items.indexOf(item);
                        if (idx === -1) return;

                        const isHoriz = orientation === 'horizontal';
                        const nextKey = isHoriz ? 'ArrowRight' : 'ArrowDown';
                        const prevKey = isHoriz ? 'ArrowLeft' : 'ArrowUp';
                        let target;

                        if (e.key === nextKey) {
                            target = items[(idx + 1) % items.length];
                        } else if (e.key === prevKey) {
                            target = items[(idx - 1 + items.length) % items.length];
                        } else if (e.key === 'Home') {
                            target = items[0];
                        } else if (e.key === 'End') {
                            target = items[items.length - 1];
                        }

                        if (target) {
                            e.preventDefault();
                            target.focus();
                        }
                    });
                });
            }
        },

        // --- Switch ---------------------------------------------------------------
        Switch: {
            /**
             * Initialize switch components.
             * Discovers [data-suite-switch] buttons and wires click→state toggle.
             * Thumb animation handled purely via CSS data-[state] selectors.
             */
            init() {
                const switches = document.querySelectorAll('[data-suite-switch]');
                switches.forEach(btn => {
                    if (btn._suiteSwitch) return;
                    btn._suiteSwitch = true;

                    btn.addEventListener('click', () => {
                        if (btn.disabled || btn.hasAttribute('data-disabled')) return;
                        const isChecked = btn.getAttribute('data-state') === 'checked';
                        const newState = isChecked ? 'unchecked' : 'checked';
                        btn.setAttribute('data-state', newState);
                        btn.setAttribute('aria-checked', String(!isChecked));
                        // Update thumb data-state
                        const thumb = btn.querySelector('span');
                        if (thumb) thumb.setAttribute('data-state', newState);
                    });
                });
            }
        },

        // --- Theme Toggle ---------------------------------------------------------
        ThemeToggle: {
            /**
             * Initialize theme toggle buttons.
             * Discovers elements with data-suite-theme-toggle attribute.
             * Toggles `dark` class on <html> and persists to localStorage.
             */
            init() {
                const toggles = document.querySelectorAll('[data-suite-theme-toggle]');
                toggles.forEach(toggle => {
                    if (toggle._suiteThemeToggle) return; // Already initialized
                    toggle._suiteThemeToggle = true;
                    toggle.addEventListener('click', () => {
                        const isDark = document.documentElement.classList.toggle('dark');
                        try {
                            localStorage.setItem(Suite._themeKey('therapy-theme'), isDark ? 'dark' : 'light');
                        } catch (e) {}
                    });
                });
            }
        },

        // --- Theme Switcher -------------------------------------------------------
        ThemeSwitcher: {
            /**
             * Initialize theme switcher dropdowns.
             * Discovers elements with data-suite-theme-switcher attribute.
             * Sets data-theme on <html> and persists to localStorage('suite-active-theme').
             */
            init() {
                const roots = document.querySelectorAll('[data-suite-theme-switcher]');
                roots.forEach(root => {
                    if (root._suiteThemeSwitcher) return;
                    root._suiteThemeSwitcher = true;

                    const trigger = root.querySelector('[data-suite-theme-switcher-trigger]');
                    const content = root.querySelector('[data-suite-theme-switcher-content]');
                    if (!trigger || !content) return;

                    // Show active theme check mark on init
                    this._updateChecks(root);

                    // Toggle dropdown
                    trigger.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = !content.classList.contains('hidden');
                        if (isOpen) {
                            this._close(trigger, content);
                        } else {
                            this._open(trigger, content);
                            // Update checks when opening
                            this._updateChecks(root);
                        }
                    });

                    // Theme option clicks
                    const options = root.querySelectorAll('[data-suite-theme-option]');
                    options.forEach(option => {
                        option.addEventListener('click', () => {
                            const theme = option.getAttribute('data-suite-theme-option');
                            this._applyTheme(theme);
                            this._updateChecks(root);
                            this._close(trigger, content);
                        });
                    });

                    // Click outside to close
                    document.addEventListener('pointerdown', (e) => {
                        if (!root.contains(e.target) && !content.classList.contains('hidden')) {
                            this._close(trigger, content);
                        }
                    });

                    // Escape to close
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && !content.classList.contains('hidden')) {
                            this._close(trigger, content);
                            trigger.focus();
                        }
                    });
                });

                // Also update checks on all switchers (in case theme changed externally)
                roots.forEach(root => this._updateChecks(root));
            },

            _open(trigger, content) {
                content.classList.remove('hidden');
                trigger.setAttribute('aria-expanded', 'true');
            },

            _close(trigger, content) {
                content.classList.add('hidden');
                trigger.setAttribute('aria-expanded', 'false');
            },

            _applyTheme(theme) {
                const html = document.documentElement;
                if (theme === 'default') {
                    html.removeAttribute('data-theme');
                } else {
                    html.setAttribute('data-theme', theme);
                }
                try {
                    localStorage.setItem(Suite._themeKey('suite-active-theme'), theme);
                } catch (e) {}
            },

            _updateChecks(root) {
                const current = document.documentElement.getAttribute('data-theme') || 'default';
                const checks = root.querySelectorAll('[data-suite-theme-check]');
                checks.forEach(check => {
                    const key = check.getAttribute('data-suite-theme-check');
                    if (key === current) {
                        check.classList.remove('hidden');
                    } else {
                        check.classList.add('hidden');
                    }
                });
            },
        },

        // --- Dialog ---------------------------------------------------------------
        Dialog: {
            init() {
                const triggers = document.querySelectorAll('[data-suite-dialog-trigger]');
                triggers.forEach(trigger => {
                    if (trigger._suiteDialog) return;
                    trigger._suiteDialog = true;

                    const dialogId = trigger.getAttribute('data-suite-dialog-trigger');
                    const root = document.querySelector('[data-suite-dialog="' + dialogId + '"]');
                    if (!root) return;

                    const overlay = root.querySelector('[data-suite-dialog-overlay]');
                    const content = root.querySelector('[data-suite-dialog-content]');
                    if (!content) return;

                    let cleanupFocusTrap, cleanupDismiss;

                    function open() {
                        root.style.display = '';
                        if (overlay) {
                            overlay.setAttribute('data-state', 'open');
                            overlay.style.display = '';
                        }
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        cleanupFocusTrap = Suite.FocusTrap.activate(content);
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });
                    }

                    function close() {
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFocusTrap) { cleanupFocusTrap(); cleanupFocusTrap = null; }

                        if (overlay) overlay.setAttribute('data-state', 'closed');
                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        // Wait for close animation before hiding
                        const hide = () => {
                            root.style.display = 'none';
                            if (overlay) overlay.style.display = 'none';
                        };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 250); // fallback
                    }

                    trigger.addEventListener('click', () => {
                        const isOpen = content.getAttribute('data-state') === 'open';
                        if (isOpen) close(); else open();
                    });

                    // Close buttons inside dialog
                    root.querySelectorAll('[data-suite-dialog-close]').forEach(btn => {
                        btn.addEventListener('click', close);
                    });
                });
            }
        },

        // --- AlertDialog ----------------------------------------------------------
        AlertDialog: {
            init() {
                const triggers = document.querySelectorAll('[data-suite-alert-dialog-trigger]');
                triggers.forEach(trigger => {
                    if (trigger._suiteAlertDialog) return;
                    trigger._suiteAlertDialog = true;

                    const dialogId = trigger.getAttribute('data-suite-alert-dialog-trigger');
                    const root = document.querySelector('[data-suite-alert-dialog="' + dialogId + '"]');
                    if (!root) return;

                    const overlay = root.querySelector('[data-suite-alert-dialog-overlay]');
                    const content = root.querySelector('[data-suite-alert-dialog-content]');
                    if (!content) return;

                    let cleanupFocusTrap, cleanupDismiss;

                    function open() {
                        root.style.display = '';
                        if (overlay) {
                            overlay.setAttribute('data-state', 'open');
                            overlay.style.display = '';
                        }
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        // Auto-focus Cancel button (not first tabbable)
                        const cancelBtn = content.querySelector('[data-suite-alert-dialog-cancel]');
                        cleanupFocusTrap = Suite.FocusTrap.activate(content, {
                            initialFocus: cancelBtn || undefined
                        });

                        // AlertDialog: Escape and click-outside do NOT dismiss
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onEscapeKeyDown: (e) => e.preventDefault(),
                            onPointerDownOutside: (e) => e.preventDefault(),
                            onDismiss: () => {}, // never auto-dismisses
                        });
                    }

                    function close() {
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFocusTrap) { cleanupFocusTrap(); cleanupFocusTrap = null; }

                        if (overlay) overlay.setAttribute('data-state', 'closed');
                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        const hide = () => {
                            root.style.display = 'none';
                            if (overlay) overlay.style.display = 'none';
                        };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 250);
                    }

                    trigger.addEventListener('click', () => {
                        const isOpen = content.getAttribute('data-state') === 'open';
                        if (isOpen) close(); else open();
                    });

                    // Action and Cancel both close
                    root.querySelectorAll('[data-suite-alert-dialog-action], [data-suite-alert-dialog-cancel]').forEach(btn => {
                        btn.addEventListener('click', close);
                    });
                });
            }
        },

        // --- Sheet ----------------------------------------------------------------
        Sheet: {
            init() {
                // Sheet reuses Dialog's exact JS behavior — FocusTrap, DismissLayer, ScrollLock.
                // The only difference is CSS (slide from edge vs center zoom).
                const triggers = document.querySelectorAll('[data-suite-sheet-trigger]');
                triggers.forEach(trigger => {
                    if (trigger._suiteSheet) return;
                    trigger._suiteSheet = true;

                    const sheetId = trigger.getAttribute('data-suite-sheet-trigger');
                    const root = document.querySelector('[data-suite-sheet="' + sheetId + '"]');
                    if (!root) return;

                    const overlay = root.querySelector('[data-suite-sheet-overlay]');
                    const content = root.querySelector('[data-suite-sheet-content]');
                    if (!content) return;

                    let cleanupFocusTrap, cleanupDismiss;

                    function open() {
                        root.style.display = '';
                        if (overlay) {
                            overlay.setAttribute('data-state', 'open');
                            overlay.style.display = '';
                        }
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        cleanupFocusTrap = Suite.FocusTrap.activate(content);
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });
                    }

                    function close() {
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFocusTrap) { cleanupFocusTrap(); cleanupFocusTrap = null; }

                        if (overlay) overlay.setAttribute('data-state', 'closed');
                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        const hide = () => {
                            root.style.display = 'none';
                            if (overlay) overlay.style.display = 'none';
                        };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 350); // longer fallback for slide animations (300-500ms)
                    }

                    trigger.addEventListener('click', () => {
                        const isOpen = content.getAttribute('data-state') === 'open';
                        if (isOpen) close(); else open();
                    });

                    // Close buttons inside sheet
                    root.querySelectorAll('[data-suite-sheet-close]').forEach(btn => {
                        btn.addEventListener('click', close);
                    });
                });
            }
        },

        // --- Drawer ---------------------------------------------------------------
        Drawer: {
            VELOCITY_THRESHOLD: 0.4,
            CLOSE_THRESHOLD: 0.25,

            init() {
                const triggers = document.querySelectorAll('[data-suite-drawer-trigger]');
                triggers.forEach(trigger => {
                    if (trigger._suiteDrawer) return;
                    trigger._suiteDrawer = true;

                    const drawerId = trigger.getAttribute('data-suite-drawer-trigger');
                    const root = document.querySelector('[data-suite-drawer="' + drawerId + '"]');
                    if (!root) return;

                    const overlay = root.querySelector('[data-suite-drawer-overlay]');
                    const content = root.querySelector('[data-suite-drawer-content]');
                    if (!content) return;

                    const direction = content.getAttribute('data-suite-drawer-direction') || 'bottom';
                    const isVertical = direction === 'bottom' || direction === 'top';

                    let cleanupFocusTrap, cleanupDismiss;
                    let isDragging = false;
                    let dragStart = 0;
                    let dragStartTime = 0;
                    let drawerSize = 0;

                    function open() {
                        root.style.display = '';
                        if (overlay) {
                            overlay.setAttribute('data-state', 'open');
                            overlay.style.display = '';
                        }
                        content.setAttribute('data-state', 'open');
                        content.style.transform = '';
                        content.style.transition = '';
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        cleanupFocusTrap = Suite.FocusTrap.activate(content);
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });
                    }

                    function close() {
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFocusTrap) { cleanupFocusTrap(); cleanupFocusTrap = null; }

                        // Animate out in the correct direction
                        const rect = content.getBoundingClientRect();
                        let transform = '';
                        if (direction === 'bottom') transform = 'translateY(' + rect.height + 'px)';
                        else if (direction === 'top') transform = 'translateY(-' + rect.height + 'px)';
                        else if (direction === 'right') transform = 'translateX(' + rect.width + 'px)';
                        else if (direction === 'left') transform = 'translateX(-' + rect.width + 'px)';

                        content.style.transition = 'transform 0.5s cubic-bezier(0.32, 0.72, 0, 1)';
                        content.style.transform = transform;
                        if (overlay) {
                            overlay.setAttribute('data-state', 'closed');
                        }
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        const hide = () => {
                            root.style.display = 'none';
                            if (overlay) overlay.style.display = 'none';
                            content.setAttribute('data-state', 'closed');
                            content.style.transform = '';
                            content.style.transition = '';
                        };
                        content.addEventListener('transitionend', hide, { once: true });
                        setTimeout(hide, 600);
                    }

                    // --- Drag-to-dismiss ---
                    content.addEventListener('pointerdown', (e) => {
                        // Don't drag on select elements or elements with data-vaul-no-drag
                        if (e.target.closest('select, [data-no-drag]')) return;
                        // Don't drag scrollable children that have scroll offset
                        const scrollable = e.target.closest('[style*="overflow"]');
                        if (scrollable && scrollable.scrollTop > 0) return;

                        isDragging = true;
                        dragStart = isVertical ? e.clientY : e.clientX;
                        dragStartTime = Date.now();
                        drawerSize = isVertical ? content.getBoundingClientRect().height : content.getBoundingClientRect().width;
                        content.style.transition = 'none';
                        content.setPointerCapture(e.pointerId);
                    });

                    content.addEventListener('pointermove', (e) => {
                        if (!isDragging) return;
                        const current = isVertical ? e.clientY : e.clientX;
                        let delta = current - dragStart;

                        // Flip direction for top/left
                        if (direction === 'top' || direction === 'left') delta = -delta;

                        if (delta < 0) {
                            // Dragging past open — logarithmic damping
                            const damped = -8 * (Math.log(Math.abs(delta) + 1) - 2);
                            if (isVertical) {
                                content.style.transform = direction === 'bottom'
                                    ? 'translateY(' + Math.max(damped, -20) + 'px)'
                                    : 'translateY(' + Math.min(-damped, 20) + 'px)';
                            } else {
                                content.style.transform = direction === 'right'
                                    ? 'translateX(' + Math.max(damped, -20) + 'px)'
                                    : 'translateX(' + Math.min(-damped, 20) + 'px)';
                            }
                        } else {
                            // Dragging toward dismiss — linear
                            if (isVertical) {
                                content.style.transform = direction === 'bottom'
                                    ? 'translateY(' + delta + 'px)'
                                    : 'translateY(-' + delta + 'px)';
                            } else {
                                content.style.transform = direction === 'right'
                                    ? 'translateX(' + delta + 'px)'
                                    : 'translateX(-' + delta + 'px)';
                            }

                            // Fade overlay proportionally
                            if (overlay) {
                                const pct = 1 - (delta / drawerSize);
                                overlay.style.opacity = Math.max(0, Math.min(1, pct));
                            }
                        }
                    });

                    content.addEventListener('pointerup', (e) => {
                        if (!isDragging) return;
                        isDragging = false;

                        const current = isVertical ? e.clientY : e.clientX;
                        let delta = current - dragStart;
                        if (direction === 'top' || direction === 'left') delta = -delta;

                        const elapsed = (Date.now() - dragStartTime) / 1000; // seconds
                        const velocity = Math.abs(delta) / elapsed / 1000; // px/ms

                        // Reset overlay opacity
                        if (overlay) overlay.style.opacity = '';

                        if (delta <= 0) {
                            // Dragged past open — spring back
                            content.style.transition = 'transform 0.5s cubic-bezier(0.32, 0.72, 0, 1)';
                            content.style.transform = '';
                            return;
                        }

                        const visibleSize = Math.min(drawerSize, isVertical ? window.innerHeight : window.innerWidth);

                        if (velocity > Suite.Drawer.VELOCITY_THRESHOLD || delta >= visibleSize * Suite.Drawer.CLOSE_THRESHOLD) {
                            close();
                        } else {
                            // Spring back
                            content.style.transition = 'transform 0.5s cubic-bezier(0.32, 0.72, 0, 1)';
                            content.style.transform = '';
                        }
                    });

                    trigger.addEventListener('click', () => {
                        const isOpen = content.getAttribute('data-state') === 'open';
                        if (isOpen) close(); else open();
                    });

                    // Close buttons
                    root.querySelectorAll('[data-suite-drawer-close]').forEach(btn => {
                        btn.addEventListener('click', close);
                    });
                });
            }
        },

        // --- Popover --------------------------------------------------------------
        Popover: {
            init() {
                const triggers = document.querySelectorAll('[data-suite-popover-trigger]');
                triggers.forEach(trigger => {
                    if (trigger._suitePopover) return;
                    trigger._suitePopover = true;

                    const popId = trigger.getAttribute('data-suite-popover-trigger');
                    const root = document.querySelector('[data-suite-popover="' + popId + '"]');
                    if (!root) return;

                    const content = root.querySelector('[data-suite-popover-content]');
                    if (!content) return;

                    const side = content.getAttribute('data-side-preference') || 'bottom';
                    const sideOffset = parseInt(content.getAttribute('data-side-offset') || '0', 10);
                    const align = content.getAttribute('data-align-preference') || 'center';

                    let cleanupFloat, cleanupDismiss, cleanupFocusTrap;

                    function open() {
                        root.style.display = '';
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        cleanupFloat = Suite.Floating.position(trigger, content, {
                            side: side, sideOffset: sideOffset, align: align
                        });

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();
                        cleanupFocusTrap = Suite.FocusTrap.activate(content);
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });
                    }

                    function close() {
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFocusTrap) { cleanupFocusTrap(); cleanupFocusTrap = null; }
                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        const hide = () => { root.style.display = 'none'; };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 250);
                    }

                    trigger.addEventListener('click', () => {
                        const isOpen = content.getAttribute('data-state') === 'open';
                        if (isOpen) close(); else open();
                    });

                    root.querySelectorAll('[data-suite-popover-close]').forEach(btn => {
                        btn.addEventListener('click', close);
                    });
                });
            }
        },

        // --- Tooltip --------------------------------------------------------------
        Tooltip: {
            // Provider-level delay state (shared across all tooltips)
            _isOpenDelayed: true,
            _skipTimer: null,
            _DEFAULT_DELAY: 700,
            _SKIP_DELAY: 300,

            init() {
                const roots = document.querySelectorAll('[data-suite-tooltip]');
                roots.forEach(root => {
                    if (root._suiteTooltip) return;
                    root._suiteTooltip = true;

                    const trigger = root.querySelector('[data-suite-tooltip-trigger]');
                    const content = root.querySelector('[data-suite-tooltip-content]');
                    if (!trigger || !content) return;

                    const side = content.getAttribute('data-side-preference') || 'top';
                    const sideOffset = parseInt(content.getAttribute('data-side-offset') || '4', 10);
                    const align = content.getAttribute('data-align-preference') || 'center';
                    const delay = parseInt(root.getAttribute('data-delay') || String(Suite.Tooltip._DEFAULT_DELAY), 10);

                    let openTimer = null;
                    let cleanupFloat = null;
                    let isOpen = false;

                    function show() {
                        if (isOpen) return;
                        isOpen = true;

                        root.style.display = '';
                        content.setAttribute('data-state', 'instant-open');
                        trigger.setAttribute('data-state', 'open');

                        cleanupFloat = Suite.Floating.position(trigger, content, {
                            side: side, sideOffset: sideOffset, align: align
                        });

                        // Set describedby
                        const contentId = content.id || ('suite-tooltip-' + Math.random().toString(36).slice(2, 8));
                        content.id = contentId;
                        trigger.setAttribute('aria-describedby', contentId);

                        // Tooltip Provider: mark as not delayed for quick subsequent tooltips
                        Suite.Tooltip._isOpenDelayed = false;
                        clearTimeout(Suite.Tooltip._skipTimer);
                    }

                    function hide() {
                        if (!isOpen) return;
                        isOpen = false;
                        clearTimeout(openTimer);

                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.removeAttribute('aria-describedby');

                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        const doHide = () => { root.style.display = 'none'; };
                        content.addEventListener('animationend', doHide, { once: true });
                        setTimeout(doHide, 200);

                        // Provider: start skip delay timer
                        Suite.Tooltip._skipTimer = setTimeout(() => {
                            Suite.Tooltip._isOpenDelayed = true;
                        }, Suite.Tooltip._SKIP_DELAY);
                    }

                    // Hover handlers
                    trigger.addEventListener('pointerenter', (e) => {
                        if (e.pointerType === 'touch') return;
                        clearTimeout(openTimer);
                        if (Suite.Tooltip._isOpenDelayed) {
                            openTimer = setTimeout(show, delay);
                        } else {
                            show();
                        }
                    });

                    trigger.addEventListener('pointerleave', (e) => {
                        if (e.pointerType === 'touch') return;
                        clearTimeout(openTimer);
                        hide();
                    });

                    // Keep tooltip open when hovering content
                    content.addEventListener('pointerenter', () => { clearTimeout(openTimer); });
                    content.addEventListener('pointerleave', () => { hide(); });

                    // Focus handlers — instant open (no delay)
                    trigger.addEventListener('focus', (e) => {
                        // Don't open on focus from pointer (already handled by pointer)
                        if (e.sourceCapabilities) return; // pointer-originated focus
                        show();
                    });
                    trigger.addEventListener('blur', () => { hide(); });

                    // Escape dismisses
                    trigger.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && isOpen) hide();
                    });

                    // Click closes
                    trigger.addEventListener('pointerdown', () => {
                        if (isOpen) hide();
                    });
                });
            }
        },

        // --- HoverCard ------------------------------------------------------------
        HoverCard: {
            init() {
                const roots = document.querySelectorAll('[data-suite-hover-card]');
                roots.forEach(root => {
                    if (root._suiteHoverCard) return;
                    root._suiteHoverCard = true;

                    const trigger = root.querySelector('[data-suite-hover-card-trigger]');
                    const content = root.querySelector('[data-suite-hover-card-content]');
                    if (!trigger || !content) return;

                    const side = content.getAttribute('data-side-preference') || 'bottom';
                    const sideOffset = parseInt(content.getAttribute('data-side-offset') || '4', 10);
                    const align = content.getAttribute('data-align-preference') || 'center';
                    const openDelay = parseInt(root.getAttribute('data-open-delay') || '700', 10);
                    const closeDelay = parseInt(root.getAttribute('data-close-delay') || '300', 10);

                    let openTimer = null;
                    let closeTimer = null;
                    let cleanupFloat = null;
                    let cleanupDismiss = null;
                    let isOpen = false;

                    function open() {
                        if (isOpen) return;
                        isOpen = true;

                        root.style.display = '';
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');

                        cleanupFloat = Suite.Floating.position(trigger, content, {
                            side: side, sideOffset: sideOffset, align: align
                        });
                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            onDismiss: close,
                        });
                    }

                    function close() {
                        if (!isOpen) return;
                        isOpen = false;
                        clearTimeout(openTimer);
                        clearTimeout(closeTimer);

                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');

                        const doHide = () => { root.style.display = 'none'; };
                        content.addEventListener('animationend', doHide, { once: true });
                        setTimeout(doHide, 250);
                    }

                    function startOpen() {
                        clearTimeout(closeTimer);
                        openTimer = setTimeout(open, openDelay);
                    }

                    function startClose() {
                        clearTimeout(openTimer);
                        closeTimer = setTimeout(close, closeDelay);
                    }

                    // Trigger hover
                    trigger.addEventListener('pointerenter', (e) => {
                        if (e.pointerType === 'touch') return;
                        startOpen();
                    });
                    trigger.addEventListener('pointerleave', (e) => {
                        if (e.pointerType === 'touch') return;
                        startClose();
                    });

                    // Content hover — keep open
                    content.addEventListener('pointerenter', () => { clearTimeout(closeTimer); });
                    content.addEventListener('pointerleave', () => { startClose(); });

                    // Focus
                    trigger.addEventListener('focus', () => { startOpen(); });
                    trigger.addEventListener('blur', () => { startClose(); });

                    // Touch prevention
                    trigger.addEventListener('touchstart', (e) => { e.preventDefault(); });
                });
            }
        },

        // --- Menu (shared base) ---------------------------------------------------
        Menu: {
            /**
             * Shared menu behavior for DropdownMenu, ContextMenu, Menubar.
             * Handles keyboard navigation, typeahead, item highlighting,
             * checkbox/radio items, sub-menus, and grace area.
             */

            /**
             * Activate menu behavior on a content element.
             * @param {HTMLElement} content - The menu content container (role=menu)
             * @param {Object} options - { onClose, isSubmenu }
             * @returns {Function} cleanup
             */
            activate(content, options = {}) {
                const onClose = options.onClose || (() => {});
                const isSubmenu = options.isSubmenu || false;
                const onNavigateLeft = options.onNavigateLeft || null;
                const onNavigateRight = options.onNavigateRight || null;

                // Typeahead state
                let searchBuffer = '';
                let searchTimer = null;

                function getItems() {
                    return Array.from(content.querySelectorAll(
                        '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                    )).filter(el => !el.hasAttribute('data-disabled') && !el.closest('[data-suite-menu-sub-content]'));
                }

                function focusItem(item) {
                    // Remove highlight from all
                    getItems().forEach(i => i.removeAttribute('data-highlighted'));
                    if (item) {
                        item.setAttribute('data-highlighted', '');
                        item.focus({ preventScroll: true });
                    }
                }

                function focusFirst() {
                    const items = getItems();
                    if (items.length > 0) focusItem(items[0]);
                }

                function focusLast() {
                    const items = getItems();
                    if (items.length > 0) focusItem(items[items.length - 1]);
                }

                // Typeahead search
                function getNextMatch(values, search, currentMatch) {
                    // Normalize repeated chars: 'aaa' → 'a'
                    const chars = search.split('');
                    const allSame = chars.every(c => c === chars[0]);
                    const normalized = allSame ? chars[0] : search;

                    let candidates = values;
                    if (currentMatch) {
                        const idx = values.indexOf(currentMatch);
                        if (idx >= 0) {
                            // Wrap array from current position + 1
                            candidates = [...values.slice(idx + 1), ...values.slice(0, idx + 1)];
                        }
                    }

                    if (normalized.length === 1) {
                        // Single char: exclude current match to cycle
                        return candidates.find(v =>
                            v.toLowerCase().startsWith(normalized.toLowerCase()) &&
                            v !== currentMatch
                        ) || candidates.find(v =>
                            v.toLowerCase().startsWith(normalized.toLowerCase())
                        );
                    }
                    return candidates.find(v =>
                        v.toLowerCase().startsWith(normalized.toLowerCase())
                    );
                }

                function handleTypeahead(key) {
                    searchBuffer += key;
                    clearTimeout(searchTimer);
                    searchTimer = setTimeout(() => { searchBuffer = ''; }, 1000);

                    const items = getItems();
                    const textValues = items.map(el =>
                        el.getAttribute('data-text-value') || el.textContent.trim()
                    );
                    const currentItem = content.querySelector('[data-highlighted]');
                    const currentText = currentItem
                        ? (currentItem.getAttribute('data-text-value') || currentItem.textContent.trim())
                        : undefined;
                    const match = getNextMatch(textValues, searchBuffer, currentText);
                    if (match) {
                        const idx = textValues.indexOf(match);
                        if (idx >= 0) focusItem(items[idx]);
                    }
                }

                function selectItem(item) {
                    if (!item || item.hasAttribute('data-disabled')) return;

                    // CheckboxItem toggle
                    if (item.hasAttribute('data-suite-menu-checkbox-item')) {
                        const checked = item.getAttribute('data-state') === 'checked';
                        const newState = checked ? 'unchecked' : 'checked';
                        item.setAttribute('data-state', newState);
                        item.setAttribute('aria-checked', String(!checked));
                        const indicator = item.querySelector('[data-suite-menu-item-indicator]');
                        if (indicator) indicator.style.display = checked ? 'none' : '';
                        return; // Don't close menu for checkbox
                    }

                    // RadioItem select
                    if (item.hasAttribute('data-suite-menu-radio-item')) {
                        const group = item.closest('[data-suite-menu-radio-group]');
                        if (group) {
                            group.querySelectorAll('[data-suite-menu-radio-item]').forEach(ri => {
                                ri.setAttribute('data-state', 'unchecked');
                                ri.setAttribute('aria-checked', 'false');
                                const ind = ri.querySelector('[data-suite-menu-item-indicator]');
                                if (ind) ind.style.display = 'none';
                            });
                        }
                        item.setAttribute('data-state', 'checked');
                        item.setAttribute('aria-checked', 'true');
                        const indicator = item.querySelector('[data-suite-menu-item-indicator]');
                        if (indicator) indicator.style.display = '';
                        return; // Don't close menu for radio
                    }

                    // SubTrigger — open sub-menu instead of selecting
                    if (item.hasAttribute('data-suite-menu-sub-trigger')) {
                        openSubmenu(item);
                        return;
                    }

                    // Regular item — close menu after selection
                    setTimeout(() => onClose(), 0);
                }

                function openSubmenu(subTrigger) {
                    const subContent = subTrigger.parentElement &&
                        subTrigger.parentElement.querySelector('[data-suite-menu-sub-content]');
                    if (!subContent) return;

                    subTrigger.setAttribute('data-state', 'open');
                    subContent.style.display = '';
                    subContent.setAttribute('data-state', 'open');

                    // Position sub-menu
                    Suite.Floating.position(subTrigger, subContent, {
                        side: 'right', sideOffset: -4, align: 'start'
                    });

                    // Activate sub-menu behavior
                    const subCleanup = Suite.Menu.activate(subContent, {
                        onClose: () => {
                            closeSubmenu(subTrigger, subContent);
                            subCleanup();
                        },
                        isSubmenu: true,
                    });

                    // Focus first item in sub-menu
                    requestAnimationFrame(() => {
                        const subItems = Array.from(subContent.querySelectorAll(
                            '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item]'
                        )).filter(el => !el.hasAttribute('data-disabled'));
                        if (subItems.length > 0) {
                            subItems[0].setAttribute('data-highlighted', '');
                            subItems[0].focus({ preventScroll: true });
                        }
                    });

                    // Store cleanup for later
                    subTrigger._subCleanup = subCleanup;
                    subTrigger._subContent = subContent;
                }

                function closeSubmenu(subTrigger, subContent) {
                    if (!subContent) return;
                    subTrigger.setAttribute('data-state', 'closed');
                    subContent.setAttribute('data-state', 'closed');
                    subContent.style.display = 'none';
                    // Remove highlights in sub-menu
                    subContent.querySelectorAll('[data-highlighted]').forEach(el => el.removeAttribute('data-highlighted'));
                    if (subTrigger._subCleanup) {
                        subTrigger._subCleanup();
                        subTrigger._subCleanup = null;
                    }
                }

                // Keyboard handler
                function onKeyDown(e) {
                    const items = getItems();
                    const currentItem = content.querySelector('[data-highlighted]');
                    const idx = currentItem ? items.indexOf(currentItem) : -1;

                    // Tab — prevent (menus never support Tab)
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        return;
                    }

                    // Escape — close (handled by DismissLayer, but also close sub-menus)
                    if (e.key === 'Escape') {
                        if (isSubmenu) {
                            e.stopPropagation();
                            onClose();
                        }
                        return;
                    }

                    // Arrow navigation
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const next = idx < items.length - 1 ? idx + 1 : 0;
                        focusItem(items[next]);
                        return;
                    }
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prev = idx > 0 ? idx - 1 : items.length - 1;
                        focusItem(items[prev]);
                        return;
                    }
                    if (e.key === 'Home' || e.key === 'PageUp') {
                        e.preventDefault();
                        focusFirst();
                        return;
                    }
                    if (e.key === 'End' || e.key === 'PageDown') {
                        e.preventDefault();
                        focusLast();
                        return;
                    }

                    // ArrowRight — open sub-menu or navigate menubar right
                    if (e.key === 'ArrowRight') {
                        if (currentItem && currentItem.hasAttribute('data-suite-menu-sub-trigger')) {
                            e.preventDefault();
                            openSubmenu(currentItem);
                            return;
                        }
                        // Menubar inter-menu navigation
                        if (onNavigateRight) {
                            e.preventDefault();
                            onNavigateRight();
                            return;
                        }
                    }

                    // ArrowLeft — close sub-menu (return to parent) or navigate menubar left
                    if (e.key === 'ArrowLeft') {
                        if (isSubmenu) {
                            e.preventDefault();
                            onClose();
                            return;
                        }
                        // Menubar inter-menu navigation
                        if (onNavigateLeft) {
                            e.preventDefault();
                            onNavigateLeft();
                            return;
                        }
                    }

                    // Enter/Space — select item
                    if (e.key === 'Enter' || (e.key === ' ' && searchBuffer === '')) {
                        e.preventDefault();
                        if (currentItem) selectItem(currentItem);
                        return;
                    }

                    // Typeahead — any printable character
                    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                        e.preventDefault();
                        handleTypeahead(e.key);
                    }
                }

                // Pointer handlers — highlight on hover
                function onPointerMove(e) {
                    if (e.pointerType === 'touch' || e.pointerType === 'pen') return;
                    const item = e.target.closest(
                        '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                    );
                    if (item && !item.hasAttribute('data-disabled') && content.contains(item) && !item.closest('[data-suite-menu-sub-content]')) {
                        focusItem(item);
                    }
                }

                function onPointerLeave(e) {
                    if (e.pointerType === 'touch' || e.pointerType === 'pen') return;
                    // Clear highlight, refocus content
                    getItems().forEach(i => i.removeAttribute('data-highlighted'));
                    content.focus({ preventScroll: true });
                }

                // Click handler — select on click
                function onClick(e) {
                    const item = e.target.closest(
                        '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                    );
                    if (item && content.contains(item) && !item.closest('[data-suite-menu-sub-content]')) {
                        selectItem(item);
                    }
                }

                content.addEventListener('keydown', onKeyDown);
                content.addEventListener('pointermove', onPointerMove);
                content.addEventListener('pointerleave', onPointerLeave);
                content.addEventListener('click', onClick);

                return function cleanup() {
                    content.removeEventListener('keydown', onKeyDown);
                    content.removeEventListener('pointermove', onPointerMove);
                    content.removeEventListener('pointerleave', onPointerLeave);
                    content.removeEventListener('click', onClick);
                    clearTimeout(searchTimer);
                    searchBuffer = '';
                    // Cleanup any open sub-menus
                    content.querySelectorAll('[data-suite-menu-sub-trigger]').forEach(st => {
                        if (st._subCleanup) { st._subCleanup(); st._subCleanup = null; }
                    });
                };
            }
        },

        // --- DropdownMenu ---------------------------------------------------------
        DropdownMenu: {
            init() {
                const roots = document.querySelectorAll('[data-suite-dropdown-menu]');
                roots.forEach(root => {
                    if (root._suiteDropdownMenu) return;
                    root._suiteDropdownMenu = true;

                    const trigger = root.querySelector('[data-suite-dropdown-menu-trigger]');
                    const content = root.querySelector('[data-suite-dropdown-menu-content]');
                    if (!trigger || !content) return;

                    const side = content.getAttribute('data-side-preference') || 'bottom';
                    const sideOffset = parseInt(content.getAttribute('data-side-offset') || '4', 10);
                    const align = content.getAttribute('data-align-preference') || 'start';

                    let cleanupFloat, cleanupDismiss, cleanupMenu;
                    let isOpen = false;
                    let wasKeyboardOpen = false;

                    // Track keyboard vs pointer globally
                    let isUsingKeyboard = false;
                    function onDocKeyDown() { isUsingKeyboard = true; }
                    function onDocPointer() { isUsingKeyboard = false; }
                    document.addEventListener('keydown', onDocKeyDown, true);
                    document.addEventListener('pointerdown', onDocPointer, true);

                    function open(focusFirst) {
                        if (isOpen) return;
                        isOpen = true;
                        wasKeyboardOpen = focusFirst;

                        root.style.display = '';
                        content.style.display = '';
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        cleanupFloat = Suite.Floating.position(trigger, content, {
                            side: side, sideOffset: sideOffset, align: align
                        });

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        cleanupMenu = Suite.Menu.activate(content, {
                            onClose: close,
                        });

                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });

                        // Focus first item if keyboard-triggered
                        if (focusFirst) {
                            requestAnimationFrame(() => {
                                const items = Array.from(content.querySelectorAll(
                                    '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                                )).filter(el => !el.hasAttribute('data-disabled') && !el.closest('[data-suite-menu-sub-content]'));
                                if (items.length > 0) {
                                    items[0].setAttribute('data-highlighted', '');
                                    items[0].focus({ preventScroll: true });
                                }
                            });
                        }
                    }

                    function close() {
                        if (!isOpen) return;
                        isOpen = false;

                        if (cleanupMenu) { cleanupMenu(); cleanupMenu = null; }
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        // Remove highlights
                        content.querySelectorAll('[data-highlighted]').forEach(el => el.removeAttribute('data-highlighted'));

                        const hide = () => {
                            content.style.display = 'none';
                        };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 250);

                        // Return focus to trigger
                        trigger.focus({ preventScroll: true });
                    }

                    // Trigger click
                    trigger.addEventListener('pointerdown', (e) => {
                        if (e.button !== 0) return; // left click only
                        if (e.ctrlKey && navigator.platform.match(/Mac/)) return; // ctrl+click on Mac
                        e.preventDefault();
                        if (isOpen) close(); else open(false);
                    });

                    // Trigger keyboard
                    trigger.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (!isOpen) open(true);
                        } else if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            if (isOpen) close(); else open(true);
                        }
                    });
                });
            }
        },

        // --- ContextMenu ----------------------------------------------------------
        ContextMenu: {
            init() {
                const roots = document.querySelectorAll('[data-suite-context-menu]');
                roots.forEach(root => {
                    if (root._suiteContextMenu) return;
                    root._suiteContextMenu = true;

                    const triggerEl = root.querySelector('[data-suite-context-menu-trigger]');
                    const content = root.querySelector('[data-suite-context-menu-content]');
                    if (!triggerEl || !content) return;

                    let cleanupFloat, cleanupDismiss, cleanupMenu;
                    let isOpen = false;
                    let longPressTimer = null;

                    function openAtPosition(x, y) {
                        if (isOpen) close();
                        isOpen = true;

                        root.style.display = '';
                        content.style.display = '';
                        content.setAttribute('data-state', 'open');

                        // Create virtual anchor at pointer position
                        const virtualAnchor = {
                            getBoundingClientRect() {
                                return { width: 0, height: 0, top: y, right: x, bottom: y, left: x, x: x, y: y };
                            }
                        };

                        cleanupFloat = Suite.Floating.position(virtualAnchor, content, {
                            side: 'right', sideOffset: 2, align: 'start'
                        });

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        cleanupMenu = Suite.Menu.activate(content, { onClose: close });

                        cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: close,
                        });

                        // Focus first item
                        requestAnimationFrame(() => {
                            const items = Array.from(content.querySelectorAll(
                                '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                            )).filter(el => !el.hasAttribute('data-disabled') && !el.closest('[data-suite-menu-sub-content]'));
                            if (items.length > 0) {
                                items[0].setAttribute('data-highlighted', '');
                                items[0].focus({ preventScroll: true });
                            }
                        });
                    }

                    function close() {
                        if (!isOpen) return;
                        isOpen = false;

                        if (cleanupMenu) { cleanupMenu(); cleanupMenu = null; }
                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        content.setAttribute('data-state', 'closed');

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();

                        content.querySelectorAll('[data-highlighted]').forEach(el => el.removeAttribute('data-highlighted'));

                        const hide = () => { content.style.display = 'none'; };
                        content.addEventListener('animationend', hide, { once: true });
                        setTimeout(hide, 250);
                    }

                    // Right-click handler
                    triggerEl.addEventListener('contextmenu', (e) => {
                        if (triggerEl.hasAttribute('data-disabled')) return;
                        clearTimeout(longPressTimer);
                        e.preventDefault();
                        openAtPosition(e.clientX, e.clientY);
                    });

                    // Touch long-press (700ms)
                    triggerEl.addEventListener('pointerdown', (e) => {
                        if (e.pointerType === 'mouse') return;
                        clearTimeout(longPressTimer);
                        longPressTimer = setTimeout(() => {
                            openAtPosition(e.clientX, e.clientY);
                        }, 700);
                    });

                    triggerEl.addEventListener('pointermove', (e) => {
                        if (e.pointerType === 'mouse') return;
                        clearTimeout(longPressTimer);
                    });
                    triggerEl.addEventListener('pointerup', (e) => {
                        if (e.pointerType === 'mouse') return;
                        clearTimeout(longPressTimer);
                    });
                    triggerEl.addEventListener('pointercancel', () => {
                        clearTimeout(longPressTimer);
                    });

                    // iOS: prevent native context menu
                    triggerEl.style.webkitTouchCallout = 'none';
                });
            }
        },

        // --- Select ---------------------------------------------------------------
        Select: {
            _initialized: new WeakSet(),

            init() {
                document.querySelectorAll('[data-suite-select]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);

                    const id = root.getAttribute('data-suite-select');
                    const trigger = root.querySelector(`[data-suite-select-trigger="${id}"]`) || root.querySelector('[data-suite-select-trigger]');
                    const content = root.querySelector('[data-suite-select-content]');
                    if (!trigger || !content) return;

                    let isOpen = false;
                    let cleanupFloat = null;
                    let cleanupDismiss = null;
                    let highlightedItem = null;
                    let typeaheadSearch = '';
                    let typeaheadTimer = null;

                    // Get initial value from root
                    let currentValue = root.getAttribute('data-suite-select-value') || '';

                    // Update display to show initial value
                    function updateDisplay() {
                        const displayEl = trigger.querySelector('[data-suite-select-display]');
                        if (!displayEl) return;
                        const items = content.querySelectorAll('[data-suite-select-item]');
                        let found = false;
                        items.forEach(item => {
                            const itemVal = item.getAttribute('data-suite-select-item-value') || '';
                            if (itemVal === currentValue && currentValue !== '') {
                                // Show item text
                                const textEl = item.querySelector('[data-suite-select-item-text-content]');
                                displayEl.textContent = textEl ? textEl.textContent : item.textContent.trim();
                                displayEl.removeAttribute('data-placeholder');
                                found = true;
                                // Show check indicator on this item
                                item.setAttribute('data-state', 'checked');
                                item.setAttribute('aria-selected', 'true');
                                const indicator = item.querySelector('[data-suite-select-item-indicator]');
                                if (indicator) indicator.style.display = '';
                            } else {
                                item.setAttribute('data-state', 'unchecked');
                                item.setAttribute('aria-selected', 'false');
                                const indicator = item.querySelector('[data-suite-select-item-indicator]');
                                if (indicator) indicator.style.display = 'none';
                            }
                        });
                        if (!found && currentValue === '') {
                            // Keep placeholder
                        }
                    }

                    function getItems() {
                        return Array.from(content.querySelectorAll('[data-suite-select-item]:not([data-disabled])'));
                    }

                    function highlightItem(item) {
                        if (highlightedItem) {
                            highlightedItem.removeAttribute('data-highlighted');
                            highlightedItem.classList.remove('bg-warm-100', 'dark:bg-warm-800');
                        }
                        highlightedItem = item;
                        if (item) {
                            item.setAttribute('data-highlighted', '');
                            item.focus();
                        }
                    }

                    function selectItem(item) {
                        if (!item) return;
                        currentValue = item.getAttribute('data-suite-select-item-value') || '';
                        root.setAttribute('data-suite-select-value', currentValue);
                        updateDisplay();
                        close();
                    }

                    function open() {
                        if (isOpen) return;
                        if (root.hasAttribute('data-disabled')) return;
                        isOpen = true;

                        content.style.display = '';
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');
                        trigger.setAttribute('data-state', 'open');

                        const side = content.getAttribute('data-suite-select-side') || 'bottom';
                        const sideOffset = parseInt(content.getAttribute('data-suite-select-side-offset') || '4', 10);
                        const align = content.getAttribute('data-suite-select-align') || 'start';

                        cleanupFloat = Suite.Floating.position(trigger, content, { side, sideOffset, align });
                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        // Focus the selected item or first item
                        requestAnimationFrame(() => {
                            const items = getItems();
                            const selected = items.find(i => i.getAttribute('data-state') === 'checked');
                            highlightItem(selected || items[0]);
                        });

                        cleanupDismiss = Suite.DismissLayer.push({
                            element: content,
                            onEscape: () => close(),
                            onPointerDownOutside: (e) => {
                                if (!trigger.contains(e.target)) close();
                            }
                        });
                    }

                    function close() {
                        if (!isOpen) return;
                        isOpen = false;

                        content.setAttribute('data-state', 'closed');
                        trigger.setAttribute('aria-expanded', 'false');
                        trigger.setAttribute('data-state', 'closed');

                        if (highlightedItem) {
                            highlightedItem.removeAttribute('data-highlighted');
                            highlightedItem = null;
                        }

                        if (cleanupDismiss) { cleanupDismiss(); cleanupDismiss = null; }
                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();
                        if (cleanupFloat) { cleanupFloat(); cleanupFloat = null; }

                        const animDur = 200;
                        setTimeout(() => {
                            if (!isOpen) content.style.display = 'none';
                        }, animDur);

                        trigger.focus();
                    }

                    // Typeahead
                    function handleTypeahead(key) {
                        clearTimeout(typeaheadTimer);
                        typeaheadSearch += key.toLowerCase();

                        // Normalize repeated chars: 'aaa' → 'a'
                        const allSame = typeaheadSearch.split('').every(c => c === typeaheadSearch[0]);
                        const search = allSame ? typeaheadSearch[0] : typeaheadSearch;

                        const items = getItems();
                        const currentIdx = highlightedItem ? items.indexOf(highlightedItem) : -1;

                        // Search forward from current position (wrap)
                        let startIdx = search.length === 1 ? currentIdx + 1 : 0;
                        for (let i = 0; i < items.length; i++) {
                            const idx = (startIdx + i) % items.length;
                            const textEl = items[idx].querySelector('[data-suite-select-item-text-content]');
                            const text = (textEl ? textEl.textContent : items[idx].textContent).trim().toLowerCase();
                            if (text.startsWith(search)) {
                                highlightItem(items[idx]);
                                break;
                            }
                        }

                        typeaheadTimer = setTimeout(() => { typeaheadSearch = ''; }, 1000);
                    }

                    // Trigger events
                    trigger.addEventListener('pointerdown', (e) => {
                        if (e.button !== 0 || (e.ctrlKey && navigator.platform.includes('Mac'))) return;
                        e.preventDefault();
                        if (isOpen) close(); else open();
                    });

                    trigger.addEventListener('keydown', (e) => {
                        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                            if (typeaheadSearch.length > 0 && e.key === ' ') {
                                e.preventDefault();
                                handleTypeahead(' ');
                                return;
                            }
                            handleTypeahead(e.key);
                            return;
                        }
                        if (['ArrowDown', 'ArrowUp', 'Enter', ' '].includes(e.key)) {
                            e.preventDefault();
                            open();
                        }
                    });

                    // Content keyboard navigation
                    content.addEventListener('keydown', (e) => {
                        if (e.key === 'Tab') { e.preventDefault(); return; }

                        const items = getItems();
                        const currentIdx = highlightedItem ? items.indexOf(highlightedItem) : -1;

                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            const next = currentIdx + 1 < items.length ? currentIdx + 1 : 0;
                            highlightItem(items[next]);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            const prev = currentIdx - 1 >= 0 ? currentIdx - 1 : items.length - 1;
                            highlightItem(items[prev]);
                        } else if (e.key === 'Home') {
                            e.preventDefault();
                            highlightItem(items[0]);
                        } else if (e.key === 'End') {
                            e.preventDefault();
                            highlightItem(items[items.length - 1]);
                        } else if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            if (highlightedItem) selectItem(highlightedItem);
                        } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                            if (typeaheadSearch.length > 0 && e.key === ' ') {
                                e.preventDefault();
                                handleTypeahead(' ');
                                return;
                            }
                            handleTypeahead(e.key);
                        }
                    });

                    // Item click
                    content.addEventListener('pointerup', (e) => {
                        const item = e.target.closest('[data-suite-select-item]:not([data-disabled])');
                        if (item && content.contains(item)) {
                            selectItem(item);
                        }
                    });

                    // Item hover highlighting
                    content.addEventListener('pointermove', (e) => {
                        const item = e.target.closest('[data-suite-select-item]:not([data-disabled])');
                        if (item && content.contains(item)) {
                            highlightItem(item);
                        }
                    });

                    // Scroll buttons
                    const scrollUp = content.querySelector('[data-suite-select-scroll-up]');
                    const scrollDown = content.querySelector('[data-suite-select-scroll-down]');
                    let scrollInterval = null;

                    if (scrollUp) {
                        scrollUp.addEventListener('pointerdown', () => {
                            scrollInterval = setInterval(() => { content.scrollTop -= 32; }, 50);
                        });
                        scrollUp.addEventListener('pointerup', () => clearInterval(scrollInterval));
                        scrollUp.addEventListener('pointerleave', () => clearInterval(scrollInterval));
                    }
                    if (scrollDown) {
                        scrollDown.addEventListener('pointerdown', () => {
                            scrollInterval = setInterval(() => { content.scrollTop += 32; }, 50);
                        });
                        scrollDown.addEventListener('pointerup', () => clearInterval(scrollInterval));
                        scrollDown.addEventListener('pointerleave', () => clearInterval(scrollInterval));
                    }

                    // Initialize display
                    updateDisplay();
                });
            }
        },

        // --- Command (cmdk-style) -------------------------------------------------
        Command: {
            _initialized: new WeakSet(),

            /**
             * Fuzzy match scoring — ported from cmdk's command-score.ts
             * Returns 0-1 score. Higher = better match.
             */
            score(string, abbreviation) {
                if (!abbreviation || !string) return 0;
                if (abbreviation.length > string.length) return 0;
                if (abbreviation === string) return 1;

                const lowerString = string.toLowerCase();
                const lowerAbbreviation = abbreviation.toLowerCase();
                const memo = {};

                function inner(sIdx, aIdx) {
                    if (aIdx === abbreviation.length) {
                        return sIdx === string.length ? 1 : 0.99;
                    }
                    const key = sIdx + ',' + aIdx;
                    if (memo[key] !== undefined) return memo[key];

                    let highScore = 0;
                    const targetChar = lowerAbbreviation[aIdx];

                    for (let i = sIdx; i < string.length; i++) {
                        if (lowerString[i] !== targetChar) continue;

                        let score = inner(i + 1, aIdx + 1);
                        if (score <= 0) continue;

                        if (i === sIdx) {
                            score *= 1; // continue match
                        } else if (i > 0) {
                            const prev = string[i - 1];
                            if (prev === ' ' || prev === '-') {
                                score *= 0.9; // space/dash word jump
                            } else if ('\\/_+.#"@[({&'.includes(prev)) {
                                score *= 0.8; // separator word jump
                            } else {
                                score *= 0.17; // character jump
                            }
                        }

                        // Case mismatch penalty
                        if (string[i] !== abbreviation[aIdx]) {
                            score *= 0.9999;
                        }

                        if (score > highScore) highScore = score;
                    }

                    memo[key] = highScore;
                    return highScore;
                }

                return inner(0, 0);
            },

            init() {
                document.querySelectorAll('[data-suite-command]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);

                    const shouldFilter = root.getAttribute('data-suite-command-filter') !== 'false';
                    const loop = root.getAttribute('data-suite-command-loop') !== 'false';
                    const input = root.querySelector('[data-suite-command-input]');
                    const list = root.querySelector('[data-suite-command-list]');
                    const emptyEl = root.querySelector('[data-suite-command-empty]');
                    let selectedItem = null;

                    function getItems() {
                        return Array.from(root.querySelectorAll('[data-suite-command-item]:not([data-disabled="true"])'));
                    }

                    function getVisibleItems() {
                        return getItems().filter(i => i.style.display !== 'none');
                    }

                    function highlightItem(item) {
                        if (selectedItem) {
                            selectedItem.setAttribute('data-selected', 'false');
                            selectedItem.setAttribute('aria-selected', 'false');
                        }
                        selectedItem = item;
                        if (item) {
                            item.setAttribute('data-selected', 'true');
                            item.setAttribute('aria-selected', 'true');
                            item.scrollIntoView({ block: 'nearest' });
                        }
                    }

                    function filterItems(search) {
                        if (!shouldFilter || !search) {
                            // Show all items and groups
                            root.querySelectorAll('[data-suite-command-item]').forEach(item => {
                                item.style.display = '';
                            });
                            root.querySelectorAll('[data-suite-command-group]').forEach(group => {
                                group.style.display = '';
                            });
                            if (emptyEl) emptyEl.style.display = 'none';

                            // Highlight first visible item
                            const items = getVisibleItems();
                            highlightItem(items[0] || null);
                            return;
                        }

                        const scores = [];
                        const items = root.querySelectorAll('[data-suite-command-item]');

                        items.forEach(item => {
                            const value = item.getAttribute('data-suite-command-item-value') || item.textContent.trim();
                            const keywords = item.getAttribute('data-suite-command-item-keywords') || '';
                            const searchText = keywords ? value + ' ' + keywords.replace(/,/g, ' ') : value;
                            const s = Suite.Command.score(searchText, search);

                            if (s > 0) {
                                item.style.display = '';
                                scores.push({ item, score: s });
                            } else {
                                item.style.display = 'none';
                            }
                        });

                        // Sort by score descending (higher = better match)
                        scores.sort((a, b) => b.score - a.score);

                        // Reorder DOM elements by score
                        if (list && scores.length > 0) {
                            // Group-aware: just let CSS handle order, don't reorder DOM
                        }

                        // Show/hide groups based on whether they have visible items
                        root.querySelectorAll('[data-suite-command-group]').forEach(group => {
                            const hasVisible = group.querySelector('[data-suite-command-item]:not([style*="display: none"])');
                            group.style.display = hasVisible ? '' : 'none';
                        });

                        // Show/hide empty state
                        const visibleItems = getVisibleItems();
                        if (emptyEl) {
                            emptyEl.style.display = visibleItems.length === 0 ? '' : 'none';
                        }

                        // Highlight first visible item
                        highlightItem(visibleItems[0] || null);
                    }

                    // Input filtering
                    if (input) {
                        input.addEventListener('input', (e) => {
                            filterItems(e.target.value);
                        });
                    }

                    // Keyboard navigation
                    root.addEventListener('keydown', (e) => {
                        // Suppress during IME composition
                        if (e.isComposing) return;

                        const items = getVisibleItems();
                        const currentIdx = selectedItem ? items.indexOf(selectedItem) : -1;

                        if (e.key === 'ArrowDown' || (e.ctrlKey && (e.key === 'n' || e.key === 'j'))) {
                            e.preventDefault();
                            let next = currentIdx + 1;
                            if (next >= items.length) next = loop ? 0 : items.length - 1;
                            highlightItem(items[next]);
                        } else if (e.key === 'ArrowUp' || (e.ctrlKey && (e.key === 'p' || e.key === 'k'))) {
                            e.preventDefault();
                            let prev = currentIdx - 1;
                            if (prev < 0) prev = loop ? items.length - 1 : 0;
                            highlightItem(items[prev]);
                        } else if (e.key === 'Home') {
                            e.preventDefault();
                            highlightItem(items[0]);
                        } else if (e.key === 'End') {
                            e.preventDefault();
                            highlightItem(items[items.length - 1]);
                        } else if (e.key === 'Enter') {
                            e.preventDefault();
                            if (selectedItem) {
                                selectedItem.click();
                            }
                        }
                    });

                    // Item click
                    root.addEventListener('click', (e) => {
                        const item = e.target.closest('[data-suite-command-item]:not([data-disabled="true"])');
                        if (item && root.contains(item)) {
                            highlightItem(item);
                        }
                    });

                    // Item hover highlighting
                    root.addEventListener('pointermove', (e) => {
                        const item = e.target.closest('[data-suite-command-item]:not([data-disabled="true"])');
                        if (item && root.contains(item)) {
                            highlightItem(item);
                        }
                    });

                    // Initial state
                    filterItems('');
                });

                // CommandDialog
                document.querySelectorAll('[data-suite-command-dialog]').forEach(dialog => {
                    if (this._initialized.has(dialog)) return;
                    this._initialized.add(dialog);

                    const id = dialog.getAttribute('data-suite-command-dialog');
                    const overlay = dialog.querySelector(`[data-suite-command-dialog-overlay="${id}"]`);

                    function openDialog() {
                        dialog.style.display = '';
                        dialog.setAttribute('data-state', 'open');
                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        const input = dialog.querySelector('[data-suite-command-input]');
                        if (input) requestAnimationFrame(() => input.focus());
                    }

                    function closeDialog() {
                        dialog.setAttribute('data-state', 'closed');
                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();
                        setTimeout(() => {
                            if (dialog.getAttribute('data-state') === 'closed') {
                                dialog.style.display = 'none';
                            }
                        }, 200);
                    }

                    // Escape to close
                    dialog.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            e.stopPropagation();
                            closeDialog();
                        }
                    });

                    // Click overlay to close
                    if (overlay) {
                        overlay.addEventListener('pointerdown', (e) => {
                            if (e.target === overlay) closeDialog();
                        });
                    }

                    // Store open/close functions for external triggering
                    dialog._suiteOpen = openDialog;
                    dialog._suiteClose = closeDialog;
                });
            }
        },

        // --- Menubar --------------------------------------------------------------
        Menubar: {
            init() {
                const bars = document.querySelectorAll('[data-suite-menubar]');
                bars.forEach(bar => {
                    if (bar._suiteMenubar) return;
                    bar._suiteMenubar = true;

                    const loop = bar.getAttribute('data-loop') !== 'false';
                    const menus = Array.from(bar.querySelectorAll('[data-suite-menubar-menu]'));
                    if (menus.length === 0) return;

                    let openMenuId = null; // Which menu is currently open
                    let cleanups = {}; // Per-menu cleanup functions

                    // Get all triggers in DOM order
                    function getTriggers() {
                        return Array.from(bar.querySelectorAll('[data-suite-menubar-trigger]'))
                            .filter(t => !t.hasAttribute('data-disabled'));
                    }

                    // Roving tabindex: only active trigger gets tabindex=0
                    function setRovingFocus(trigger) {
                        getTriggers().forEach(t => t.setAttribute('tabindex', '-1'));
                        trigger.setAttribute('tabindex', '0');
                        trigger.focus({ preventScroll: true });
                    }

                    // Initialize roving tabindex — first trigger gets 0
                    const allTriggers = getTriggers();
                    if (allTriggers.length > 0) {
                        allTriggers.forEach(t => t.setAttribute('tabindex', '-1'));
                        allTriggers[0].setAttribute('tabindex', '0');
                    }

                    function openMenu(menuId, focusFirst) {
                        if (openMenuId === menuId) return;
                        if (openMenuId) closeMenu(openMenuId);

                        const menuEl = bar.querySelector(`[data-suite-menubar-menu="${menuId}"]`);
                        if (!menuEl) return;
                        const trigger = menuEl.querySelector('[data-suite-menubar-trigger]');
                        const content = menuEl.querySelector('[data-suite-menubar-content]');
                        if (!trigger || !content) return;

                        openMenuId = menuId;
                        const side = content.getAttribute('data-side-preference') || 'bottom';
                        const sideOffset = parseInt(content.getAttribute('data-side-offset') || '4', 10);
                        const align = content.getAttribute('data-align-preference') || 'start';

                        content.style.display = '';
                        content.setAttribute('data-state', 'open');
                        trigger.setAttribute('data-state', 'open');
                        trigger.setAttribute('aria-expanded', 'true');

                        const cleanupFloat = Suite.Floating.position(trigger, content, {
                            side, sideOffset, align
                        });

                        Suite.ScrollLock.lock();
                        Suite.FocusGuards.install();

                        const cleanupMenu = Suite.Menu.activate(content, {
                            onClose: () => closeMenu(menuId),
                            onNavigateLeft: () => navigateMenubar(menuId, -1),
                            onNavigateRight: () => navigateMenubar(menuId, 1),
                        });

                        const cleanupDismiss = Suite.DismissLayer.activate(content, {
                            disableOutsidePointerEvents: true,
                            onDismiss: () => closeMenu(menuId),
                            excludeElements: () => getTriggers(),
                        });

                        cleanups[menuId] = { cleanupFloat, cleanupMenu, cleanupDismiss };

                        if (focusFirst) {
                            requestAnimationFrame(() => {
                                const items = Array.from(content.querySelectorAll(
                                    '[data-suite-menu-item], [data-suite-menu-checkbox-item], [data-suite-menu-radio-item], [data-suite-menu-sub-trigger]'
                                )).filter(el => !el.hasAttribute('data-disabled') && !el.closest('[data-suite-menu-sub-content]'));
                                if (items.length > 0) {
                                    items[0].setAttribute('data-highlighted', '');
                                    items[0].focus({ preventScroll: true });
                                }
                            });
                        }
                    }

                    function closeMenu(menuId) {
                        if (openMenuId !== menuId) return;
                        openMenuId = null;

                        const menuEl = bar.querySelector(`[data-suite-menubar-menu="${menuId}"]`);
                        if (!menuEl) return;
                        const trigger = menuEl.querySelector('[data-suite-menubar-trigger]');
                        const content = menuEl.querySelector('[data-suite-menubar-content]');

                        if (cleanups[menuId]) {
                            const c = cleanups[menuId];
                            if (c.cleanupMenu) c.cleanupMenu();
                            if (c.cleanupDismiss) c.cleanupDismiss();
                            if (c.cleanupFloat) c.cleanupFloat();
                            delete cleanups[menuId];
                        }

                        if (content) {
                            content.setAttribute('data-state', 'closed');
                            content.querySelectorAll('[data-highlighted]').forEach(el => el.removeAttribute('data-highlighted'));
                            const hide = () => { if (content.getAttribute('data-state') === 'closed') content.style.display = 'none'; };
                            content.addEventListener('animationend', hide, { once: true });
                            setTimeout(hide, 250);
                        }
                        if (trigger) {
                            trigger.setAttribute('data-state', 'closed');
                            trigger.setAttribute('aria-expanded', 'false');
                        }

                        Suite.ScrollLock.unlock();
                        Suite.FocusGuards.uninstall();
                    }

                    // Navigate between menus from within content (ArrowLeft/Right)
                    function navigateMenubar(currentMenuId, direction) {
                        const triggers = getTriggers();
                        const currentTrigger = bar.querySelector(`[data-suite-menubar-menu="${currentMenuId}"] [data-suite-menubar-trigger]`);
                        let idx = triggers.indexOf(currentTrigger);
                        if (idx < 0) return;

                        closeMenu(currentMenuId);

                        let nextIdx = idx + direction;
                        if (loop) {
                            nextIdx = (nextIdx + triggers.length) % triggers.length;
                        } else {
                            nextIdx = Math.max(0, Math.min(triggers.length - 1, nextIdx));
                        }

                        const nextTrigger = triggers[nextIdx];
                        setRovingFocus(nextTrigger);

                        // Open the next menu and focus first item
                        const nextMenuEl = nextTrigger.closest('[data-suite-menubar-menu]');
                        if (nextMenuEl) {
                            const nextMenuId = nextMenuEl.getAttribute('data-suite-menubar-menu');
                            openMenu(nextMenuId, true);
                        }
                    }

                    // Set up trigger event handlers
                    menus.forEach(menuEl => {
                        const menuId = menuEl.getAttribute('data-suite-menubar-menu');
                        const trigger = menuEl.querySelector('[data-suite-menubar-trigger]');
                        if (!trigger) return;

                        // Click to toggle
                        trigger.addEventListener('pointerdown', (e) => {
                            if (e.button !== 0) return;
                            if (e.ctrlKey && navigator.platform.match(/Mac/)) return;
                            e.preventDefault();
                            setRovingFocus(trigger);
                            if (openMenuId === menuId) {
                                closeMenu(menuId);
                            } else {
                                openMenu(menuId, false);
                            }
                        });

                        // Pointer-enter rapid switching
                        trigger.addEventListener('pointerenter', () => {
                            if (openMenuId && openMenuId !== menuId) {
                                closeMenu(openMenuId);
                                setRovingFocus(trigger);
                                openMenu(menuId, false);
                            }
                        });

                        // Keyboard on trigger
                        trigger.addEventListener('keydown', (e) => {
                            const triggers = getTriggers();
                            const idx = triggers.indexOf(trigger);

                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                openMenu(menuId, true);
                            } else if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                if (openMenuId === menuId) {
                                    closeMenu(menuId);
                                } else {
                                    openMenu(menuId, true);
                                }
                            } else if (e.key === 'ArrowRight') {
                                e.preventDefault();
                                let next = idx + 1;
                                if (loop) next = next % triggers.length;
                                else next = Math.min(next, triggers.length - 1);
                                setRovingFocus(triggers[next]);
                            } else if (e.key === 'ArrowLeft') {
                                e.preventDefault();
                                let prev = idx - 1;
                                if (loop) prev = (prev + triggers.length) % triggers.length;
                                else prev = Math.max(prev, 0);
                                setRovingFocus(triggers[prev]);
                            } else if (e.key === 'Home') {
                                e.preventDefault();
                                setRovingFocus(triggers[0]);
                            } else if (e.key === 'End') {
                                e.preventDefault();
                                setRovingFocus(triggers[triggers.length - 1]);
                            }
                        });
                    });
                });
            }
        },

        // --- NavigationMenu -------------------------------------------------------
        // Inline content panels (no viewport) — matches shadcn viewport=false.
        // Content panels render as absolute-positioned dropdowns under their triggers.
        NavigationMenu: {
            init() {
                const roots = document.querySelectorAll('[data-suite-nav-menu]');
                roots.forEach(root => {
                    // Singleton guard — but expose close() for SPA state reset
                    if (root._suiteNavMenu) {
                        // Already initialized — force-close to reset state after SPA navigation
                        if (root._suiteNavMenuClose) root._suiteNavMenuClose();
                        return;
                    }
                    root._suiteNavMenu = true;

                    const delayDuration = parseInt(root.getAttribute('data-delay-duration') || '200', 10);
                    const skipDelayDuration = parseInt(root.getAttribute('data-skip-delay-duration') || '300', 10);

                    const items = root.querySelectorAll('[data-suite-nav-menu-item]');
                    const indicator = root.querySelector('[data-suite-nav-menu-indicator]');

                    let activeValue = '';
                    let previousValue = '';
                    let openTimer = null;
                    let closeTimer = null;
                    let skipDelayTimer = null;
                    let isSkipDelay = false;
                    let wasEscapeClose = false;

                    function getItemByValue(value) {
                        return root.querySelector(`[data-suite-nav-menu-item][data-value="${value}"]`);
                    }

                    function open(value) {
                        if (activeValue === value) return;
                        previousValue = activeValue;
                        activeValue = value;

                        // Update all items — show active content, hide others
                        items.forEach(item => {
                            const v = item.getAttribute('data-value');
                            const trigger = item.querySelector('[data-suite-nav-menu-trigger]');
                            const content = item.querySelector('[data-suite-nav-menu-content]');
                            if (v === value) {
                                if (trigger) {
                                    trigger.setAttribute('data-state', 'open');
                                    trigger.setAttribute('aria-expanded', 'true');
                                }
                                if (content) {
                                    content.style.display = '';
                                    content.setAttribute('data-state', 'open');
                                    // Set motion attribute for animation direction
                                    const prevItem = previousValue ? getItemByValue(previousValue) : null;
                                    if (prevItem) {
                                        const allItems = Array.from(items);
                                        const prevIdx = allItems.indexOf(prevItem);
                                        const curIdx = allItems.indexOf(item);
                                        content.setAttribute('data-motion', curIdx > prevIdx ? 'from-end' : 'from-start');
                                    } else {
                                        content.removeAttribute('data-motion');
                                    }
                                }
                            } else {
                                if (trigger) {
                                    trigger.setAttribute('data-state', 'closed');
                                    trigger.setAttribute('aria-expanded', 'false');
                                }
                                if (content) {
                                    // Set exit motion
                                    if (v === previousValue) {
                                        const allItems = Array.from(items);
                                        const prevIdx = allItems.indexOf(item);
                                        const curItem = getItemByValue(value);
                                        const curIdx = curItem ? allItems.indexOf(curItem) : -1;
                                        content.setAttribute('data-motion', curIdx > prevIdx ? 'to-start' : 'to-end');
                                    }
                                    content.setAttribute('data-state', 'closed');
                                    const hideContent = content;
                                    const hide = () => { if (hideContent.getAttribute('data-state') === 'closed') hideContent.style.display = 'none'; };
                                    hideContent.addEventListener('animationend', hide, { once: true });
                                    setTimeout(hide, 300);
                                }
                            }
                        });

                        // Update indicator
                        if (indicator) {
                            const activeItem = getItemByValue(value);
                            const trigger = activeItem ? activeItem.querySelector('[data-suite-nav-menu-trigger]') : null;
                            if (trigger) {
                                indicator.setAttribute('data-state', 'visible');
                                indicator.style.display = '';
                                // Position indicator under active trigger
                                const list = root.querySelector('[data-suite-nav-menu-list]');
                                if (list) {
                                    const listRect = list.getBoundingClientRect();
                                    const triggerRect = trigger.getBoundingClientRect();
                                    indicator.style.position = 'absolute';
                                    indicator.style.left = (triggerRect.left - listRect.left) + 'px';
                                    indicator.style.width = triggerRect.width + 'px';
                                    indicator.style.transition = 'left 0.2s ease, width 0.2s ease';
                                }
                            }
                        }
                    }

                    function close() {
                        if (!activeValue) return;
                        previousValue = activeValue;
                        activeValue = '';

                        items.forEach(item => {
                            const trigger = item.querySelector('[data-suite-nav-menu-trigger]');
                            const content = item.querySelector('[data-suite-nav-menu-content]');
                            if (trigger) {
                                trigger.setAttribute('data-state', 'closed');
                                trigger.setAttribute('aria-expanded', 'false');
                            }
                            if (content) {
                                content.setAttribute('data-state', 'closed');
                                const hideContent = content;
                                const hide = () => { if (hideContent.getAttribute('data-state') === 'closed') hideContent.style.display = 'none'; };
                                hideContent.addEventListener('animationend', hide, { once: true });
                                setTimeout(hide, 300);
                            }
                        });

                        if (indicator) {
                            indicator.setAttribute('data-state', 'hidden');
                            setTimeout(() => {
                                if (indicator.getAttribute('data-state') === 'hidden') indicator.style.display = 'none';
                            }, 200);
                        }

                        // Start skip delay timer
                        clearTimeout(skipDelayTimer);
                        isSkipDelay = true;
                        skipDelayTimer = setTimeout(() => { isSkipDelay = false; }, skipDelayDuration);
                    }

                    // Expose close() for SPA state reset
                    root._suiteNavMenuClose = close;

                    // Set up event handlers on each item
                    items.forEach(item => {
                        const value = item.getAttribute('data-value');
                        const trigger = item.querySelector('[data-suite-nav-menu-trigger]');
                        const content = item.querySelector('[data-suite-nav-menu-content]');

                        if (!trigger) return;
                        // Only items with content have hover/click behavior
                        if (!content) return;

                        // Hover on trigger — delayed open
                        trigger.addEventListener('pointerenter', (e) => {
                            if (e.pointerType === 'touch') return;
                            if (wasEscapeClose) { wasEscapeClose = false; return; }
                            clearTimeout(closeTimer);
                            if (isSkipDelay || activeValue) {
                                // Open immediately (rapid switching or skip delay)
                                open(value);
                            } else {
                                openTimer = setTimeout(() => open(value), delayDuration);
                            }
                        });

                        trigger.addEventListener('pointerleave', (e) => {
                            if (e.pointerType === 'touch') return;
                            clearTimeout(openTimer);
                            closeTimer = setTimeout(close, 150);
                        });

                        // Click for immediate toggle
                        trigger.addEventListener('click', () => {
                            if (activeValue === value) {
                                close();
                            } else {
                                open(value);
                            }
                        });

                        // Keyboard on trigger
                        trigger.addEventListener('keydown', (e) => {
                            if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                open(value);
                                // Focus first tabbable in content
                                if (content) {
                                    requestAnimationFrame(() => {
                                        const first = content.querySelector('a, button, [tabindex="0"]');
                                        if (first) first.focus({ preventScroll: true });
                                    });
                                }
                            }
                        });

                        // Content hover — keep open
                        if (content) {
                            content.addEventListener('pointerenter', (e) => {
                                if (e.pointerType === 'touch') return;
                                clearTimeout(closeTimer);
                            });
                            content.addEventListener('pointerleave', (e) => {
                                if (e.pointerType === 'touch') return;
                                closeTimer = setTimeout(close, 150);
                            });
                        }
                    });

                    // Escape to close
                    root.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && activeValue) {
                            e.preventDefault();
                            e.stopPropagation();
                            wasEscapeClose = true;
                            const activeItem = getItemByValue(activeValue);
                            const trigger = activeItem ? activeItem.querySelector('[data-suite-nav-menu-trigger]') : null;
                            close();
                            if (trigger) trigger.focus({ preventScroll: true });
                        }
                    });

                    // Click outside to close
                    document.addEventListener('pointerdown', (e) => {
                        if (activeValue && !root.contains(e.target)) {
                            close();
                        }
                    });
                });
            }
        },

        // =====================================================================
        // Toast — Sonner-style notification system
        // =====================================================================
        Toast: {
            _container: null,
            _toasts: [],
            _counter: 0,
            _defaults: {
                duration: 4000,
                position: 'bottom-right',
                visibleToasts: 3,
                gap: 14,
                swipeThreshold: 45
            },

            init() {
                // Find or create toaster container
                const el = document.querySelector('[data-suite-toaster]');
                if (el && !el._suiteToastInit) {
                    el._suiteToastInit = true;
                    this._container = el;
                    // Read config from data attributes
                    if (el.dataset.position) this._defaults.position = el.dataset.position;
                    if (el.dataset.duration) this._defaults.duration = parseInt(el.dataset.duration, 10);
                    if (el.dataset.visibleToasts) this._defaults.visibleToasts = parseInt(el.dataset.visibleToasts, 10);
                }
            },

            _ensureContainer() {
                if (this._container) return;
                // Auto-create container if not found in DOM
                const c = document.createElement('section');
                c.setAttribute('aria-label', 'Notifications');
                c.setAttribute('data-suite-toaster', '');
                c.setAttribute('tabindex', '-1');
                document.body.appendChild(c);
                this._container = c;
                c._suiteToastInit = true;
            },

            _getPositionClasses(pos) {
                const map = {
                    'top-left':      { y: 'top',    x: 'left',   style: 'top: var(--offset-y, 24px); left: var(--offset-x, 24px);' },
                    'top-center':    { y: 'top',    x: 'center', style: 'top: var(--offset-y, 24px); left: 50%; transform: translateX(-50%);' },
                    'top-right':     { y: 'top',    x: 'right',  style: 'top: var(--offset-y, 24px); right: var(--offset-x, 24px);' },
                    'bottom-left':   { y: 'bottom', x: 'left',   style: 'bottom: var(--offset-y, 24px); left: var(--offset-x, 24px);' },
                    'bottom-center': { y: 'bottom', x: 'center', style: 'bottom: var(--offset-y, 24px); left: 50%; transform: translateX(-50%);' },
                    'bottom-right':  { y: 'bottom', x: 'right',  style: 'bottom: var(--offset-y, 24px); right: var(--offset-x, 24px);' }
                };
                return map[pos] || map['bottom-right'];
            },

            _iconSvg(type) {
                const icons = {
                    success: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
                    error: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
                    warning: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
                    info: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>'
                };
                return icons[type] || '';
            },

            _typeColors(type) {
                const colors = {
                    default: '',
                    success: 'border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-950 text-green-800 dark:text-green-200',
                    error: 'border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-950 text-red-800 dark:text-red-200',
                    warning: 'border-amber-200 dark:border-amber-800 bg-amber-50 dark:bg-amber-950 text-amber-800 dark:text-amber-200',
                    info: 'border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-950 text-blue-800 dark:text-blue-200'
                };
                return colors[type] || colors['default'];
            },

            _createToastEl(toast) {
                const li = document.createElement('li');
                li.setAttribute('role', 'status');
                li.setAttribute('aria-live', toast.type === 'error' ? 'assertive' : 'polite');
                li.setAttribute('aria-atomic', 'true');
                li.setAttribute('data-suite-toast', toast.id);
                li.setAttribute('data-type', toast.type);
                li.setAttribute('data-mounted', 'false');
                li.setAttribute('data-dismissed', 'false');
                li.setAttribute('tabindex', '0');

                const typeColors = this._typeColors(toast.type);
                const baseClasses = 'pointer-events-auto relative flex items-start gap-3 w-[356px] max-w-[calc(100vw-48px)] rounded-md border p-4 shadow-lg transition-all duration-300';
                const defaultColors = 'border-warm-200 dark:border-warm-700 bg-warm-50 dark:bg-warm-900 text-warm-800 dark:text-warm-300';
                li.className = baseClasses + ' ' + (typeColors || defaultColors);

                // Icon
                const icon = this._iconSvg(toast.type);
                let iconHtml = '';
                if (icon) {
                    const iconColorMap = {
                        success: 'text-green-600 dark:text-green-400',
                        error: 'text-red-600 dark:text-red-400',
                        warning: 'text-amber-600 dark:text-amber-400',
                        info: 'text-blue-600 dark:text-blue-400'
                    };
                    iconHtml = '<div class="flex-shrink-0 ' + (iconColorMap[toast.type] || '') + '">' + icon + '</div>';
                }

                // Content
                let contentHtml = '<div class="flex-1 min-w-0">';
                if (toast.title) {
                    contentHtml += '<div class="text-sm font-semibold">' + this._escapeHtml(toast.title) + '</div>';
                }
                if (toast.description) {
                    contentHtml += '<div class="text-sm opacity-80 mt-0.5">' + this._escapeHtml(toast.description) + '</div>';
                }
                contentHtml += '</div>';

                // Close button
                let closeHtml = '';
                if (toast.dismissible !== false) {
                    closeHtml = '<button type="button" aria-label="Dismiss" class="flex-shrink-0 rounded-md p-0.5 opacity-50 hover:opacity-100 transition-opacity cursor-pointer focus:outline-none focus-visible:ring-2 focus-visible:ring-accent-600">' +
                        '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>' +
                        '</button>';
                }

                // Action button
                let actionHtml = '';
                if (toast.action) {
                    actionHtml = '<button type="button" data-suite-toast-action class="flex-shrink-0 text-sm font-medium px-3 py-1 rounded-md bg-accent-600 text-white hover:bg-accent-700 transition-colors cursor-pointer">' +
                        this._escapeHtml(toast.action.label) + '</button>';
                }

                li.innerHTML = iconHtml + contentHtml + actionHtml + closeHtml;

                // Wire close button
                const closeBtn = li.querySelector('button[aria-label="Dismiss"]');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.dismiss(toast.id));
                }

                // Wire action button
                const actionBtn = li.querySelector('[data-suite-toast-action]');
                if (actionBtn && toast.action && toast.action.onClick) {
                    actionBtn.addEventListener('click', (e) => {
                        toast.action.onClick(e);
                        this.dismiss(toast.id);
                    });
                }

                // Swipe to dismiss
                this._setupSwipe(li, toast);

                return li;
            },

            _escapeHtml(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            },

            _setupSwipe(el, toast) {
                if (toast.dismissible === false) return;

                let startX = 0, startY = 0, startTime = 0, swiping = false;

                el.addEventListener('pointerdown', (e) => {
                    if (e.button !== 0) return;
                    startX = e.clientX;
                    startY = e.clientY;
                    startTime = Date.now();
                    swiping = true;
                    el.setPointerCapture(e.pointerId);
                    el.style.transition = 'none';
                    el.setAttribute('data-swiping', 'true');
                });

                el.addEventListener('pointermove', (e) => {
                    if (!swiping) return;
                    const dx = e.clientX - startX;
                    // Only allow right swipe (positive direction)
                    if (dx > 0) {
                        el.style.transform = 'translateX(' + dx + 'px)';
                        el.style.opacity = Math.max(0, 1 - dx / 150);
                    }
                });

                el.addEventListener('pointerup', (e) => {
                    if (!swiping) return;
                    swiping = false;
                    el.removeAttribute('data-swiping');
                    el.style.transition = '';

                    const dx = e.clientX - startX;
                    const timeTaken = Date.now() - startTime;
                    const velocity = Math.abs(dx) / timeTaken;

                    if (dx >= this._defaults.swipeThreshold || velocity > 0.11) {
                        // Swipe out
                        el.style.transition = 'transform 200ms ease-out, opacity 200ms ease-out';
                        el.style.transform = 'translateX(100%)';
                        el.style.opacity = '0';
                        setTimeout(() => this.dismiss(toast.id), 200);
                    } else {
                        // Snap back
                        el.style.transform = '';
                        el.style.opacity = '';
                    }
                });
            },

            _updatePositions() {
                const visible = this._toasts.filter(t => !t.dismissed);
                const gap = this._defaults.gap;

                visible.forEach((toast, index) => {
                    const el = toast.el;
                    if (!el) return;

                    const isVisible = index < this._defaults.visibleToasts;
                    el.style.zIndex = String(visible.length - index);

                    if (isVisible) {
                        el.style.opacity = '';
                        el.style.pointerEvents = '';
                        // Stack offset: each toast offsets by its predecessors' heights + gap
                        let offset = 0;
                        for (let i = 0; i < index; i++) {
                            offset += (visible[i].height || 0) + gap;
                        }
                        const pos = this._getPositionClasses(this._defaults.position);
                        const dir = pos.y === 'bottom' ? -1 : 1;
                        el.style.transform = 'translateY(' + (dir * offset) + 'px)';
                    } else {
                        // Hidden behind stack
                        el.style.opacity = '0';
                        el.style.pointerEvents = 'none';
                        el.style.transform = 'translateY(0) scale(0.95)';
                    }
                });
            },

            _startTimer(toast) {
                if (toast.duration === Infinity) return;
                const dur = toast.duration || this._defaults.duration;
                toast._remaining = dur;
                toast._timerStart = Date.now();
                toast._timer = setTimeout(() => this.dismiss(toast.id), dur);
            },

            _pauseTimer(toast) {
                if (toast._timer) {
                    clearTimeout(toast._timer);
                    toast._remaining -= (Date.now() - toast._timerStart);
                }
            },

            _resumeTimer(toast) {
                if (toast._remaining > 0 && toast.duration !== Infinity) {
                    toast._timerStart = Date.now();
                    toast._timer = setTimeout(() => this.dismiss(toast.id), toast._remaining);
                }
            },

            /**
             * Show a toast notification.
             * @param {string} title - Toast title
             * @param {Object} opts - Options: type, description, duration, action, dismissible
             * @returns {number} Toast ID
             */
            show(title, opts = {}) {
                this._ensureContainer();

                const id = ++this._counter;
                const toast = {
                    id,
                    title,
                    description: opts.description || '',
                    type: opts.type || 'default',
                    duration: opts.duration,
                    dismissible: opts.dismissible,
                    action: opts.action,
                    dismissed: false,
                    el: null,
                    height: 0,
                    _timer: null,
                    _remaining: 0,
                    _timerStart: 0
                };

                // Create DOM element
                toast.el = this._createToastEl(toast);

                // Find or create the list container for this position
                let list = this._container.querySelector('ol[data-suite-toast-list]');
                if (!list) {
                    list = document.createElement('ol');
                    list.setAttribute('data-suite-toast-list', '');
                    const pos = this._getPositionClasses(this._defaults.position);
                    list.style.cssText = 'position: fixed; ' + pos.style + ' z-index: 999999; list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; pointer-events: none;';
                    this._container.appendChild(list);
                }

                // Prepend (newest on top for bottom, append for top)
                const posInfo = this._getPositionClasses(this._defaults.position);
                if (posInfo.y === 'bottom') {
                    list.prepend(toast.el);
                } else {
                    list.appendChild(toast.el);
                }

                // Add to tracking array (newest first)
                this._toasts.unshift(toast);

                // Measure height after render
                requestAnimationFrame(() => {
                    toast.height = toast.el.getBoundingClientRect().height;
                    toast.el.setAttribute('data-mounted', 'true');
                    this._updatePositions();
                });

                // Pause timer on hover
                toast.el.addEventListener('mouseenter', () => this._pauseTimer(toast));
                toast.el.addEventListener('mouseleave', () => this._resumeTimer(toast));

                // Start auto-dismiss timer
                this._startTimer(toast);

                return id;
            },

            dismiss(id) {
                const idx = this._toasts.findIndex(t => t.id === id);
                if (idx === -1) return;

                const toast = this._toasts[idx];
                if (toast.dismissed) return;
                toast.dismissed = true;

                if (toast._timer) clearTimeout(toast._timer);

                // Animate out
                if (toast.el) {
                    toast.el.setAttribute('data-dismissed', 'true');
                    toast.el.style.transition = 'transform 300ms ease-out, opacity 300ms ease-out';
                    toast.el.style.opacity = '0';
                    toast.el.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.el && toast.el.parentNode) {
                            toast.el.parentNode.removeChild(toast.el);
                        }
                        this._toasts = this._toasts.filter(t => t.id !== id);
                        this._updatePositions();
                    }, 300);
                }

                this._updatePositions();
            },

            dismissAll() {
                [...this._toasts].forEach(t => this.dismiss(t.id));
            },

            // Convenience methods
            success(title, opts = {}) { return this.show(title, { ...opts, type: 'success' }); },
            error(title, opts = {})   { return this.show(title, { ...opts, type: 'error' }); },
            warning(title, opts = {}) { return this.show(title, { ...opts, type: 'warning' }); },
            info(title, opts = {})    { return this.show(title, { ...opts, type: 'info' }); }
        },

        // --- Slider ---------------------------------------------------------------
        Slider: {
            init() {
                document.querySelectorAll('[data-suite-slider]').forEach(root => {
                    if (root._suiteSlider) return;
                    root._suiteSlider = true;

                    const thumb = root.querySelector('[data-suite-slider-thumb]');
                    const track = root.querySelector('[data-suite-slider-track]');
                    const range = root.querySelector('[data-suite-slider-range]');
                    if (!thumb || !track || !range) return;

                    const isVertical = root.getAttribute('data-orientation') === 'vertical';
                    const min = parseFloat(root.getAttribute('data-min') || '0');
                    const max = parseFloat(root.getAttribute('data-max') || '100');
                    const step = parseFloat(root.getAttribute('data-step') || '1');

                    const isDisabled = () => root.hasAttribute('data-disabled') || root.hasAttribute('aria-disabled');

                    const snapToStep = (val) => {
                        const stepped = Math.round((val - min) / step) * step + min;
                        // Round to avoid floating point issues
                        const decimals = (step.toString().split('.')[1] || '').length;
                        return parseFloat(Math.min(max, Math.max(min, stepped)).toFixed(decimals));
                    };

                    const updateVisuals = (value) => {
                        const pct = max > min ? ((value - min) / (max - min)) * 100 : 0;
                        root.setAttribute('data-value', String(value));
                        thumb.setAttribute('aria-valuenow', String(value));

                        if (isVertical) {
                            range.style.bottom = '0';
                            range.style.height = pct + '%';
                            thumb.style.bottom = pct + '%';
                            thumb.style.left = '50%';
                            thumb.style.transform = 'translate(-50%, 50%)';
                            thumb.style.position = 'absolute';
                            thumb.style.top = '';
                        } else {
                            range.style.left = '0';
                            range.style.width = pct + '%';
                            thumb.style.left = pct + '%';
                            thumb.style.top = '50%';
                            thumb.style.transform = 'translate(-50%, -50%)';
                            thumb.style.position = 'absolute';
                            thumb.style.bottom = '';
                        }
                    };

                    const setValue = (newVal) => {
                        const snapped = snapToStep(newVal);
                        const current = parseFloat(root.getAttribute('data-value') || '0');
                        if (snapped === current) return;
                        updateVisuals(snapped);
                        root.dispatchEvent(new CustomEvent('suite:slider:change', {
                            detail: { value: snapped },
                            bubbles: true
                        }));
                    };

                    const getValueFromPointer = (e) => {
                        const rect = track.getBoundingClientRect();
                        let pct;
                        if (isVertical) {
                            pct = 1 - ((e.clientY - rect.top) / rect.height);
                        } else {
                            pct = (e.clientX - rect.left) / rect.width;
                        }
                        pct = Math.min(1, Math.max(0, pct));
                        return min + pct * (max - min);
                    };

                    // Pointer drag via Pointer Capture API
                    let dragging = false;

                    root.addEventListener('pointerdown', (e) => {
                        if (isDisabled()) return;
                        e.preventDefault();
                        dragging = true;
                        root.setPointerCapture(e.pointerId);
                        setValue(getValueFromPointer(e));
                        thumb.focus();
                    });

                    root.addEventListener('pointermove', (e) => {
                        if (!dragging) return;
                        if (!root.hasPointerCapture(e.pointerId)) return;
                        setValue(getValueFromPointer(e));
                    });

                    root.addEventListener('pointerup', (e) => {
                        if (!dragging) return;
                        dragging = false;
                        root.releasePointerCapture(e.pointerId);
                    });

                    // Keyboard navigation on thumb
                    thumb.addEventListener('keydown', (e) => {
                        if (isDisabled()) return;
                        const current = parseFloat(root.getAttribute('data-value') || '0');
                        let newVal = current;
                        const bigStep = step * 10;

                        switch (e.key) {
                            case 'ArrowRight':
                            case 'ArrowUp':
                                newVal = current + (e.shiftKey ? bigStep : step);
                                break;
                            case 'ArrowLeft':
                            case 'ArrowDown':
                                newVal = current - (e.shiftKey ? bigStep : step);
                                break;
                            case 'PageUp':
                                newVal = current + bigStep;
                                break;
                            case 'PageDown':
                                newVal = current - bigStep;
                                break;
                            case 'Home':
                                newVal = min;
                                break;
                            case 'End':
                                newVal = max;
                                break;
                            default:
                                return; // Don't prevent default for other keys
                        }
                        e.preventDefault();
                        setValue(newVal);
                    });
                });
            }
        },

        // --- Calendar -------------------------------------------------------------
        Calendar: {
            _initialized: new WeakSet(),

            init() {
                document.querySelectorAll('[data-suite-calendar]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);
                    this._setup(root);
                });
                document.querySelectorAll('[data-suite-datepicker]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);
                    this._setupDatePicker(root);
                });
            },

            _setup(root) {
                const id = root.getAttribute('data-suite-calendar');
                const mode = root.getAttribute('data-suite-calendar-mode') || 'single';
                let month = parseInt(root.getAttribute('data-suite-calendar-month')) || (new Date().getMonth() + 1);
                let year = parseInt(root.getAttribute('data-suite-calendar-year')) || new Date().getFullYear();
                const showOutside = root.getAttribute('data-suite-calendar-show-outside') !== 'false';
                const fixedWeeks = root.getAttribute('data-suite-calendar-fixed-weeks') === 'true';
                const monthsCount = parseInt(root.getAttribute('data-suite-calendar-months-count')) || 1;

                // Parse selected dates
                const selectedStr = root.getAttribute('data-suite-calendar-selected') || '';
                let selected = selectedStr ? selectedStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // Parse disabled dates
                const disabledStr = root.getAttribute('data-suite-calendar-disabled') || '';
                const disabled = disabledStr ? disabledStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // State
                const state = { month, year, selected, disabled, mode, showOutside, fixedWeeks, monthsCount, focusedDate: null };

                // Prev/Next buttons
                const prevBtn = root.querySelector(`[data-suite-calendar-prev="${id}"]`);
                const nextBtn = root.querySelector(`[data-suite-calendar-next="${id}"]`);

                if (prevBtn) {
                    prevBtn.addEventListener('click', () => {
                        state.month--;
                        if (state.month < 1) { state.month = 12; state.year--; }
                        this._render(root, id, state);
                    });
                }
                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        state.month++;
                        if (state.month > 12) { state.month = 1; state.year++; }
                        this._render(root, id, state);
                    });
                }

                // Apply initial selection styling
                this._applySelection(root, state);

                // Set initial focus target (selected or today)
                this._setInitialFocus(root, state);

                // Keyboard navigation on the grid
                root.addEventListener('keydown', (e) => this._handleKeyDown(e, root, id, state));

                // Click on day buttons
                root.addEventListener('click', (e) => {
                    const dayBtn = e.target.closest('[data-suite-calendar-day-btn]');
                    if (!dayBtn) return;
                    const dateStr = dayBtn.getAttribute('data-suite-calendar-day-btn');
                    if (disabled.includes(dateStr)) return;
                    this._selectDate(root, id, state, dateStr);
                });
            },

            _setInitialFocus(root, state) {
                // Set tabindex=0 on the first selected date, or today, or first available day
                const allBtns = root.querySelectorAll('[data-suite-calendar-day-btn]');
                let target = null;

                // Priority: selected > today > first non-outside
                if (state.selected.length > 0) {
                    target = root.querySelector(`[data-suite-calendar-day-btn="${state.selected[0]}"]`);
                }
                if (!target) {
                    const todayCell = root.querySelector('[data-today="true"] [data-suite-calendar-day-btn]');
                    if (todayCell) target = todayCell;
                }
                if (!target && allBtns.length > 0) {
                    for (const btn of allBtns) {
                        const cell = btn.closest('td');
                        if (cell && !cell.hasAttribute('data-outside')) {
                            target = btn;
                            break;
                        }
                    }
                }

                if (target) {
                    target.setAttribute('tabindex', '0');
                    state.focusedDate = target.getAttribute('data-suite-calendar-day-btn');
                }
            },

            _selectDate(root, id, state, dateStr) {
                if (state.mode === 'single') {
                    // Toggle or replace
                    if (state.selected.length === 1 && state.selected[0] === dateStr) {
                        state.selected = [];
                    } else {
                        state.selected = [dateStr];
                    }
                } else if (state.mode === 'multiple') {
                    const idx = state.selected.indexOf(dateStr);
                    if (idx >= 0) {
                        state.selected.splice(idx, 1);
                    } else {
                        state.selected.push(dateStr);
                    }
                } else if (state.mode === 'range') {
                    if (state.selected.length === 0 || state.selected.length === 2) {
                        // Start new range
                        state.selected = [dateStr];
                    } else if (state.selected.length === 1) {
                        // Complete range
                        const from = state.selected[0];
                        if (dateStr < from) {
                            state.selected = [dateStr, from];
                        } else {
                            state.selected.push(dateStr);
                        }
                    }
                }

                // Update the root data attribute
                root.setAttribute('data-suite-calendar-selected', state.selected.join(','));

                this._applySelection(root, state);

                // Fire custom event for integration
                root.dispatchEvent(new CustomEvent('suite:calendar:select', {
                    bubbles: true,
                    detail: { selected: [...state.selected], mode: state.mode }
                }));

                // If inside a datepicker, update the trigger display
                const datepicker = root.closest('[data-suite-datepicker]');
                if (datepicker) {
                    this._updateDatePickerDisplay(datepicker, state);
                    // Auto-close on single select
                    if (state.mode === 'single' || (state.mode === 'range' && state.selected.length === 2)) {
                        setTimeout(() => this._closeDatePicker(datepicker), 150);
                    }
                }
            },

            _applySelection(root, state) {
                const allBtns = root.querySelectorAll('[data-suite-calendar-day-btn]');
                allBtns.forEach(btn => {
                    const dateStr = btn.getAttribute('data-suite-calendar-day-btn');
                    const cell = btn.closest('td');
                    const isDisabled = state.disabled.includes(dateStr);

                    // Reset
                    btn.removeAttribute('data-selected');
                    btn.removeAttribute('aria-selected');
                    if (cell) {
                        cell.removeAttribute('data-selected');
                        cell.removeAttribute('data-range-start');
                        cell.removeAttribute('data-range-middle');
                        cell.removeAttribute('data-range-end');
                    }

                    if (isDisabled) {
                        btn.setAttribute('aria-disabled', 'true');
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                        return;
                    }

                    if (state.mode === 'range' && state.selected.length === 2) {
                        const [from, to] = state.selected;
                        if (dateStr === from) {
                            btn.setAttribute('data-selected', 'true');
                            btn.setAttribute('aria-selected', 'true');
                            if (cell) {
                                cell.setAttribute('data-selected', 'true');
                                cell.setAttribute('data-range-start', 'true');
                            }
                            btn.className = btn.className.replace(/bg-warm-100 dark:bg-warm-900/g, '').replace(/hover:bg-warm-100 dark:hover:bg-warm-900/g, '');
                            btn.style.backgroundColor = '';
                            btn.classList.add('suite-cal-selected');
                        } else if (dateStr === to) {
                            btn.setAttribute('data-selected', 'true');
                            btn.setAttribute('aria-selected', 'true');
                            if (cell) {
                                cell.setAttribute('data-selected', 'true');
                                cell.setAttribute('data-range-end', 'true');
                            }
                            btn.classList.add('suite-cal-selected');
                        } else if (dateStr > from && dateStr < to) {
                            btn.setAttribute('aria-selected', 'true');
                            if (cell) cell.setAttribute('data-range-middle', 'true');
                            btn.classList.add('suite-cal-range-middle');
                        }
                    } else if (state.selected.includes(dateStr)) {
                        btn.setAttribute('data-selected', 'true');
                        btn.setAttribute('aria-selected', 'true');
                        if (cell) cell.setAttribute('data-selected', 'true');
                        btn.classList.add('suite-cal-selected');
                    }
                });
            },

            _handleKeyDown(e, root, id, state) {
                const dayBtn = e.target.closest('[data-suite-calendar-day-btn]');
                if (!dayBtn) return;

                const dateStr = dayBtn.getAttribute('data-suite-calendar-day-btn');
                const currentDate = new Date(dateStr + 'T00:00:00');
                let newDate = null;
                let handled = false;

                switch (e.key) {
                    case 'ArrowLeft':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setMonth(newDate.getMonth() - 1);
                        } else {
                            newDate.setDate(newDate.getDate() - 1);
                        }
                        handled = true;
                        break;
                    case 'ArrowRight':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setMonth(newDate.getMonth() + 1);
                        } else {
                            newDate.setDate(newDate.getDate() + 1);
                        }
                        handled = true;
                        break;
                    case 'ArrowUp':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setFullYear(newDate.getFullYear() - 1);
                        } else {
                            newDate.setDate(newDate.getDate() - 7);
                        }
                        handled = true;
                        break;
                    case 'ArrowDown':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setFullYear(newDate.getFullYear() + 1);
                        } else {
                            newDate.setDate(newDate.getDate() + 7);
                        }
                        handled = true;
                        break;
                    case 'PageUp':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setFullYear(newDate.getFullYear() - 1);
                        } else {
                            newDate.setMonth(newDate.getMonth() - 1);
                        }
                        handled = true;
                        break;
                    case 'PageDown':
                        newDate = new Date(currentDate);
                        if (e.shiftKey) {
                            newDate.setFullYear(newDate.getFullYear() + 1);
                        } else {
                            newDate.setMonth(newDate.getMonth() + 1);
                        }
                        handled = true;
                        break;
                    case 'Home':
                        // Start of week (Monday)
                        newDate = new Date(currentDate);
                        const dow = newDate.getDay(); // 0=Sun
                        const diff = dow === 0 ? -6 : 1 - dow;
                        newDate.setDate(newDate.getDate() + diff);
                        handled = true;
                        break;
                    case 'End':
                        // End of week (Sunday)
                        newDate = new Date(currentDate);
                        const endDow = newDate.getDay(); // 0=Sun
                        const endDiff = endDow === 0 ? 0 : 7 - endDow;
                        newDate.setDate(newDate.getDate() + endDiff);
                        handled = true;
                        break;
                }

                if (handled && newDate) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Format as ISO date string
                    const y = newDate.getFullYear();
                    const m = String(newDate.getMonth() + 1).padStart(2, '0');
                    const d = String(newDate.getDate()).padStart(2, '0');
                    const newDateStr = `${y}-${m}-${d}`;

                    // Check if the new date is in the current grid
                    let targetBtn = root.querySelector(`[data-suite-calendar-day-btn="${newDateStr}"]`);

                    if (!targetBtn) {
                        // Need to navigate months
                        state.month = newDate.getMonth() + 1;
                        state.year = newDate.getFullYear();
                        state.focusedDate = newDateStr;
                        this._render(root, id, state);
                        // After re-render, find and focus
                        targetBtn = root.querySelector(`[data-suite-calendar-day-btn="${newDateStr}"]`);
                    }

                    if (targetBtn) {
                        // Update roving tabindex
                        root.querySelectorAll('[data-suite-calendar-day-btn]').forEach(b => b.setAttribute('tabindex', '-1'));
                        targetBtn.setAttribute('tabindex', '0');
                        targetBtn.focus();
                        state.focusedDate = newDateStr;
                    }
                }
            },

            _render(root, id, state) {
                // Re-render the calendar grid for the current month/year
                const container = root.querySelector('.flex.gap-4');
                if (!container) return;

                const panels = [];
                for (let i = 0; i < state.monthsCount; i++) {
                    let m = state.month + i;
                    let y = state.year;
                    while (m > 12) { m -= 12; y++; }
                    panels.push(this._buildMonthPanel(id, y, m, state));
                }

                container.innerHTML = panels.join('');

                // Update caption
                const caption = root.querySelector(`[data-suite-calendar-caption="${id}"]`);
                if (caption) {
                    const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                    caption.textContent = months[state.month - 1] + ' ' + state.year;
                }

                // Re-apply selection
                this._applySelection(root, state);

                // Re-set focus
                if (state.focusedDate) {
                    const target = root.querySelector(`[data-suite-calendar-day-btn="${state.focusedDate}"]`);
                    if (target) {
                        root.querySelectorAll('[data-suite-calendar-day-btn]').forEach(b => b.setAttribute('tabindex', '-1'));
                        target.setAttribute('tabindex', '0');
                        target.focus();
                    }
                } else {
                    this._setInitialFocus(root, state);
                }

                // Update data attributes
                root.setAttribute('data-suite-calendar-month', String(state.month));
                root.setAttribute('data-suite-calendar-year', String(state.year));
            },

            _buildMonthPanel(calId, year, month, state) {
                const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                const dayAbbrs = ['Mo','Tu','We','Th','Fr','Sa','Su'];
                const dayNames = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];
                const monthLabel = months[month - 1] + ' ' + year;

                const weeks = this._getWeeks(year, month, state.showOutside, state.fixedWeeks);

                let gridHtml = '';
                gridHtml += `<div class="flex items-center justify-center h-7 relative">`;
                gridHtml += `<span class="text-sm font-medium select-none" role="status" aria-live="polite" data-suite-calendar-caption="${calId}">${monthLabel}</span>`;
                gridHtml += `</div>`;

                const multiselect = (state.mode === 'multiple' || state.mode === 'range') ? ' aria-multiselectable="true"' : '';
                gridHtml += `<table role="grid" aria-label="${monthLabel}" class="w-full border-collapse" data-suite-calendar-grid="${calId}" data-suite-calendar-grid-month="${month}" data-suite-calendar-grid-year="${year}"${multiselect}>`;

                // Weekday headers
                gridHtml += `<thead aria-hidden="true"><tr class="flex">`;
                for (let i = 0; i < 7; i++) {
                    gridHtml += `<th scope="col" class="text-warm-600 dark:text-warm-500 rounded-md flex-1 font-normal text-xs select-none w-9 text-center" aria-label="${dayNames[i]}">${dayAbbrs[i]}</th>`;
                }
                gridHtml += `</tr></thead>`;

                // Weeks
                gridHtml += `<tbody class="suite-calendar-weeks">`;
                for (const week of weeks) {
                    gridHtml += `<tr class="flex w-full mt-2">`;
                    for (const day of week) {
                        if (day.outside && !state.showOutside) {
                            gridHtml += `<td class="relative w-9 h-9 p-0 text-center" role="gridcell"></td>`;
                        } else {
                            const outsideAttr = day.outside ? ' data-outside="true"' : '';
                            const todayAttr = day.isToday ? ' data-today="true"' : '';
                            const outsideClass = day.outside ? 'text-warm-400 dark:text-warm-600 opacity-50' : 'text-warm-800 dark:text-warm-300';
                            const todayClass = day.isToday ? ' bg-warm-100 dark:bg-warm-900' : '';
                            gridHtml += `<td class="relative w-9 h-9 p-0 text-center select-none group/day" role="gridcell"${outsideAttr}${todayAttr}>`;
                            gridHtml += `<button type="button" class="relative flex items-center justify-center w-9 h-9 rounded-md text-sm font-normal p-0 border-0 hover:bg-warm-100 dark:hover:bg-warm-900 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent-600 transition-colors ${outsideClass}${todayClass}" tabindex="-1" data-suite-calendar-day-btn="${day.isoDate}" aria-label="${day.label}">${day.dayNum}</button>`;
                            gridHtml += `</td>`;
                        }
                    }
                    gridHtml += `</tr>`;
                }
                gridHtml += `</tbody></table>`;

                return `<div class="flex flex-col gap-4 w-full">${gridHtml}</div>`;
            },

            _getWeeks(year, month, showOutside, fixedWeeks) {
                const firstDay = new Date(year, month - 1, 1);
                const lastDay = new Date(year, month, 0);
                const today = new Date();
                today.setHours(0,0,0,0);

                // Day of week: 0=Sun -> convert to Mon=0
                let startDow = firstDay.getDay(); // 0=Sun
                startDow = startDow === 0 ? 6 : startDow - 1; // Mon=0

                const gridStart = new Date(firstDay);
                gridStart.setDate(gridStart.getDate() - startDow);

                let endDow = lastDay.getDay();
                endDow = endDow === 0 ? 6 : endDow - 1;
                const gridEnd = new Date(lastDay);
                gridEnd.setDate(gridEnd.getDate() + (6 - endDow));

                const dayNames = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];
                const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];

                const weeks = [];
                let current = new Date(gridStart);
                while (current <= gridEnd) {
                    const week = [];
                    for (let d = 0; d < 7; d++) {
                        const isOutside = current.getMonth() !== month - 1;
                        const isToday = current.getTime() === today.getTime();
                        const y = current.getFullYear();
                        const m = String(current.getMonth() + 1).padStart(2, '0');
                        const day = String(current.getDate()).padStart(2, '0');
                        const dow = current.getDay();
                        const dowIdx = dow === 0 ? 6 : dow - 1;

                        week.push({
                            dayNum: current.getDate(),
                            outside: isOutside,
                            isToday,
                            isoDate: `${y}-${m}-${day}`,
                            label: `${dayNames[dowIdx]}, ${monthNames[current.getMonth()]} ${current.getDate()}, ${y}`
                        });
                        current.setDate(current.getDate() + 1);
                    }
                    weeks.push(week);
                }

                // Pad to 6 weeks if fixedWeeks
                while (fixedWeeks && weeks.length < 6) {
                    const week = [];
                    for (let d = 0; d < 7; d++) {
                        const y = current.getFullYear();
                        const m = String(current.getMonth() + 1).padStart(2, '0');
                        const day = String(current.getDate()).padStart(2, '0');
                        const dow = current.getDay();
                        const dowIdx = dow === 0 ? 6 : dow - 1;
                        week.push({
                            dayNum: current.getDate(),
                            outside: true,
                            isToday: false,
                            isoDate: `${y}-${m}-${day}`,
                            label: `${dayNames[dowIdx]}, ${monthNames[current.getMonth()]} ${current.getDate()}, ${y}`
                        });
                        current.setDate(current.getDate() + 1);
                    }
                    weeks.push(week);
                }

                return weeks;
            },

            // --- DatePicker ---

            _setupDatePicker(root) {
                const id = root.getAttribute('data-suite-datepicker');
                const trigger = root.querySelector(`[data-suite-datepicker-trigger="${id}"]`);
                const content = root.querySelector(`[data-suite-datepicker-content="${id}"]`);

                if (!trigger || !content) return;

                let isOpen = false;

                // Click trigger to open/close
                trigger.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (isOpen) {
                        this._closeDatePicker(root);
                        isOpen = false;
                    } else {
                        this._openDatePicker(root);
                        isOpen = true;
                    }
                });

                // Escape closes
                root.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && isOpen) {
                        e.preventDefault();
                        this._closeDatePicker(root);
                        isOpen = false;
                        trigger.focus();
                    }
                });

                // Click outside closes
                document.addEventListener('pointerdown', (e) => {
                    if (isOpen && !root.contains(e.target)) {
                        this._closeDatePicker(root);
                        isOpen = false;
                    }
                });

                // Track open state
                root._isOpen = () => isOpen;
                root._setOpen = (v) => { isOpen = v; };
            },

            _openDatePicker(root) {
                const id = root.getAttribute('data-suite-datepicker');
                const trigger = root.querySelector(`[data-suite-datepicker-trigger="${id}"]`);
                const content = root.querySelector(`[data-suite-datepicker-content="${id}"]`);
                if (!content) return;

                content.style.display = '';
                content.setAttribute('data-state', 'open');
                trigger.setAttribute('aria-expanded', 'true');
                root._setOpen && root._setOpen(true);

                // Position below trigger using Floating if available
                if (Suite.Floating) {
                    const side = content.getAttribute('data-suite-datepicker-side') || 'bottom';
                    const align = content.getAttribute('data-suite-datepicker-align') || 'start';
                    Suite.Floating.position(trigger, content, side, 0, align);
                }

                // Focus the first focusable day
                requestAnimationFrame(() => {
                    const focusTarget = content.querySelector('[data-suite-calendar-day-btn][tabindex="0"]')
                                     || content.querySelector('[data-suite-calendar-day-btn]');
                    if (focusTarget) focusTarget.focus();
                });
            },

            _closeDatePicker(root) {
                const id = root.getAttribute('data-suite-datepicker');
                const trigger = root.querySelector(`[data-suite-datepicker-trigger="${id}"]`);
                const content = root.querySelector(`[data-suite-datepicker-content="${id}"]`);
                if (!content) return;

                content.setAttribute('data-state', 'closed');
                trigger.setAttribute('aria-expanded', 'false');
                root._setOpen && root._setOpen(false);
                setTimeout(() => { content.style.display = 'none'; }, 150);
            },

            _updateDatePickerDisplay(root, state) {
                const id = root.getAttribute('data-suite-datepicker');
                const valueEl = root.querySelector(`[data-suite-datepicker-value="${id}"]`);
                if (!valueEl) return;

                root.setAttribute('data-suite-datepicker-selected', state.selected.join(','));

                if (state.selected.length === 0) {
                    valueEl.textContent = valueEl.textContent || 'Pick a date';
                    valueEl.classList.add('text-warm-400', 'dark:text-warm-600');
                    return;
                }

                valueEl.classList.remove('text-warm-400', 'dark:text-warm-600');

                const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                const fullMonths = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

                if (state.mode === 'single' && state.selected.length === 1) {
                    const d = new Date(state.selected[0] + 'T00:00:00');
                    valueEl.textContent = `${dayNames[d.getDay()]}, ${fullMonths[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
                } else if (state.mode === 'range' && state.selected.length === 2) {
                    const d1 = new Date(state.selected[0] + 'T00:00:00');
                    const d2 = new Date(state.selected[1] + 'T00:00:00');
                    valueEl.textContent = `${months[d1.getMonth()]} ${d1.getDate()}, ${d1.getFullYear()} – ${months[d2.getMonth()]} ${d2.getDate()}, ${d2.getFullYear()}`;
                } else if (state.mode === 'range' && state.selected.length === 1) {
                    const d = new Date(state.selected[0] + 'T00:00:00');
                    valueEl.textContent = `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()} – ...`;
                } else if (state.mode === 'multiple') {
                    valueEl.textContent = state.selected.length + ' date' + (state.selected.length === 1 ? '' : 's') + ' selected';
                }
            }
        },

        // --- Form -----------------------------------------------------------------
        Form: {
            _initialized: new WeakSet(),

            init() {
                document.querySelectorAll('[data-suite-form]').forEach(form => {
                    if (this._initialized.has(form)) return;
                    this._initialized.add(form);
                    this._setup(form);
                });
            },

            _setup(form) {
                const validateOn = form.getAttribute('data-suite-form-validate-on') || 'submit';

                // Link IDs: label → control, description, message
                this._linkIds(form);

                // Wire validation events
                const fields = form.querySelectorAll('[data-suite-form-field]');
                fields.forEach(field => {
                    const control = this._getControl(field);
                    if (!control) return;

                    if (validateOn === 'change' || validateOn === 'all') {
                        control.addEventListener('input', () => this._validateField(field));
                    }
                    if (validateOn === 'blur' || validateOn === 'all') {
                        control.addEventListener('blur', () => this._validateField(field));
                    }
                });

                // Submit handler
                form.addEventListener('submit', (e) => {
                    let valid = true;
                    fields.forEach(field => {
                        if (!this._validateField(field)) valid = false;
                    });
                    if (!valid) {
                        e.preventDefault();
                        const firstError = form.querySelector('[aria-invalid="true"]');
                        if (firstError) firstError.focus();
                    }
                });
            },

            _linkIds(form) {
                form.querySelectorAll('[data-suite-form-field]').forEach(field => {
                    const fieldId = field.getAttribute('data-suite-form-field-id');
                    if (!fieldId) return;

                    const controlId = fieldId + '-control';
                    const descId = fieldId + '-description';
                    const msgId = fieldId + '-message';

                    const controlWrapper = field.querySelector('[data-suite-form-control]');
                    const control = controlWrapper ? controlWrapper.querySelector('input, select, textarea') : null;
                    const label = field.querySelector('[data-suite-form-label]');
                    const desc = field.querySelector('[data-suite-form-description]');
                    const msg = field.querySelector('[data-suite-form-message]');

                    if (control) control.id = controlId;
                    if (desc) desc.id = descId;
                    if (msg) msg.id = msgId;
                    if (label) label.setAttribute('for', controlId);

                    if (control) {
                        const describedBy = [];
                        if (desc) describedBy.push(descId);
                        if (describedBy.length) control.setAttribute('aria-describedby', describedBy.join(' '));
                    }
                });
            },

            _getControl(field) {
                const wrapper = field.querySelector('[data-suite-form-control]');
                return wrapper ? wrapper.querySelector('input, select, textarea') : null;
            },

            _validateField(field) {
                const control = this._getControl(field);
                if (!control) return true;

                const value = control.value || '';
                const errors = [];

                const required = field.getAttribute('data-suite-form-required');
                if (required !== null && value.trim() === '') {
                    errors.push(required || 'This field is required');
                }

                const minLen = field.getAttribute('data-suite-form-min-length');
                if (minLen && value.length > 0 && value.length < parseInt(minLen)) {
                    const msg = field.getAttribute('data-suite-form-min-length-message') ||
                                'Must be at least ' + minLen + ' characters';
                    errors.push(msg);
                }

                const maxLen = field.getAttribute('data-suite-form-max-length');
                if (maxLen && value.length > parseInt(maxLen)) {
                    const msg = field.getAttribute('data-suite-form-max-length-message') ||
                                'Must be at most ' + maxLen + ' characters';
                    errors.push(msg);
                }

                const pattern = field.getAttribute('data-suite-form-pattern');
                if (pattern && value.length > 0) {
                    const regex = new RegExp('^(?:' + pattern + ')$');
                    if (!regex.test(value)) {
                        const msg = field.getAttribute('data-suite-form-pattern-message') ||
                                    'Invalid format';
                        errors.push(msg);
                    }
                }

                const min = field.getAttribute('data-suite-form-min');
                if (min && value.length > 0 && parseFloat(value) < parseFloat(min)) {
                    errors.push('Must be at least ' + min);
                }
                const max = field.getAttribute('data-suite-form-max');
                if (max && value.length > 0 && parseFloat(value) > parseFloat(max)) {
                    errors.push('Must be at most ' + max);
                }

                const hasError = errors.length > 0;
                const label = field.querySelector('[data-suite-form-label]');
                const msg = field.querySelector('[data-suite-form-message]');
                const fieldId = field.getAttribute('data-suite-form-field-id');
                const desc = field.querySelector('[data-suite-form-description]');

                control.setAttribute('aria-invalid', hasError ? 'true' : 'false');

                if (label) label.setAttribute('data-error', hasError ? 'true' : 'false');

                if (msg) {
                    if (hasError) {
                        msg.textContent = errors[0];
                        msg.classList.remove('hidden');
                        const descId = fieldId + '-description';
                        const msgId = fieldId + '-message';
                        const parts = [];
                        if (desc) parts.push(descId);
                        parts.push(msgId);
                        control.setAttribute('aria-describedby', parts.join(' '));
                    } else {
                        msg.textContent = '';
                        msg.classList.add('hidden');
                        const descId = fieldId + '-description';
                        if (desc) {
                            control.setAttribute('aria-describedby', descId);
                        } else {
                            control.removeAttribute('aria-describedby');
                        }
                    }
                }

                return !hasError;
            },
        },

        // --- DataTable -------------------------------------------------------------
        DataTable: {
            _initialized: new WeakSet(),

            init() {
                document.querySelectorAll('[data-suite-datatable]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);
                    this._setup(root);
                });
            },

            _setup(root) {
                const id = root.getAttribute('data-suite-datatable');
                const pageSize = parseInt(root.getAttribute('data-suite-datatable-page-size')) || 10;
                const sortable = root.getAttribute('data-suite-datatable-sortable') !== 'false';
                const filterable = root.getAttribute('data-suite-datatable-filterable') !== 'false';
                const selectable = root.getAttribute('data-suite-datatable-selectable') === 'true';
                const hasColVis = root.getAttribute('data-suite-datatable-column-visibility') === 'true';

                // Load data from embedded JSON
                const dataStore = root.querySelector(`[data-suite-datatable-store="${id}"]`);
                const colStore = root.querySelector(`[data-suite-datatable-columns="${id}"]`);
                if (!dataStore || !colStore) return;

                let allData;
                let columns;
                try {
                    allData = JSON.parse(dataStore.textContent);
                    columns = JSON.parse(colStore.textContent);
                } catch (e) { return; }

                const state = {
                    data: allData,
                    filtered: [...allData],
                    sorted: [...allData],
                    page: 0,
                    pageSize: pageSize,
                    sortKey: null,
                    sortDir: null, // 'asc' | 'desc' | null
                    filterText: '',
                    filterColumns: [],
                    selected: new Set(),
                    hiddenCols: new Set(),
                    columns: columns,
                };

                // Parse filter columns
                const filterInput = root.querySelector(`[data-suite-datatable-filter="${id}"]`);
                if (filterInput) {
                    const fc = filterInput.getAttribute('data-suite-datatable-filter-columns') || '';
                    state.filterColumns = fc ? fc.split(',').map(s => s.trim()).filter(s => s) : [];
                }

                // Wire filter
                if (filterInput) {
                    filterInput.addEventListener('input', () => {
                        state.filterText = filterInput.value.toLowerCase();
                        state.page = 0;
                        state.selected.clear();
                        this._applyPipeline(root, id, state);
                    });
                }

                // Wire sort buttons
                if (sortable) {
                    root.querySelectorAll(`[data-suite-datatable-sort="${id}"]`).forEach(btn => {
                        btn.addEventListener('click', () => {
                            const key = btn.value;
                            if (state.sortKey === key) {
                                if (state.sortDir === 'asc') state.sortDir = 'desc';
                                else if (state.sortDir === 'desc') { state.sortDir = null; state.sortKey = null; }
                                else state.sortDir = 'asc';
                            } else {
                                state.sortKey = key;
                                state.sortDir = 'asc';
                            }
                            state.page = 0;
                            this._applyPipeline(root, id, state);
                            this._updateSortIcons(root, id, state);
                        });
                    });
                }

                // Wire pagination
                const prevBtn = root.querySelector(`[data-suite-datatable-prev="${id}"]`);
                const nextBtn = root.querySelector(`[data-suite-datatable-next="${id}"]`);
                if (prevBtn) {
                    prevBtn.addEventListener('click', () => {
                        if (state.page > 0) {
                            state.page--;
                            this._render(root, id, state);
                        }
                    });
                }
                if (nextBtn) {
                    nextBtn.addEventListener('click', () => {
                        const totalPages = Math.max(1, Math.ceil(state.sorted.length / state.pageSize));
                        if (state.page < totalPages - 1) {
                            state.page++;
                            this._render(root, id, state);
                        }
                    });
                }

                // Wire select all
                if (selectable) {
                    const selectAll = root.querySelector(`[data-suite-datatable-select-all="${id}"]`);
                    if (selectAll) {
                        selectAll.addEventListener('change', () => {
                            const start = state.page * state.pageSize;
                            const end = Math.min(start + state.pageSize, state.sorted.length);
                            if (selectAll.checked) {
                                for (let i = start; i < end; i++) state.selected.add(i);
                            } else {
                                for (let i = start; i < end; i++) state.selected.delete(i);
                            }
                            this._render(root, id, state);
                        });
                    }
                }

                // Wire column visibility
                if (hasColVis) {
                    const visTrigger = root.querySelector(`[data-suite-datatable-col-vis-trigger="${id}"]`);
                    const visContent = root.querySelector(`[data-suite-datatable-col-vis-content="${id}"]`);
                    if (visTrigger && visContent) {
                        visTrigger.addEventListener('click', (e) => {
                            e.stopPropagation();
                            visContent.classList.toggle('hidden');
                        });
                        document.addEventListener('click', (e) => {
                            if (!visContent.contains(e.target) && e.target !== visTrigger) {
                                visContent.classList.add('hidden');
                            }
                        });
                    }

                    root.querySelectorAll(`[data-suite-datatable-col-toggle="${id}"]`).forEach(cb => {
                        cb.addEventListener('change', () => {
                            const key = cb.value;
                            if (cb.checked) {
                                state.hiddenCols.delete(key);
                            } else {
                                state.hiddenCols.add(key);
                            }
                            // Update check mark
                            const check = root.querySelector(`[data-suite-datatable-col-check="${key}"]`);
                            if (check) check.textContent = cb.checked ? '✓ ' : '  ';
                            this._applyColumnVisibility(root, id, state);
                        });
                    });
                }
            },

            _applyPipeline(root, id, state) {
                // 1. Filter
                const text = state.filterText;
                if (text) {
                    const filterKeys = state.filterColumns.length > 0
                        ? state.filterColumns
                        : state.columns.map(c => c.key);
                    state.filtered = state.data.filter(row => {
                        return filterKeys.some(key => {
                            const val = row[key];
                            return val !== null && val !== undefined &&
                                   String(val).toLowerCase().includes(text);
                        });
                    });
                } else {
                    state.filtered = [...state.data];
                }

                // 2. Sort
                if (state.sortKey && state.sortDir) {
                    const key = state.sortKey;
                    const dir = state.sortDir === 'asc' ? 1 : -1;
                    state.sorted = [...state.filtered].sort((a, b) => {
                        let va = a[key], vb = b[key];
                        if (va == null) va = '';
                        if (vb == null) vb = '';
                        if (typeof va === 'number' && typeof vb === 'number') {
                            return (va - vb) * dir;
                        }
                        return String(va).localeCompare(String(vb)) * dir;
                    });
                } else {
                    state.sorted = [...state.filtered];
                }

                this._render(root, id, state);
            },

            _render(root, id, state) {
                const tbody = root.querySelector(`[data-suite-datatable-body="${id}"]`);
                if (!tbody) return;

                const selectable = root.getAttribute('data-suite-datatable-selectable') === 'true';
                const start = state.page * state.pageSize;
                const end = Math.min(start + state.pageSize, state.sorted.length);
                const pageData = state.sorted.slice(start, end);
                const totalPages = Math.max(1, Math.ceil(state.sorted.length / state.pageSize));

                // Clear tbody
                tbody.innerHTML = '';

                if (pageData.length === 0) {
                    const colspan = state.columns.filter(c => !state.hiddenCols.has(c.key)).length + (selectable ? 1 : 0);
                    const tr = document.createElement('tr');
                    tr.className = 'border-b border-warm-200 dark:border-warm-700';
                    const td = document.createElement('td');
                    td.colSpan = colspan;
                    td.className = 'p-2 align-middle text-center text-warm-500 dark:text-warm-600 h-24';
                    td.textContent = 'No results.';
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                } else {
                    pageData.forEach((row, i) => {
                        const globalIndex = start + i;
                        const isSelected = state.selected.has(globalIndex);
                        const tr = document.createElement('tr');
                        tr.className = 'border-b border-warm-200 dark:border-warm-700 transition-colors hover:bg-warm-100/50 dark:hover:bg-warm-900/50';
                        tr.setAttribute('data-suite-datatable-row', id);
                        tr.setAttribute('data-row-index', String(globalIndex));
                        if (isSelected) tr.setAttribute('data-state', 'selected');

                        if (selectable) {
                            const td = document.createElement('td');
                            td.className = 'w-12 px-2 align-middle';
                            const cb = document.createElement('input');
                            cb.type = 'checkbox';
                            cb.className = 'h-4 w-4 rounded border border-warm-300 dark:border-warm-600 accent-accent-600';
                            cb.setAttribute('data-suite-datatable-select-row', id);
                            cb.value = String(globalIndex);
                            cb.setAttribute('aria-label', 'Select row');
                            cb.checked = isSelected;
                            cb.addEventListener('change', () => {
                                if (cb.checked) state.selected.add(globalIndex);
                                else state.selected.delete(globalIndex);
                                tr.toggleAttribute('data-state', cb.checked);
                                if (cb.checked) tr.setAttribute('data-state', 'selected');
                                else tr.removeAttribute('data-state');
                                this._updateSelectionInfo(root, id, state);
                                this._updateSelectAll(root, id, state);
                            });
                            td.appendChild(cb);
                            tr.appendChild(td);
                        }

                        state.columns.forEach(col => {
                            if (state.hiddenCols.has(col.key)) return;
                            const td = document.createElement('td');
                            const alignClass = col.align === 'right' ? 'text-right' :
                                               col.align === 'center' ? 'text-center' : 'text-left';
                            td.className = 'p-2 align-middle whitespace-nowrap ' + alignClass;
                            td.setAttribute('data-suite-datatable-col', col.key);
                            const val = row[col.key];
                            td.textContent = val != null ? String(val) : '';
                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    });
                }

                // Update pagination controls
                this._updatePagination(root, id, state, totalPages);
                this._updateSelectionInfo(root, id, state);
                this._updateSelectAll(root, id, state);
            },

            _updatePagination(root, id, state, totalPages) {
                const pageInfo = root.querySelector(`[data-suite-datatable-page-info="${id}"]`);
                if (pageInfo) pageInfo.textContent = `Page ${state.page + 1} of ${totalPages}`;

                const prevBtn = root.querySelector(`[data-suite-datatable-prev="${id}"]`);
                if (prevBtn) {
                    if (state.page <= 0) prevBtn.setAttribute('disabled', 'disabled');
                    else prevBtn.removeAttribute('disabled');
                }

                const nextBtn = root.querySelector(`[data-suite-datatable-next="${id}"]`);
                if (nextBtn) {
                    if (state.page >= totalPages - 1) nextBtn.setAttribute('disabled', 'disabled');
                    else nextBtn.removeAttribute('disabled');
                }

                // Update row info
                const rowInfo = root.querySelector(`[data-suite-datatable-row-info="${id}"]`);
                if (rowInfo) rowInfo.textContent = `${state.sorted.length} row(s) total.`;
            },

            _updateSelectionInfo(root, id, state) {
                const info = root.querySelector(`[data-suite-datatable-selection-info="${id}"]`);
                if (info) info.textContent = `${state.selected.size} of ${state.sorted.length} row(s) selected.`;
            },

            _updateSelectAll(root, id, state) {
                const selectAll = root.querySelector(`[data-suite-datatable-select-all="${id}"]`);
                if (!selectAll) return;
                const start = state.page * state.pageSize;
                const end = Math.min(start + state.pageSize, state.sorted.length);
                let allChecked = end > start;
                let someChecked = false;
                for (let i = start; i < end; i++) {
                    if (state.selected.has(i)) someChecked = true;
                    else allChecked = false;
                }
                selectAll.checked = allChecked;
                selectAll.indeterminate = someChecked && !allChecked;
            },

            _updateSortIcons(root, id, state) {
                root.querySelectorAll(`[data-suite-datatable-sort="${id}"]`).forEach(btn => {
                    const key = btn.value;
                    const svg = btn.querySelector('svg');
                    if (!svg) return;
                    if (key === state.sortKey && state.sortDir === 'asc') {
                        svg.innerHTML = '<path d="m7 9 5-5 5 5"/>';
                    } else if (key === state.sortKey && state.sortDir === 'desc') {
                        svg.innerHTML = '<path d="m7 15 5 5 5-5"/>';
                    } else {
                        svg.innerHTML = '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>';
                    }
                });
            },

            _applyColumnVisibility(root, id, state) {
                // Hide/show header cells
                state.columns.forEach(col => {
                    const hidden = state.hiddenCols.has(col.key);
                    root.querySelectorAll(`[data-suite-datatable-col="${col.key}"]`).forEach(el => {
                        el.style.display = hidden ? 'none' : '';
                    });
                    // Also header th
                    const th = root.querySelector(`th[data-suite-datatable-col="${col.key}"]`);
                    if (th) th.style.display = hidden ? 'none' : '';
                });
                // Re-render to update colspan for empty state
                this._applyPipeline(root, id, state);
            },
        },

        // --- SyntaxHighlight (Julia code highlighting) ----------------------------
        SyntaxHighlight: {
            _highlighted: new Set(),

            // Julia keyword list
            _keywords: new Set([
                'function', 'end', 'if', 'else', 'elseif', 'for', 'while', 'return',
                'begin', 'let', 'do', 'try', 'catch', 'finally', 'struct', 'mutable',
                'abstract', 'primitive', 'type', 'module', 'baremodule', 'using',
                'import', 'export', 'const', 'local', 'global', 'macro', 'quote',
                'where', 'in', 'isa', 'break', 'continue', 'new',
            ]),

            // Special values
            _specials: new Set(['true', 'false', 'nothing', 'missing', 'Inf', 'NaN', 'pi']),

            highlight(codeEl) {
                if (this._highlighted.has(codeEl)) return;
                this._highlighted.add(codeEl);

                const text = codeEl.textContent || '';
                if (!text.trim()) return;

                const tokens = this._tokenize(text);
                codeEl.innerHTML = tokens.map(t => this._render(t)).join('');
            },

            _tokenize(text) {
                const tokens = [];
                let i = 0;
                while (i < text.length) {
                    // Triple-quoted string
                    if (text.startsWith('"""', i)) {
                        const end = text.indexOf('"""', i + 3);
                        const j = end === -1 ? text.length : end + 3;
                        tokens.push({ type: 'string', value: text.slice(i, j) });
                        i = j;
                    }
                    // Single-line comment
                    else if (text[i] === '#') {
                        const nl = text.indexOf('\n', i);
                        const j = nl === -1 ? text.length : nl;
                        tokens.push({ type: 'comment', value: text.slice(i, j) });
                        i = j;
                    }
                    // Double-quoted string (with escape handling)
                    else if (text[i] === '"') {
                        let j = i + 1;
                        while (j < text.length && text[j] !== '"') {
                            if (text[j] === '\\') j++; // skip escaped char
                            j++;
                        }
                        j = Math.min(j + 1, text.length);
                        tokens.push({ type: 'string', value: text.slice(i, j) });
                        i = j;
                    }
                    // Single-quoted char
                    else if (text[i] === "'" && (i === 0 || /[\s(,=\[{;]/.test(text[i-1]))) {
                        let j = i + 1;
                        while (j < text.length && text[j] !== "'") {
                            if (text[j] === '\\') j++;
                            j++;
                        }
                        j = Math.min(j + 1, text.length);
                        tokens.push({ type: 'string', value: text.slice(i, j) });
                        i = j;
                    }
                    // Symbol :word
                    else if (text[i] === ':' && i + 1 < text.length && /[a-zA-Z_]/.test(text[i+1]) && (i === 0 || /[\s(,=\[{;]/.test(text[i-1]))) {
                        let j = i + 1;
                        while (j < text.length && /[a-zA-Z0-9_!]/.test(text[j])) j++;
                        tokens.push({ type: 'symbol', value: text.slice(i, j) });
                        i = j;
                    }
                    // Number
                    else if (/[0-9]/.test(text[i]) && (i === 0 || /[\s(,=\[{;+\-*\/<>!^%&|~]/.test(text[i-1]))) {
                        let j = i;
                        if (text[j] === '0' && j + 1 < text.length && (text[j+1] === 'x' || text[j+1] === 'o' || text[j+1] === 'b')) {
                            j += 2;
                            while (j < text.length && /[0-9a-fA-F_]/.test(text[j])) j++;
                        } else {
                            while (j < text.length && /[0-9._eE+\-]/.test(text[j])) j++;
                        }
                        tokens.push({ type: 'number', value: text.slice(i, j) });
                        i = j;
                    }
                    // Word (keyword, identifier, type, function call)
                    else if (/[a-zA-Z_@]/.test(text[i])) {
                        let j = i;
                        if (text[i] === '@') j++; // macro
                        while (j < text.length && /[a-zA-Z0-9_!]/.test(text[j])) j++;

                        const word = text.slice(i, j);

                        // Look ahead for function call: word(
                        if (j < text.length && text[j] === '(') {
                            tokens.push({ type: 'funcall', value: word });
                        } else if (text[i] === '@') {
                            tokens.push({ type: 'macro', value: word });
                        } else if (this._keywords.has(word)) {
                            tokens.push({ type: 'keyword', value: word });
                        } else if (this._specials.has(word)) {
                            tokens.push({ type: 'special', value: word });
                        } else if (/^[A-Z]/.test(word) && word.length > 1) {
                            tokens.push({ type: 'type', value: word });
                        } else {
                            tokens.push({ type: 'plain', value: word });
                        }
                        i = j;
                    }
                    // Operators
                    else if (/[=!<>+\-*\/\\%^&|~]/.test(text[i])) {
                        let j = i + 1;
                        // Multi-char operators: ==, !=, <=, >=, |>, ->, =>, ::, ...
                        while (j < text.length && /[=!<>|>&:]/.test(text[j]) && j - i < 3) j++;
                        tokens.push({ type: 'operator', value: text.slice(i, j) });
                        i = j;
                    }
                    // :: type annotation
                    else if (text[i] === ':' && i + 1 < text.length && text[i+1] === ':') {
                        tokens.push({ type: 'operator', value: '::' });
                        i += 2;
                    }
                    // Everything else (whitespace, punctuation)
                    else {
                        tokens.push({ type: 'plain', value: text[i] });
                        i++;
                    }
                }
                return tokens;
            },

            _render(token) {
                const esc = token.value
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');

                if (token.type === 'plain') return esc;
                return `<span class="suite-hl-${token.type}">${esc}</span>`;
            },
        },

        // --- CodeBlock (copy-to-clipboard + syntax highlighting) -----------------
        CodeBlock: {
            _initialized: new Set(),

            init() {
                document.querySelectorAll('[data-suite-codeblock]').forEach(block => {
                    if (this._initialized.has(block)) return;
                    this._initialized.add(block);

                    // Copy button
                    const copyBtn = block.querySelector('[data-suite-codeblock-copy]');
                    if (copyBtn) {
                        copyBtn.addEventListener('click', () => {
                            const code = block.querySelector('code');
                            if (!code) return;

                            const text = code.textContent || '';
                            navigator.clipboard.writeText(text).then(() => {
                                const original = copyBtn.innerHTML;
                                copyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
                                setTimeout(() => { copyBtn.innerHTML = original; }, 2000);
                            });
                        });
                    }

                    // Syntax highlighting
                    const lang = block.getAttribute('data-suite-codeblock-lang');
                    if (lang === 'julia' || lang === 'jl') {
                        const code = block.querySelector('code');
                        if (code) Suite.SyntaxHighlight.highlight(code);
                    }
                });
            },
        },

        // --- TreeView (expand/collapse + keyboard nav) ----------------------------
        TreeView: {
            _initialized: new Set(),

            init() {
                document.querySelectorAll('[data-suite-treeview]').forEach(tree => {
                    if (this._initialized.has(tree)) return;
                    this._initialized.add(tree);
                    this._setup(tree);
                });
            },

            _setup(tree) {
                // Click handler for items
                tree.addEventListener('click', (e) => {
                    const row = e.target.closest('[data-suite-treeview-item] > div');
                    if (!row) return;
                    const item = row.parentElement;
                    if (item.hasAttribute('data-disabled')) return;

                    const isFolder = item.hasAttribute('data-suite-treeview-folder');
                    if (isFolder) {
                        this._toggle(item);
                    }
                    this._select(tree, item);
                });

                // Keyboard navigation
                tree.addEventListener('keydown', (e) => {
                    const item = e.target.closest('[data-suite-treeview-item]');
                    if (!item) return;

                    const visible = this._getVisibleItems(tree);
                    const idx = visible.indexOf(item);
                    if (idx === -1) return;

                    switch (e.key) {
                        case 'ArrowDown': {
                            e.preventDefault();
                            if (idx < visible.length - 1) {
                                this._focus(visible[idx + 1]);
                            }
                            break;
                        }
                        case 'ArrowUp': {
                            e.preventDefault();
                            if (idx > 0) {
                                this._focus(visible[idx - 1]);
                            }
                            break;
                        }
                        case 'ArrowRight': {
                            e.preventDefault();
                            if (item.hasAttribute('data-suite-treeview-folder')) {
                                if (item.getAttribute('data-suite-treeview-expanded') !== 'true') {
                                    this._expand(item);
                                } else {
                                    // Move to first child
                                    const children = item.querySelector('[data-suite-treeview-children]');
                                    if (children) {
                                        const first = children.querySelector('[data-suite-treeview-item]');
                                        if (first) this._focus(first);
                                    }
                                }
                            }
                            break;
                        }
                        case 'ArrowLeft': {
                            e.preventDefault();
                            if (item.hasAttribute('data-suite-treeview-folder') &&
                                item.getAttribute('data-suite-treeview-expanded') === 'true') {
                                this._collapse(item);
                            } else {
                                // Move to parent
                                const parentGroup = item.closest('[data-suite-treeview-children]');
                                if (parentGroup) {
                                    const parentItem = parentGroup.closest('[data-suite-treeview-item]');
                                    if (parentItem) this._focus(parentItem);
                                }
                            }
                            break;
                        }
                        case 'Enter':
                        case ' ': {
                            e.preventDefault();
                            if (item.hasAttribute('data-suite-treeview-folder')) {
                                this._toggle(item);
                            }
                            this._select(tree, item);
                            break;
                        }
                        case 'Home': {
                            e.preventDefault();
                            if (visible.length > 0) this._focus(visible[0]);
                            break;
                        }
                        case 'End': {
                            e.preventDefault();
                            if (visible.length > 0) this._focus(visible[visible.length - 1]);
                            break;
                        }
                    }
                });
            },

            _getVisibleItems(tree) {
                const items = [];
                const walk = (parent) => {
                    const lis = parent.children;
                    for (const li of lis) {
                        if (li.tagName !== 'LI' || !li.hasAttribute('data-suite-treeview-item')) continue;
                        items.push(li);
                        // Only traverse children if expanded
                        if (li.getAttribute('data-suite-treeview-expanded') === 'true') {
                            const group = li.querySelector(':scope > [data-suite-treeview-children]');
                            if (group) walk(group);
                        }
                    }
                };
                walk(tree);
                return items;
            },

            _toggle(item) {
                if (item.getAttribute('data-suite-treeview-expanded') === 'true') {
                    this._collapse(item);
                } else {
                    this._expand(item);
                }
            },

            _expand(item) {
                item.setAttribute('data-suite-treeview-expanded', 'true');
                item.setAttribute('aria-expanded', 'true');
                const children = item.querySelector(':scope > [data-suite-treeview-children]');
                if (children) children.classList.remove('hidden');
                const chevron = item.querySelector(':scope > div [data-suite-treeview-chevron]');
                if (chevron) chevron.classList.add('rotate-90');
            },

            _collapse(item) {
                item.setAttribute('data-suite-treeview-expanded', 'false');
                item.setAttribute('aria-expanded', 'false');
                const children = item.querySelector(':scope > [data-suite-treeview-children]');
                if (children) children.classList.add('hidden');
                const chevron = item.querySelector(':scope > div [data-suite-treeview-chevron]');
                if (chevron) chevron.classList.remove('rotate-90');
            },

            _select(tree, item) {
                // Deselect all
                tree.querySelectorAll('[data-suite-treeview-selected="true"]').forEach(el => {
                    el.setAttribute('data-suite-treeview-selected', 'false');
                    el.setAttribute('aria-selected', 'false');
                    const row = el.querySelector(':scope > div');
                    if (row) {
                        row.classList.remove('bg-warm-100', 'dark:bg-warm-800', 'text-accent-700', 'dark:text-accent-400');
                        row.classList.add('text-warm-700', 'dark:text-warm-300');
                    }
                });
                // Select clicked item
                item.setAttribute('data-suite-treeview-selected', 'true');
                item.setAttribute('aria-selected', 'true');
                const row = item.querySelector(':scope > div');
                if (row) {
                    row.classList.add('bg-warm-100', 'dark:bg-warm-800', 'text-accent-700', 'dark:text-accent-400');
                    row.classList.remove('text-warm-700', 'dark:text-warm-300');
                }
                this._focus(item);
            },

            _focus(item) {
                // Set tabindex
                const tree = item.closest('[data-suite-treeview]');
                if (tree) {
                    tree.querySelectorAll('[data-suite-treeview-item] > div[tabindex="0"]').forEach(el => {
                        el.setAttribute('tabindex', '-1');
                    });
                }
                const row = item.querySelector(':scope > div');
                if (row) {
                    row.setAttribute('tabindex', '0');
                    row.focus();
                }
            },
        },

        // --- Resizable (drag-to-resize panels) ------------------------------------
        Resizable: {
            _initialized: new Set(),
            _cursorSheet: null,

            init() {
                document.querySelectorAll('[data-suite-resizable-group]').forEach(group => {
                    if (this._initialized.has(group)) return;
                    this._initialized.add(group);
                    this._setup(group);
                });
            },

            _setup(group) {
                const direction = group.getAttribute('data-suite-resizable-direction') || 'horizontal';
                const handles = Array.from(group.querySelectorAll(':scope > [data-suite-resizable-handle]'));
                const panels = Array.from(group.querySelectorAll(':scope > [data-suite-resizable-panel]'));

                // Set correct direction data attribute on handles + aria-orientation
                handles.forEach(handle => {
                    handle.setAttribute('data-suite-resizable-direction', direction);
                    // ARIA: separator orientation is inverse of group direction
                    handle.setAttribute('aria-orientation', direction === 'horizontal' ? 'vertical' : 'horizontal');
                });

                // Auto-distribute sizes for panels with default_size=0
                const explicitTotal = panels.reduce((sum, p) => {
                    const s = parseInt(p.getAttribute('data-suite-resizable-default-size') || '0', 10);
                    return sum + s;
                }, 0);
                const unsized = panels.filter(p => parseInt(p.getAttribute('data-suite-resizable-default-size') || '0', 10) === 0);
                if (unsized.length > 0) {
                    const each = (100 - explicitTotal) / unsized.length;
                    unsized.forEach(p => {
                        p.style.flexGrow = each;
                        p.setAttribute('data-suite-resizable-default-size', String(Math.round(each)));
                    });
                }

                // Get current sizes as percentages
                const getSizes = () => {
                    const total = panels.reduce((s, p) => s + parseFloat(p.style.flexGrow || 1), 0);
                    return panels.map(p => (parseFloat(p.style.flexGrow || 1) / total) * 100);
                };

                // Set sizes from percentage array
                const setSizes = (sizes) => {
                    panels.forEach((p, i) => {
                        p.style.flexGrow = sizes[i];
                    });
                    // Update ARIA on handles
                    handles.forEach((h, i) => {
                        if (panels[i]) {
                            h.setAttribute('aria-valuenow', Math.round(getSizes()[i]));
                        }
                    });
                };

                // Resize by delta percentage on a handle
                const resize = (handleIdx, deltaPct) => {
                    const sizes = getSizes();
                    const beforeIdx = handleIdx;
                    const afterIdx = handleIdx + 1;
                    if (beforeIdx >= panels.length || afterIdx >= panels.length) return;

                    const beforeMin = parseInt(panels[beforeIdx].getAttribute('data-suite-resizable-min-size') || '10', 10);
                    const beforeMax = parseInt(panels[beforeIdx].getAttribute('data-suite-resizable-max-size') || '100', 10);
                    const afterMin = parseInt(panels[afterIdx].getAttribute('data-suite-resizable-min-size') || '10', 10);
                    const afterMax = parseInt(panels[afterIdx].getAttribute('data-suite-resizable-max-size') || '100', 10);

                    let newBefore = sizes[beforeIdx] + deltaPct;
                    let newAfter = sizes[afterIdx] - deltaPct;

                    // Clamp
                    if (newBefore < beforeMin) { newAfter += (newBefore - beforeMin); newBefore = beforeMin; }
                    if (newBefore > beforeMax) { newAfter += (newBefore - beforeMax); newBefore = beforeMax; }
                    if (newAfter < afterMin) { newBefore += (newAfter - afterMin); newAfter = afterMin; }
                    if (newAfter > afterMax) { newBefore += (newAfter - afterMax); newAfter = afterMax; }

                    // Final clamp
                    newBefore = Math.max(beforeMin, Math.min(beforeMax, newBefore));
                    newAfter = Math.max(afterMin, Math.min(afterMax, newAfter));

                    sizes[beforeIdx] = newBefore;
                    sizes[afterIdx] = newAfter;
                    setSizes(sizes);
                };

                // Pointer drag
                handles.forEach((handle, hIdx) => {
                    let dragging = false;
                    let startPos = 0;
                    let groupSize = 0;

                    const onPointerDown = (e) => {
                        e.preventDefault();
                        dragging = true;
                        handle.setAttribute('data-suite-resizable-handle', 'active');
                        startPos = direction === 'horizontal' ? e.clientX : e.clientY;
                        const rect = group.getBoundingClientRect();
                        groupSize = direction === 'horizontal' ? rect.width : rect.height;
                        handle.setPointerCapture(e.pointerId);

                        // Set cursor globally
                        const cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';
                        if (!this._cursorSheet) {
                            this._cursorSheet = new CSSStyleSheet();
                            document.adoptedStyleSheets = [...document.adoptedStyleSheets, this._cursorSheet];
                        }
                        this._cursorSheet.replaceSync(`*, *:hover { cursor: ${cursor} !important; }`);

                        // Disable pointer events on panels (iframes etc)
                        panels.forEach(p => p.style.pointerEvents = 'none');
                    };

                    const onPointerMove = (e) => {
                        if (!dragging) return;
                        const currentPos = direction === 'horizontal' ? e.clientX : e.clientY;
                        const deltaPx = currentPos - startPos;
                        const deltaPct = (deltaPx / groupSize) * 100;
                        startPos = currentPos;
                        resize(hIdx, deltaPct);
                    };

                    const onPointerUp = (e) => {
                        if (!dragging) return;
                        dragging = false;
                        handle.setAttribute('data-suite-resizable-handle', 'inactive');
                        handle.releasePointerCapture(e.pointerId);

                        // Remove cursor override
                        if (this._cursorSheet) {
                            document.adoptedStyleSheets = document.adoptedStyleSheets.filter(s => s !== this._cursorSheet);
                            this._cursorSheet = null;
                        }

                        // Restore pointer events
                        panels.forEach(p => p.style.pointerEvents = '');
                    };

                    handle.addEventListener('pointerdown', onPointerDown);
                    handle.addEventListener('pointermove', onPointerMove);
                    handle.addEventListener('pointerup', onPointerUp);
                    handle.addEventListener('pointercancel', onPointerUp);

                    // Hover state
                    handle.addEventListener('pointerenter', () => {
                        if (!dragging) handle.setAttribute('data-suite-resizable-handle', 'hover');
                    });
                    handle.addEventListener('pointerleave', () => {
                        if (!dragging) handle.setAttribute('data-suite-resizable-handle', 'inactive');
                    });

                    // Keyboard
                    handle.addEventListener('keydown', (e) => {
                        const step = 5; // 5% per keystroke
                        const rect = group.getBoundingClientRect();
                        const gs = direction === 'horizontal' ? rect.width : rect.height;

                        if (direction === 'horizontal') {
                            if (e.key === 'ArrowLeft') { e.preventDefault(); resize(hIdx, -step); }
                            if (e.key === 'ArrowRight') { e.preventDefault(); resize(hIdx, step); }
                        } else {
                            if (e.key === 'ArrowUp') { e.preventDefault(); resize(hIdx, -step); }
                            if (e.key === 'ArrowDown') { e.preventDefault(); resize(hIdx, step); }
                        }
                        if (e.key === 'Home') { e.preventDefault(); resize(hIdx, -100); }
                        if (e.key === 'End') { e.preventDefault(); resize(hIdx, 100); }
                    });
                });

                // Initial ARIA
                handles.forEach((h, i) => {
                    const sizes = getSizes();
                    if (panels[i]) {
                        h.setAttribute('aria-valuenow', Math.round(sizes[i]));
                        h.setAttribute('aria-valuemin', panels[i].getAttribute('data-suite-resizable-min-size') || '10');
                        h.setAttribute('aria-valuemax', panels[i].getAttribute('data-suite-resizable-max-size') || '100');
                    }
                });
            },
        },

        // --- Carousel (scroll-snap navigation + autoplay) --------------------------
        Carousel: {
            _initialized: new Set(),

            init() {
                document.querySelectorAll('[data-suite-carousel]').forEach(root => {
                    if (this._initialized.has(root)) return;
                    this._initialized.add(root);
                    this._setup(root);
                });
            },

            _setup(root) {
                const orientation = root.getAttribute('data-suite-carousel-orientation') || 'horizontal';
                const loop = root.getAttribute('data-suite-carousel-loop') === 'true';
                const autoplay = root.getAttribute('data-suite-carousel-autoplay') === 'true';
                const interval = parseInt(root.getAttribute('data-suite-carousel-autoplay-interval') || '4000', 10);

                const content = root.querySelector('[data-suite-carousel-content]');
                const prevBtn = root.querySelector('[data-suite-carousel-prev]');
                const nextBtn = root.querySelector('[data-suite-carousel-next]');
                if (!content) return;

                const getItems = () => Array.from(content.querySelectorAll('[data-suite-carousel-item]'));

                const scrollToIdx = (idx) => {
                    const items = getItems();
                    if (items.length === 0) return;
                    const target = items[Math.max(0, Math.min(idx, items.length - 1))];
                    target.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                };

                const getCurrentIdx = () => {
                    const items = getItems();
                    if (items.length === 0) return 0;
                    const viewport = root.querySelector('[data-suite-carousel-viewport]');
                    if (!viewport) return 0;
                    const rect = viewport.getBoundingClientRect();
                    const center = orientation === 'horizontal'
                        ? rect.left + rect.width / 2
                        : rect.top + rect.height / 2;
                    let closest = 0;
                    let minDist = Infinity;
                    items.forEach((item, i) => {
                        const ir = item.getBoundingClientRect();
                        const ic = orientation === 'horizontal'
                            ? ir.left + ir.width / 2
                            : ir.top + ir.height / 2;
                        const d = Math.abs(ic - center);
                        if (d < minDist) { minDist = d; closest = i; }
                    });
                    return closest;
                };

                const updateButtons = () => {
                    const items = getItems();
                    const idx = getCurrentIdx();
                    if (prevBtn) {
                        prevBtn.disabled = !loop && idx === 0;
                    }
                    if (nextBtn) {
                        nextBtn.disabled = !loop && idx >= items.length - 1;
                    }
                };

                const goPrev = () => {
                    const items = getItems();
                    const idx = getCurrentIdx();
                    if (idx > 0) {
                        scrollToIdx(idx - 1);
                    } else if (loop && items.length > 0) {
                        scrollToIdx(items.length - 1);
                    }
                };

                const goNext = () => {
                    const items = getItems();
                    const idx = getCurrentIdx();
                    if (idx < items.length - 1) {
                        scrollToIdx(idx + 1);
                    } else if (loop && items.length > 0) {
                        scrollToIdx(0);
                    }
                };

                if (prevBtn) prevBtn.addEventListener('click', () => { goPrev(); setTimeout(updateButtons, 350); });
                if (nextBtn) nextBtn.addEventListener('click', () => { goNext(); setTimeout(updateButtons, 350); });

                // Scroll listener to update button states
                content.addEventListener('scrollend', updateButtons);
                content.addEventListener('scroll', () => { clearTimeout(content._scrollTimer); content._scrollTimer = setTimeout(updateButtons, 150); });

                // Keyboard navigation
                root.addEventListener('keydown', (e) => {
                    if (orientation === 'horizontal') {
                        if (e.key === 'ArrowLeft') { e.preventDefault(); goPrev(); setTimeout(updateButtons, 350); }
                        if (e.key === 'ArrowRight') { e.preventDefault(); goNext(); setTimeout(updateButtons, 350); }
                    } else {
                        if (e.key === 'ArrowUp') { e.preventDefault(); goPrev(); setTimeout(updateButtons, 350); }
                        if (e.key === 'ArrowDown') { e.preventDefault(); goNext(); setTimeout(updateButtons, 350); }
                    }
                });

                // Autoplay
                if (autoplay && interval > 0) {
                    let timer = setInterval(() => { goNext(); setTimeout(updateButtons, 350); }, interval);
                    // Pause on hover
                    root.addEventListener('mouseenter', () => clearInterval(timer));
                    root.addEventListener('mouseleave', () => {
                        timer = setInterval(() => { goNext(); setTimeout(updateButtons, 350); }, interval);
                    });
                }

                // Initial button state
                requestAnimationFrame(updateButtons);
            },
        },

        // --- Auto-Discovery -------------------------------------------------------
        discover() {
            // Scan for data-suite-* attributes and initialize behaviors
            this.ThemeToggle.init();
            this.ThemeSwitcher.init();
            this.Collapsible.init();
            this.Accordion.init();
            this.Tabs.init();
            this.Toggle.init();
            this.ToggleGroup.init();
            this.Switch.init();
            this.Dialog.init();
            this.AlertDialog.init();
            this.Sheet.init();
            this.Drawer.init();
            this.Popover.init();
            this.Tooltip.init();
            this.HoverCard.init();
            this.DropdownMenu.init();
            this.ContextMenu.init();
            this.Menubar.init();
            this.NavigationMenu.init();
            this.Select.init();
            this.Command.init();
            this.Toast.init();
            this.Slider.init();
            this.Calendar.init();
            this.DataTable.init();
            this.Form.init();
            this.CodeBlock.init();
            this.TreeView.init();
            this.Carousel.init();
            this.Resizable.init();
        },

        // --- Init -----------------------------------------------------------------
        init() {
            this.discover();

            // Re-discover on SPA navigation
            // Therapy.jl's client router fires 'therapy:router:loaded' after each navigation
            window.addEventListener('therapy:router:loaded', () => {
                requestAnimationFrame(() => this.discover());
            });
        }
    };

    window.Suite = Suite;

    // Convenience: Suite.toast("Hello") shorthand for Suite.Toast.show()
    // Also: Suite.toast.success(), Suite.toast.error(), etc.
    window.Suite.toast = function(title, opts) { return Suite.Toast.show(title, opts); };
    window.Suite.toast.success = function(title, opts) { return Suite.Toast.success(title, opts); };
    window.Suite.toast.error = function(title, opts) { return Suite.Toast.error(title, opts); };
    window.Suite.toast.warning = function(title, opts) { return Suite.Toast.warning(title, opts); };
    window.Suite.toast.info = function(title, opts) { return Suite.Toast.info(title, opts); };
    window.Suite.toast.dismiss = function(id) { return Suite.Toast.dismiss(id); };
    window.Suite.toast.dismissAll = function() { return Suite.Toast.dismissAll(); };

    Suite.init();
})();
</script></div>
</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-julia.min.js"></script>
<script>
// Therapy.jl Client-Side Router
(function() {
    'use strict';

    // CRITICAL: Prevent re-execution during SPA navigation.
    // On static sites, loadPage() extracts inline scripts from the fetched full HTML page.
    // This router script contains 'TherapyWS' references, so it matches the extraction filter
    // and gets re-executed on every navigation. Without this guard, each execution adds another
    // click listener, causing exponential request duplication (1→2→4→8 navigations per click).
    if (window.TherapyRouter) {
        return;
    }

    const CONFIG = {
        contentSelector: '#page-content',
        basePath: '/WasmTarget.jl',
        partialHeader: 'X-Therapy-Partial',
        // Debug logging - toggle via TherapyRouter.setDebug(true/false)
        debug: false
    };

    // Track current navigation to cancel on rapid clicks
    let currentNavigation = null;

    function log(...args) {
        if (CONFIG.debug) console.log('%c[Router]', 'color: #748ffc', ...args);
    }

    /**
     * Normalize a path by removing trailing slashes and adding leading slash
     */
    function normalizePath(path) {
        if (!path) return '/';
        path = path.replace(/\/+$/g, '') || '/';
        if (!path.startsWith('/')) path = '/' + path;
        return path;
    }

    /**
     * Check if a URL is internal (same origin, not a hash link, etc.)
     */
    function isInternalLink(href, link) {
        if (!href) return false;

        // Skip hash-only links
        if (href.startsWith('#')) return false;

        // Skip javascript: links
        if (href.startsWith('javascript:')) return false;

        // Skip links with download attribute
        if (link.hasAttribute('download')) return false;

        // Skip links targeting new window
        if (link.target === '_blank') return false;

        // Skip links with data-no-router
        if (link.hasAttribute('data-no-router')) return false;

        // External links (different origin)
        if (href.startsWith('http://') || href.startsWith('https://')) {
            try {
                const url = new URL(href);
                if (url.origin !== window.location.origin) return false;
            } catch (e) {
                return false;
            }
        }

        return true;
    }

    /**
     * Resolve a relative URL to absolute path
     *
     * Path resolution rules:
     * - Absolute paths (/foo) -> returned as-is
     * - Full URLs (http://...) -> extract pathname
     * - ./ paths -> resolve against CONFIG.basePath (app root)
     * - Bare paths (foo/) -> resolve against CONFIG.basePath (app root)
     * - ../ paths -> resolve against current URL (for going up directories)
     */
    function resolveUrl(href) {
        log('resolveUrl input:', href);

        // Absolute paths - return as-is
        if (href.startsWith('/')) {
            log('resolveUrl: absolute path, returning as-is:', href);
            return href;
        }

        // Full URLs - extract pathname
        if (href.startsWith('http://') || href.startsWith('https://')) {
            const pathname = new URL(href).pathname;
            log('resolveUrl: full URL, extracted pathname:', pathname);
            return pathname;
        }

        // Parent-relative paths (../) - resolve against current URL
        // This is intentional for going UP from nested routes
        // Example: on /Therapy.jl/book/reactivity/, "../" -> /Therapy.jl/book/
        if (href.startsWith('../')) {
            const resolved = new URL(href, window.location.href).pathname;
            log('resolveUrl: parent-relative resolved:', href, '->', resolved);
            return resolved;
        }

        // Current-directory relative (./) or bare paths - resolve against BASE PATH
        // This fixes the path stacking bug where ./foo on /Therapy.jl/learn/
        // would incorrectly become /Therapy.jl/learn/foo instead of /Therapy.jl/foo
        const base = CONFIG.basePath || '';
        let path = href;

        // Remove leading ./ if present
        if (path.startsWith('./')) {
            path = path.slice(2);
        }

        // Build the final path: basePath + "/" + path
        // Handle edge cases for trailing/leading slashes
        let result;
        if (!path) {
            // ./ alone means "home" (the base path with trailing slash)
            result = base ? base + '/' : '/';
        } else if (base.endsWith('/')) {
            result = base + path;
        } else {
            result = base + '/' + path;
        }

        log('resolveUrl: base-relative resolved:', href, '->', result);
        return result;
    }

    /**
     * Navigate to a new URL using client-side routing
     */
    async function navigate(href, options = {}) {
        const { replace = false, scroll = true } = options;

        const path = resolveUrl(href);
        log('Navigating to:', path);

        // Update browser history
        if (replace) {
            history.replaceState({ path }, '', path);
        } else {
            history.pushState({ path }, '', path);
        }

        // Load the page content
        await loadPage(path);

        // Scroll to top unless disabled
        if (scroll) {
            window.scrollTo({ top: 0, behavior: 'instant' });
        }

        // Update active link states
        updateActiveLinks();
    }

    /**
     * Fetch page content and swap it into the content container
     */
    async function loadPage(path) {
        const container = document.querySelector(CONFIG.contentSelector);
        if (!container) {
            console.error('[Router] Content container not found:', CONFIG.contentSelector);
            window.location.href = path;
            return;
        }

        // Cancel any in-flight navigation (handles rapid clicking)
        if (currentNavigation) {
            currentNavigation.abort();
            log('Cancelled previous navigation');
        }

        // Create new abort controller for this navigation
        const abortController = new AbortController();
        currentNavigation = abortController;

        // Show loading state (optional)
        container.style.opacity = '0.7';
        container.style.transition = 'opacity 0.1s';

        try {
            const response = await fetch(path, {
                headers: {
                    [CONFIG.partialHeader]: '1',
                    'Accept': 'text/html'
                },
                credentials: 'same-origin',
                signal: abortController.signal
            });

            if (!response.ok) {
                throw new Error('HTTP ' + response.status);
            }

            let html = await response.text();

            // Check if this navigation was cancelled while waiting for response
            if (abortController.signal.aborted) {
                return;
            }

            // Check if we got a full HTML document (static site) or partial content (dev server)
            // Full documents start with <!DOCTYPE or <html
            let scriptsToExecute = [];
            if (html.trim().toLowerCase().startsWith('<!doctype') || html.trim().toLowerCase().startsWith('<html')) {
                log('Got full page, extracting content...');
                // Parse the full document and extract just the content area
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const newContent = doc.querySelector(CONFIG.contentSelector);
                if (newContent) {
                    html = newContent.innerHTML;
                } else {
                    // Fallback: try to get body content
                    log('Content selector not found in response, using body');
                    html = doc.body ? doc.body.innerHTML : html;
                }

                // Extract hydration scripts from the body (they're outside #therapy-content)
                // These contain TherapyHydrate registration functions for islands
                const scripts = doc.querySelectorAll('body script:not([src])');
                log('Found', scripts.length, 'inline scripts in body');
                scripts.forEach((script, idx) => {
                    const content = script.textContent;
                    // Only collect Therapy-related scripts (safety check)
                    if (content && (content.includes('TherapyHydrate') || content.includes('TherapyWS'))) {
                        scriptsToExecute.push(content);
                        log('Script', idx, 'contains Therapy code, length:', content.length);
                    } else {
                        log('Script', idx, 'skipped, length:', content ? content.length : 0);
                    }
                });
                if (scriptsToExecute.length > 0) {
                    log('Collected', scriptsToExecute.length, 'hydration scripts to execute');
                } else {
                    log('WARNING: No hydration scripts found!');
                }
            }

            // Swap content
            container.innerHTML = html;
            container.style.opacity = '1';

            // Clear current navigation tracker
            if (currentNavigation === abortController) {
                currentNavigation = null;
            }

            // Execute any hydration scripts extracted from the full page
            // This registers TherapyHydrate functions before we try to call them
            // Set flag to prevent auto-hydration (router will call hydrateIslands)
            window._therapyRouterHydrating = true;
            for (const scriptContent of scriptsToExecute) {
                try {
                    const script = document.createElement('script');
                    script.textContent = scriptContent;
                    document.head.appendChild(script);
                    document.head.removeChild(script);
                    log('Executed hydration script');
                } catch (e) {
                    console.error('[Router] Failed to execute hydration script:', e);
                }
            }
            window._therapyRouterHydrating = false;

            // Re-hydrate all islands in the new content
            await hydrateIslands();

            // Re-run syntax highlighting for code blocks (Prism.js)
            if (typeof Prism !== 'undefined' && Prism.highlightAll) {
                Prism.highlightAll();
            }

            // Re-discover and subscribe to any new server signals in the content
            if (typeof TherapyWS !== 'undefined' && TherapyWS.discoverAndSubscribe) {
                TherapyWS.discoverAndSubscribe();
            }

            // Show static mode warnings on any new ws-example elements
            if (typeof TherapyWS !== 'undefined' && TherapyWS.showStaticModeWarningOnNewElements) {
                TherapyWS.showStaticModeWarningOnNewElements();
            }

            // Dispatch event for any listeners (e.g., Sessions.jl CodeMirror reinit)
            window.dispatchEvent(new CustomEvent('therapy:router:loaded', {
                detail: { path: path }
            }));

            // Call any registered post-navigation callbacks
            if (Array.isArray(window._therapyRouterCallbacks)) {
                for (const callback of window._therapyRouterCallbacks) {
                    try {
                        callback(path);
                    } catch (e) {
                        console.error('[Router] Post-navigation callback error:', e);
                    }
                }
            }

            log('Page loaded successfully');

        } catch (error) {
            // Ignore abort errors (expected when clicking fast)
            if (error.name === 'AbortError') {
                log('Navigation cancelled');
                return;
            }

            console.error('[Router] Failed to load page:', error);
            container.style.opacity = '1';

            // Clear current navigation tracker
            if (currentNavigation === abortController) {
                currentNavigation = null;
            }

            // Fallback to full page navigation
            window.location.href = path;
        }
    }

    /**
     * Re-hydrate therapy-island components that haven't been hydrated yet.
     * Islands in the Layout (like ThemeToggle) persist across SPA navigation,
     * so we skip them to avoid re-fetching WASM and re-initializing state.
     */
    async function hydrateIslands() {
        // Only hydrate islands that haven't been hydrated yet
        // This prevents duplicate WASM fetches for Layout islands like ThemeToggle
        const islands = document.querySelectorAll('therapy-island:not([data-hydrated])');
        const totalIslands = document.querySelectorAll('therapy-island').length;
        log('Hydrating', islands.length, 'new islands (', totalIslands, 'total on page)');

        for (const island of islands) {
            const componentName = island.dataset.component;
            if (!componentName) {
                console.warn('[Router] Found therapy-island without data-component attribute');
                continue;
            }

            // Registry uses lowercase keys (see Hydration.jl)
            const registryKey = componentName.toLowerCase();
            log('Looking for hydration function:', componentName, '-> registry key:', registryKey);
            log('TherapyHydrate registry:', window.TherapyHydrate ? Object.keys(window.TherapyHydrate) : 'undefined');

            // Look for registered hydration function (using lowercase key)
            if (window.TherapyHydrate && typeof window.TherapyHydrate[registryKey] === 'function') {
                try {
                    log('Calling hydration function for:', registryKey);
                    await window.TherapyHydrate[registryKey]();
                    // Mark as hydrated to prevent re-hydration on future navigation
                    island.dataset.hydrated = 'true';
                    log('Hydrated island:', componentName);
                } catch (error) {
                    console.error('[Router] Failed to hydrate island:', componentName, error);
                }
            } else {
                console.warn('[Router] No hydration function found for:', registryKey);
                console.warn('[Router] Available functions:', window.TherapyHydrate ? Object.keys(window.TherapyHydrate) : 'none');
            }
        }
    }

    /**
     * Update active class on navigation links.
     * Three-class model: class (always-on), active_class (when active), inactive_class (when inactive).
     * Swaps inactive_class <-> active_class to avoid CSS conflicts from competing Tailwind utilities.
     */
    function updateActiveLinks() {
        const currentPath = normalizePath(window.location.pathname);

        document.querySelectorAll('[data-navlink]').forEach(link => {
            const href = link.getAttribute('href');
            if (!href) return;

            const linkPath = normalizePath(resolveUrl(href));
            const activeClassAttr = link.dataset.activeClass || 'active';
            const inactiveClassAttr = link.dataset.inactiveClass || '';
            // Split by spaces to handle multiple classes like "text-accent-700 dark:text-accent-400"
            const activeClasses = activeClassAttr.split(/\s+/).filter(c => c.length > 0);
            const inactiveClasses = inactiveClassAttr.split(/\s+/).filter(c => c.length > 0);
            const exact = link.hasAttribute('data-exact');

            let isActive;
            const basePath = normalizePath(CONFIG.basePath || '/');
            if (exact) {
                isActive = linkPath === currentPath;
            } else {
                // Prefix match for nested routes
                // But exclude base path itself (e.g., /Therapy.jl) from prefix matching
                // to avoid Home link being active on all pages
                isActive = currentPath === linkPath ||
                          (linkPath !== '/' && linkPath !== basePath && currentPath.startsWith(linkPath + '/'));
            }

            if (isActive) {
                link.classList.add(...activeClasses);
                if (inactiveClasses.length > 0) link.classList.remove(...inactiveClasses);
            } else {
                link.classList.remove(...activeClasses);
                if (inactiveClasses.length > 0) link.classList.add(...inactiveClasses);
            }
        });
    }

    /**
     * Handle click events on links
     */
    function handleLinkClick(event) {
        // Find the closest anchor tag
        const link = event.target.closest('a[href]');
        if (!link) return;

        const href = link.getAttribute('href');
        log('handleLinkClick: intercepted href=', href, 'from element:', link.tagName);

        // Check if we should handle this link
        if (!isInternalLink(href, link)) {
            log('handleLinkClick: not internal, skipping');
            return;
        }

        log('handleLinkClick: internal link, routing via SPA');

        // Prevent default navigation
        event.preventDefault();

        // Navigate using the router
        navigate(href);
    }

    /**
     * Handle browser back/forward buttons
     */
    function handlePopState(event) {
        const path = window.location.pathname;
        log('Popstate:', path);
        loadPage(path);
    }

    /**
     * Initialize the router
     */
    function init() {
        log('Initializing client-side router');

        // Bind link click handler (delegation on document, capture phase)
        document.addEventListener('click', handleLinkClick, true);

        // Bind popstate for back/forward
        window.addEventListener('popstate', handlePopState);

        // Update active links on initial load
        updateActiveLinks();

        log('Router initialized');
    }

    // Expose API for programmatic navigation
    window.TherapyRouter = {
        navigate,
        loadPage,
        hydrateIslands,
        updateActiveLinks,
        setDebug: (enabled) => { CONFIG.debug = enabled; },
        // Register a callback to run after each navigation
        onNavigate: (callback) => {
            if (!Array.isArray(window._therapyRouterCallbacks)) {
                window._therapyRouterCallbacks = [];
            }
            window._therapyRouterCallbacks.push(callback);
        }
    };

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
</script>
<script>
// Therapy.jl WebSocket Client
(function() {
    'use strict';

    // CRITICAL: Prevent re-execution during SPA navigation
    // ClientRouter extracts and re-executes scripts containing 'TherapyWS' after each navigation.
    // Without this guard, each navigation creates a NEW scope with its own `let ws = null`,
    // causing the duplicate connection check (ws.readyState) to fail and create new connections.
    // This single check fixes the WebSocket connection leak issue.
    if (window.TherapyWS) {
        console.log('[WS] Script already executed, skipping re-initialization');
        return;
    }

    const CONFIG = {
        reconnectDelay: 1000,
        maxReconnectDelay: 30000,
        signals: []
    };

    let ws = null;
    let reconnectAttempts = 0;
    let connectionId = null;
    let isStaticMode = false;

    // Dev mode: localhost/127.0.0.1 gets exponential backoff reconnection.
    // Production: non-localhost gets fast static mode detection (1 retry).
    const isDevMode = (window.location.hostname === 'localhost' ||
                       window.location.hostname === '127.0.0.1');

    // Track signal values for patch application
    let signalValues = {};

    /**
     * Get WebSocket URL based on current page protocol
     */
    function getWsUrl() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        return protocol + '//' + window.location.host + '/ws';
    }

    /**
     * Connect to WebSocket server
     */
    function connect() {
        if (isStaticMode) return;

        // Prevent duplicate connections - check if already connected or connecting
        // This fixes connection leaks during SPA navigation
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
            return;
        }

        try {
            ws = new WebSocket(getWsUrl());

            ws.onopen = function() {
                console.log('[WS] Connected to server');
                reconnectAttempts = 0;

                // Subscribe to configured signals
                CONFIG.signals.forEach(function(sig) {
                    subscribe(sig);
                });

                // Auto-discover and subscribe to signals from data-server-signal attributes
                discoverAndSubscribe();

                // Dispatch connected event
                window.dispatchEvent(new CustomEvent('therapy:ws:connected'));
            };

            ws.onmessage = function(e) {
                try {
                    const msg = JSON.parse(e.data);
                    handleMessage(msg);
                } catch (err) {
                    console.warn('[WS] Failed to parse message:', e.data);
                }
            };

            ws.onclose = function(e) {
                connectionId = null;

                // Dispatch disconnected event
                window.dispatchEvent(new CustomEvent('therapy:ws:disconnected'));

                // Attempt reconnect unless it was a clean close
                if (e.code !== 1000) {
                    if (isDevMode) {
                        // Dev server: exponential backoff reconnection
                        // Handles server restarts, code changes, crashes
                        scheduleReconnect();
                    } else if (reconnectAttempts >= 1) {
                        // Production: two failures → static hosting, stop trying
                        showStaticModeWarning();
                    } else {
                        // Production: first failure → retry once quickly
                        reconnectAttempts++;
                        setTimeout(connect, 500);
                    }
                }
            };

            ws.onerror = function(err) {
                // Dev mode: log connection errors for debugging
                if (isDevMode) {
                    console.warn('[WS] Connection error - server may not be running');
                }
                // Production: suppress verbose logs during static mode detection
            };

        } catch (e) {
            showStaticModeWarning();
        }
    }

    /**
     * Schedule a reconnection attempt with exponential backoff (dev mode only)
     */
    function scheduleReconnect() {
        if (isStaticMode) return;

        const delay = Math.min(
            CONFIG.reconnectDelay * Math.pow(2, reconnectAttempts),
            CONFIG.maxReconnectDelay
        );
        reconnectAttempts++;

        console.log('[WS] Reconnecting in', delay, 'ms (attempt', reconnectAttempts + ')');
        setTimeout(connect, delay);
    }

    /**
     * Handle incoming WebSocket message
     */
    function handleMessage(msg) {
        switch (msg.type) {
            case 'connected':
                connectionId = msg.connection_id;
                console.log('[WS] Connection ID:', connectionId);
                break;

            case 'signal_update':
                handleSignalUpdate(msg.signal, msg.value);
                break;

            case 'signal_patch':
                handleSignalPatch(msg.signal, msg.patch);
                break;

            case 'channel_message':
                handleChannelMessage(msg.channel, msg.data);
                break;

            case 'error':
                console.error('[WS] Server error:', msg.message);
                break;

            case 'pong':
                // Keepalive response, ignore
                break;

            default:
                console.log('[WS] Unknown message type:', msg.type, msg);
        }
    }

    /**
     * Handle a signal update from the server (full value)
     */
    function handleSignalUpdate(signalName, value) {
        console.log('[WS] Signal update:', signalName, '=', value);

        // Store the value for future patch application
        signalValues[signalName] = value;

        // Update via TherapySignals if available (Wasm integration)
        if (window.TherapySignals && window.TherapySignals[signalName]) {
            window.TherapySignals[signalName].set(value);
        }

        // Also update DOM elements with data-server-signal attribute
        updateSignalDOM(signalName, value);

        // Dispatch custom event for custom handlers
        window.dispatchEvent(new CustomEvent('therapy:signal:' + signalName, {
            detail: { value: value }
        }));
    }

    /**
     * Handle a signal patch from the server (RFC 6902 JSON Patch)
     */
    function handleSignalPatch(signalName, patch) {
        console.log('[WS] Signal patch:', signalName, patch);

        // Get current value or initialize
        let value = signalValues[signalName];
        if (value === undefined) {
            value = null;
        }

        // Apply each patch operation
        for (const op of patch) {
            value = applyPatchOp(value, op);
        }

        // Store the new value
        signalValues[signalName] = value;

        // Update via TherapySignals if available (Wasm integration)
        if (window.TherapySignals && window.TherapySignals[signalName]) {
            window.TherapySignals[signalName].set(value);
        }

        // Update DOM elements
        updateSignalDOM(signalName, value);

        // Dispatch custom event
        window.dispatchEvent(new CustomEvent('therapy:signal:' + signalName, {
            detail: { value: value }
        }));
    }

    /**
     * Apply a single JSON patch operation (RFC 6902)
     */
    function applyPatchOp(value, op) {
        const path = op.path;
        const operation = op.op;

        // Root replacement
        if (path === '' || path === '/') {
            if (operation === 'replace' || operation === 'add') {
                return op.value;
            }
            return null;
        }

        // Parse path: "/foo/bar/0" -> ["foo", "bar", "0"]
        const parts = path.split('/').filter(p => p !== '');

        // Handle nested path
        if (operation === 'add' || operation === 'replace') {
            return setAtPath(value, parts, op.value);
        } else if (operation === 'remove') {
            return removeAtPath(value, parts);
        }

        return value;
    }

    /**
     * Set a value at a nested path in an object/array
     */
    function setAtPath(obj, parts, newValue) {
        if (!obj) {
            obj = {};
        }
        if (parts.length === 0) {
            return newValue;
        }

        // Clone to avoid mutation
        obj = JSON.parse(JSON.stringify(obj));

        let current = obj;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (Array.isArray(current)) {
                const idx = parseInt(part, 10);
                if (!current[idx]) {
                    current[idx] = {};
                }
                current = current[idx];
            } else {
                if (!current[part]) {
                    current[part] = {};
                }
                current = current[part];
            }
        }

        const finalPart = parts[parts.length - 1];
        if (Array.isArray(current)) {
            const idx = finalPart === '-' ? current.length : parseInt(finalPart, 10);
            current[idx] = newValue;
        } else {
            current[finalPart] = newValue;
        }

        return obj;
    }

    /**
     * Remove a value at a nested path
     */
    function removeAtPath(obj, parts) {
        if (!obj || parts.length === 0) {
            return obj;
        }

        // Clone to avoid mutation
        obj = JSON.parse(JSON.stringify(obj));

        let current = obj;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (Array.isArray(current)) {
                current = current[parseInt(part, 10)];
            } else {
                current = current[part];
            }
            if (!current) return obj;
        }

        const finalPart = parts[parts.length - 1];
        if (Array.isArray(current)) {
            current.splice(parseInt(finalPart, 10), 1);
        } else {
            delete current[finalPart];
        }

        return obj;
    }

    /**
     * Update DOM elements with data-server-signal or data-bidirectional-signal attribute
     * Leptos-style reactive bindings:
     * - data-server-signal="name" - updates textContent/value
     * - data-signal-html="name" - updates innerHTML (for rich content)
     * - data-signal-class="name:class1,class2" - adds classes when signal is truthy
     * - data-signal-match="name:value:class" - adds class when signal equals value
     */
    function updateSignalDOM(signalName, value) {
        // Update read-only server signal elements (textContent)
        document.querySelectorAll('[data-server-signal="' + signalName + '"]').forEach(function(el) {
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.value = value;
            } else {
                el.textContent = value;
            }
        });

        // Update innerHTML bindings (for rich HTML content like cell output)
        document.querySelectorAll('[data-signal-html="' + signalName + '"]').forEach(function(el) {
            el.innerHTML = value || '';
            // Show/hide based on content
            if (el.hasAttribute('data-signal-hide-empty')) {
                el.classList.toggle('hidden', !value);
            }
        });

        // Update class bindings (add classes when signal is truthy)
        document.querySelectorAll('[data-signal-class^="' + signalName + ':"]').forEach(function(el) {
            const binding = el.getAttribute('data-signal-class');
            const [, classes] = binding.split(':');
            if (classes) {
                const classList = classes.split(',').map(c => c.trim()).filter(c => c);
                if (value) {
                    el.classList.add(...classList);
                } else {
                    el.classList.remove(...classList);
                }
            }
        });

        // Update match bindings (add class when signal equals specific value)
        // Format: data-signal-match="signalName:matchValue:className"
        document.querySelectorAll('[data-signal-match]').forEach(function(el) {
            const bindings = el.getAttribute('data-signal-match').split(';');
            bindings.forEach(function(binding) {
                const parts = binding.trim().split(':');
                if (parts.length >= 3 && parts[0] === signalName) {
                    const matchValue = parts[1];
                    const className = parts[2];
                    if (String(value) === matchValue) {
                        el.classList.add(className);
                    } else {
                        el.classList.remove(className);
                    }
                }
            });
        });

        // Update bidirectional signal elements (only if not focused, to avoid cursor jump)
        document.querySelectorAll('[data-bidirectional-signal="' + signalName + '"]').forEach(function(el) {
            if (document.activeElement === el) {
                // Don't update if user is currently typing in this element
                return;
            }
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.value = value;
            } else {
                el.textContent = value;
            }
        });
    }

    /**
     * Compute a JSON patch between old and new values (client-side)
     * Simplified version - handles basic types
     */
    function computePatch(oldValue, newValue) {
        const patches = [];

        // Handle simple values
        if (typeof oldValue !== 'object' || typeof newValue !== 'object' ||
            oldValue === null || newValue === null ||
            Array.isArray(oldValue) !== Array.isArray(newValue)) {
            if (oldValue !== newValue) {
                patches.push({ op: 'replace', path: '', value: newValue });
            }
            return patches;
        }

        // Handle objects
        if (!Array.isArray(newValue)) {
            // Added or changed keys
            for (const key of Object.keys(newValue)) {
                if (!(key in oldValue)) {
                    patches.push({ op: 'add', path: '/' + key, value: newValue[key] });
                } else if (JSON.stringify(oldValue[key]) !== JSON.stringify(newValue[key])) {
                    patches.push({ op: 'replace', path: '/' + key, value: newValue[key] });
                }
            }
            // Removed keys
            for (const key of Object.keys(oldValue)) {
                if (!(key in newValue)) {
                    patches.push({ op: 'remove', path: '/' + key });
                }
            }
            return patches;
        }

        // For arrays, just replace if different (computing array diff is complex)
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
            patches.push({ op: 'replace', path: '', value: newValue });
        }
        return patches;
    }

    /**
     * Update a bidirectional signal from the client
     * Sends changes to server, which validates and broadcasts to other clients
     */
    function setBidirectional(signalName, newValue) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.warn('[WS] Cannot update signal - not connected');
            return false;
        }

        // Get current value
        const oldValue = signalValues[signalName];

        // Compute patch
        const patch = computePatch(oldValue, newValue);

        if (patch.length === 0) {
            return true; // No change needed
        }

        // Optimistic update - update local state immediately
        signalValues[signalName] = newValue;
        updateSignalDOM(signalName, newValue);

        // Send patch to server
        send({
            type: 'bidirectional_update',
            signal: signalName,
            patch: patch
        });

        console.log('[WS] Bidirectional update:', signalName, patch);
        return true;
    }

    /**
     * Get current value of a signal (for use before setBidirectional)
     */
    function getSignalValue(signalName) {
        return signalValues[signalName];
    }

    /**
     * Handle a channel message from the server
     */
    function handleChannelMessage(channelName, data) {
        console.log('[WS] Channel message:', channelName, data);

        // Dispatch custom event for this channel
        window.dispatchEvent(new CustomEvent('therapy:channel:' + channelName, {
            detail: data
        }));

        // Also dispatch a general channel event
        window.dispatchEvent(new CustomEvent('therapy:channel', {
            detail: { channel: channelName, data: data }
        }));
    }

    /**
     * Send a message on a channel
     */
    function sendMessage(channelName, data) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.warn('[WS] Cannot send message - not connected');
            return false;
        }

        send({
            type: 'channel_message',
            channel: channelName,
            data: data
        });

        console.log('[WS] Sent channel message:', channelName, data);
        return true;
    }

    /**
     * Subscribe to channel messages (convenience for addEventListener)
     */
    function onChannelMessage(channelName, callback) {
        window.addEventListener('therapy:channel:' + channelName, function(e) {
            callback(e.detail);
        });
    }

    /**
     * Add warning banner to a single ws-example element
     */
    function addWarningToElement(el) {
        if (el.querySelector('.ws-warning')) return;

        const warning = document.createElement('div');
        warning.className = 'ws-warning';
        warning.style.cssText = 'background: linear-gradient(135deg, #fef3c7, #fde68a); border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; margin-bottom: 16px; color: #92400e;';
        warning.innerHTML = '<strong style="display: block; margin-bottom: 4px;">\u26A0\uFE0F Live Demo Unavailable</strong>' +
            '<span style="font-size: 14px;">This example requires a WebSocket server. Run locally with:</span>' +
            '<code style="display: block; margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; font-family: monospace;">julia docs/app.jl dev</code>';
        el.insertBefore(warning, el.firstChild);
    }

    /**
     * Show warning when running in static mode (no WebSocket server)
     */
    function showStaticModeWarning() {
        if (isStaticMode) return;
        isStaticMode = true;

        console.log('[WS] Static mode detected - WebSocket features unavailable');

        // Find all WebSocket example containers and add warning
        document.querySelectorAll('[data-ws-example]').forEach(addWarningToElement);

        // Dispatch static mode event
        window.dispatchEvent(new CustomEvent('therapy:ws:static_mode'));
    }

    /**
     * Add warnings to any new ws-example elements loaded after static mode was detected
     * Called by ClientRouter after SPA navigation
     */
    function showStaticModeWarningOnNewElements() {
        if (!isStaticMode) return;

        // Find any new ws-example elements that don't have warnings yet
        document.querySelectorAll('[data-ws-example]').forEach(addWarningToElement);
    }

    // Track subscribed signals to avoid duplicates
    let subscribedSignals = new Set();

    /**
     * Subscribe to a server signal
     */
    function subscribe(signalName) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            if (!subscribedSignals.has(signalName)) {
                subscribedSignals.add(signalName);
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    signal: signalName
                }));
            }
        }
    }

    /**
     * Discover and subscribe to signals from all reactive data attributes
     * Called on connect and after SPA navigation
     */
    function discoverAndSubscribe() {
        // Subscribe to read-only server signals
        document.querySelectorAll('[data-server-signal]').forEach(function(el) {
            var signalName = el.getAttribute('data-server-signal');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to bidirectional signals (also need to receive updates)
        document.querySelectorAll('[data-bidirectional-signal]').forEach(function(el) {
            var signalName = el.getAttribute('data-bidirectional-signal');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to bidirectional:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to HTML signal bindings (innerHTML updates for rich content)
        document.querySelectorAll('[data-signal-html]').forEach(function(el) {
            var signalName = el.getAttribute('data-signal-html');
            if (signalName && !subscribedSignals.has(signalName)) {
                console.log('[WS] Auto-subscribing to html signal:', signalName);
                subscribe(signalName);
            }
        });

        // Subscribe to class match bindings (parse signal names from pattern)
        // Format: "signalName:value:class;signalName2:value2:class2"
        document.querySelectorAll('[data-signal-match]').forEach(function(el) {
            var pattern = el.getAttribute('data-signal-match');
            if (pattern) {
                // Extract unique signal names from pattern
                var parts = pattern.split(';');
                parts.forEach(function(part) {
                    var signalName = part.split(':')[0];
                    if (signalName && !subscribedSignals.has(signalName)) {
                        console.log('[WS] Auto-subscribing to match signal:', signalName);
                        subscribe(signalName);
                    }
                });
            }
        });

        // Subscribe to class toggle bindings
        // Format: "signalName:class1,class2"
        document.querySelectorAll('[data-signal-class]').forEach(function(el) {
            var binding = el.getAttribute('data-signal-class');
            if (binding) {
                var signalName = binding.split(':')[0];
                if (signalName && !subscribedSignals.has(signalName)) {
                    console.log('[WS] Auto-subscribing to class signal:', signalName);
                    subscribe(signalName);
                }
            }
        });
    }

    /**
     * Unsubscribe from a server signal
     */
    function unsubscribe(signalName) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'unsubscribe',
                signal: signalName
            }));
        }
    }

    /**
     * Send a custom action to the server
     */
    function sendAction(signalName, action, payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'action',
                signal: signalName,
                action: action,
                payload: payload
            }));
        }
    }

    /**
     * Send raw message to server
     */
    function send(msg) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(msg));
        }
    }

    /**
     * Check if WebSocket is connected
     */
    function isConnected() {
        return ws && ws.readyState === WebSocket.OPEN;
    }

    /**
     * Get current connection ID
     */
    function getConnectionId() {
        return connectionId;
    }

    /**
     * Manually disconnect
     */
    function disconnect() {
        if (ws) {
            ws.close(1000, 'Client disconnect');
            ws = null;
        }
    }

    // Expose API globally
    window.TherapyWS = {
        connect: connect,
        disconnect: disconnect,
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        discoverAndSubscribe: discoverAndSubscribe,
        showStaticModeWarningOnNewElements: showStaticModeWarningOnNewElements,
        sendAction: sendAction,
        send: send,
        isConnected: isConnected,
        getConnectionId: getConnectionId,
        isStaticMode: function() { return isStaticMode; },
        // Bidirectional signals
        setBidirectional: setBidirectional,
        getSignalValue: getSignalValue,
        computePatch: computePatch,
        // Channel messaging
        sendMessage: sendMessage,
        onChannelMessage: onChannelMessage
    };

    /**
     * Handle data-action clicks (Leptos-style server actions)
     * Elements with data-action="channelName" send channel messages on click
     * Additional data-* attributes are included in the message payload
     */
    function setupActionHandlers() {
        document.addEventListener('click', function(e) {
            const el = e.target.closest('[data-action]');
            if (!el) return;

            const action = el.getAttribute('data-action');
            if (!action) return;

            // Collect all data-* attributes as payload
            const payload = {};
            for (const attr of el.attributes) {
                if (attr.name.startsWith('data-') && attr.name !== 'data-action') {
                    // Convert data-cell-id to cell_id
                    const key = attr.name.substring(5).replace(/-/g, '_');
                    payload[key] = attr.value;
                }
            }

            // Check for confirmation
            if (el.hasAttribute('data-confirm')) {
                const msg = el.getAttribute('data-confirm');
                if (!confirm(msg)) return;
            }

            // Send channel message
            sendMessage(action, payload);

            // Prevent default for links/buttons
            e.preventDefault();
        });
    }

    // Auto-connect when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            connect();
            setupActionHandlers();
        });
    } else {
        connect();
        setupActionHandlers();
    }
})();
</script>
</body>
</html>
